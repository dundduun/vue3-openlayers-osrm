import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isMathMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-5U3IQKTW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-DZZM6G22.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    // for container types, further traverse downwards
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    // SSR only types
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    /* v8 ignore start */
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        // "
        case 39:
          inSingle = true;
          break;
        // '
        case 96:
          inTemplateString = true;
          break;
        // `
        case 40:
          paren++;
          break;
        // (
        case 41:
          paren--;
          break;
        // )
        case 91:
          square++;
          break;
        // [
        case 93:
          square--;
          break;
        // ]
        case 123:
          curly++;
          break;
        // {
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, getExpSource, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, fnExpRE, isFnExpressionBrowser, isFnExpressionNode, isFnExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformBind, transformBindShorthand, injectPrefix, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, transformOn, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(
      true ? `BaseTransition` : ``
    );
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(
      true ? `createElementBlock` : ``
    );
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(
      true ? `createElementVNode` : ``
    );
    CREATE_COMMENT = Symbol(
      true ? `createCommentVNode` : ``
    );
    CREATE_TEXT = Symbol(
      true ? `createTextVNode` : ``
    );
    CREATE_STATIC = Symbol(
      true ? `createStaticVNode` : ``
    );
    RESOLVE_COMPONENT = Symbol(
      true ? `resolveComponent` : ``
    );
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(
      true ? `resolveDirective` : ``
    );
    RESOLVE_FILTER = Symbol(
      true ? `resolveFilter` : ``
    );
    WITH_DIRECTIVES = Symbol(
      true ? `withDirectives` : ``
    );
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(
      true ? `toDisplayString` : ``
    );
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(
      true ? `normalizeClass` : ``
    );
    NORMALIZE_STYLE = Symbol(
      true ? `normalizeStyle` : ``
    );
    NORMALIZE_PROPS = Symbol(
      true ? `normalizeProps` : ``
    );
    GUARD_REACTIVE_PROPS = Symbol(
      true ? `guardReactiveProps` : ``
    );
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(
      true ? `toHandlerKey` : ``
    );
    SET_BLOCK_TRACKING = Symbol(
      true ? `setBlockTracking` : ``
    );
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_CACHE": 2,
      "2": "CAN_CACHE",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index) {
        let line = 1;
        let column = index + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index > newlineIndex) {
            line = i + 2;
            column = index - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (!this.inVPre && c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c)) ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [53]: ``
    };
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
    isMemberExpressionBrowser = (exp) => {
      const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
    isFnExpressionNode = NOOP;
    isFnExpression = isFnExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isIgnoreNewlineTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end) return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          const exp = createSimpleExpression(mod, true, getLoc(start, end));
          currentProp.modifiers.push(exp);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p) => (p.type === 7 ? p.rawName : p.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
                (mod) => mod.content === "sync"
              )) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.rawName
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            // "
            case 20:
            // '
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index = 0; index < stack.length; index++) {
          onCloseTag(stack[index], end - 1);
          emitError(24, stack[index].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*@__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        const memo = findDir(node, "memo");
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
            !(memo && arg && arg.type === 4 && arg.content === "key")) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          exp = void 0;
        }
      }
      if (!exp) {
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
        transformBindShorthand(dir);
        exp = dir.exp;
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.some((mod) => mod.content === "camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.some((mod) => mod.content === "prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.some((mod) => mod.content === "attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    transformBindShorthand = (dir, context) => {
      const arg = dir.arg;
      const propName = camelize(arg.content);
      dir.exp = createSimpleExpression(propName, false, arg.loc);
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`, false, true);
          const isDirKey = keyProp && keyProp.type === 7;
          if (isDirKey && !keyProp.exp) {
            transformBindShorthand(keyProp);
          }
          let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
          const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64,
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached.length))
              );
              context.cached.push(null);
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject" || tag === "math")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          patchFlag === 0 ? void 0 : patchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp);
        const isInlineStatement = !(isMemberExp || isFnExpression(exp));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true,
              true
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source.trim();
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(exp) && !maybeRef) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      } else if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached.length)
            ]);
            context.cached.push(null);
          }
        };
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isCoreComponent: () => isCoreComponent,
  isFnExpression: () => isFnExpression,
  isFnExpressionBrowser: () => isFnExpressionBrowser,
  isFnExpressionNode: () => isFnExpressionNode,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function isValidHTMLNesting(parent, child) {
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, headings, emptySet, onlyValidChildren, onlyValidParents, knownInvalidChildren, knownInvalidParents, validateHtmlNesting, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(
      true ? `vModelCheckbox` : ``
    );
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(
      true ? `vModelSelect` : ``
    );
    V_MODEL_DYNAMIC = Symbol(
      true ? `vModelDynamic` : ``
    );
    V_ON_WITH_MODIFIERS = Symbol(
      true ? `vOnModifiersGuard` : ``
    );
    V_ON_WITH_KEYS = Symbol(
      true ? `vOnKeysGuard` : ``
    );
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(
      true ? `TransitionGroup` : ``
    );
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findDir(node, "bind");
        if (value && isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i].content;
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content.toLowerCase())) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length) return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
    emptySet = /* @__PURE__ */ new Set([]);
    onlyValidChildren = {
      head: /* @__PURE__ */ new Set([
        "base",
        "basefront",
        "bgsound",
        "link",
        "meta",
        "title",
        "noscript",
        "noframes",
        "style",
        "script",
        "template"
      ]),
      optgroup: /* @__PURE__ */ new Set(["option"]),
      select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
      // table
      table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
      tr: /* @__PURE__ */ new Set(["td", "th"]),
      colgroup: /* @__PURE__ */ new Set(["col"]),
      tbody: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["tr"]),
      tfoot: /* @__PURE__ */ new Set(["tr"]),
      // these elements can not have any children elements
      script: emptySet,
      iframe: emptySet,
      option: emptySet,
      textarea: emptySet,
      style: emptySet,
      title: emptySet
    };
    onlyValidParents = {
      // sections
      html: emptySet,
      body: /* @__PURE__ */ new Set(["html"]),
      head: /* @__PURE__ */ new Set(["html"]),
      // table
      td: /* @__PURE__ */ new Set(["tr"]),
      colgroup: /* @__PURE__ */ new Set(["table"]),
      caption: /* @__PURE__ */ new Set(["table"]),
      tbody: /* @__PURE__ */ new Set(["table"]),
      tfoot: /* @__PURE__ */ new Set(["table"]),
      col: /* @__PURE__ */ new Set(["colgroup"]),
      th: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["table"]),
      tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
      // data list
      dd: /* @__PURE__ */ new Set(["dl", "div"]),
      dt: /* @__PURE__ */ new Set(["dl", "div"]),
      // other
      figcaption: /* @__PURE__ */ new Set(["figure"]),
      // li: new Set(["ul", "ol"]),
      summary: /* @__PURE__ */ new Set(["details"]),
      area: /* @__PURE__ */ new Set(["map"])
    };
    knownInvalidChildren = {
      p: /* @__PURE__ */ new Set([
        "address",
        "article",
        "aside",
        "blockquote",
        "center",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "fieldset",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "li",
        "main",
        "nav",
        "menu",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ]),
      svg: /* @__PURE__ */ new Set([
        "b",
        "blockquote",
        "br",
        "code",
        "dd",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "li",
        "menu",
        "meta",
        "ol",
        "p",
        "pre",
        "ruby",
        "s",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "table",
        "u",
        "ul",
        "var"
      ])
    };
    knownInvalidParents = {
      a: /* @__PURE__ */ new Set(["a"]),
      button: /* @__PURE__ */ new Set(["button"]),
      dd: /* @__PURE__ */ new Set(["dd", "dt"]),
      dt: /* @__PURE__ */ new Set(["dd", "dt"]),
      form: /* @__PURE__ */ new Set(["form"]),
      li: /* @__PURE__ */ new Set(["li"]),
      h1: headings,
      h2: headings,
      h3: headings,
      h4: headings,
      h5: headings,
      h6: headings
    };
    validateHtmlNesting = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
        const error = new SyntaxError(
          `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
        );
        error.loc = node.loc;
        context.onWarn(error);
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition, validateHtmlNesting] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = shared.genCacheKey(template, options);
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/vue3-openlayers/dist/vue3-openlayers.common.js
var require_vue3_openlayers_common = __commonJS({
  "node_modules/vue3-openlayers/dist/vue3-openlayers.common.js"(exports, module) {
    module.exports = /******/
    function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
          return value[key2];
        }).bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? (
          /******/
          function getDefault() {
            return module2["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module2;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      /***/
      "00ee": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var test = {};
          test[TO_STRING_TAG] = "z";
          module2.exports = String(test) === "[object z]";
        }
      ),
      /***/
      "01d4": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_exports__["a"] = {
            /**
             * Generic change event. Triggered when the revision counter is increased.
             * @event module:ol/events/Event~BaseEvent#change
             * @api
             */
            CHANGE: "change",
            /**
             * Generic error event. Triggered when an error occurs.
             * @event module:ol/events/Event~BaseEvent#error
             * @api
             */
            ERROR: "error",
            BLUR: "blur",
            CLEAR: "clear",
            CONTEXTMENU: "contextmenu",
            CLICK: "click",
            DBLCLICK: "dblclick",
            DRAGENTER: "dragenter",
            DRAGOVER: "dragover",
            DROP: "drop",
            FOCUS: "focus",
            KEYDOWN: "keydown",
            KEYPRESS: "keypress",
            LOAD: "load",
            RESIZE: "resize",
            TOUCHMOVE: "touchmove",
            WHEEL: "wheel"
          };
        }
      ),
      /***/
      "0366": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var aFunction = __webpack_require__("1c0b");
          module2.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === void 0) return fn;
            switch (length) {
              case 0:
                return function() {
                  return fn.call(that);
                };
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        }
      ),
      /***/
      "0538": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var aFunction = __webpack_require__("1c0b");
          var isObject2 = __webpack_require__("861d");
          var slice = [].slice;
          var factories = {};
          var construct = function(C, argsLength, args) {
            if (!(argsLength in factories)) {
              for (var list = [], i = 0; i < argsLength; i++) list[i] = "a[" + i + "]";
              factories[argsLength] = Function("C,a", "return new C(" + list.join(",") + ")");
            }
            return factories[argsLength](C, args);
          };
          module2.exports = Function.bind || function bind(that) {
            var fn = aFunction(this);
            var partArgs = slice.call(arguments, 1);
            var boundFunction = function bound() {
              var args = partArgs.concat(slice.call(arguments));
              return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
            };
            if (isObject2(fn.prototype)) boundFunction.prototype = fn.prototype;
            return boundFunction;
          };
        }
      ),
      /***/
      "057f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("fc6a");
          var $getOwnPropertyNames = __webpack_require__("241c").f;
          var toString = {}.toString;
          var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          var getWindowNames = function(it) {
            try {
              return $getOwnPropertyNames(it);
            } catch (error) {
              return windowNames.slice();
            }
          };
          module2.exports.f = function getOwnPropertyNames(it) {
            return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
          };
        }
      ),
      /***/
      "06cf": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var propertyIsEnumerableModule = __webpack_require__("d1e7");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          var toIndexedObject = __webpack_require__("fc6a");
          var toPrimitive = __webpack_require__("c04e");
          var has = __webpack_require__("5135");
          var IE8_DOM_DEFINE = __webpack_require__("0cfb");
          var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE) try {
              return $getOwnPropertyDescriptor(O, P);
            } catch (error) {
            }
            if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
          };
        }
      ),
      /***/
      "07ac": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var $values = __webpack_require__("6f53").values;
          $({ target: "Object", stat: true }, {
            values: function values(O) {
              return $values(O);
            }
          });
        }
      ),
      /***/
      "0999": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return createCanvasContext2D;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return outerWidth;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return outerHeight;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return replaceNode;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return removeNode;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return removeChildren;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return replaceChildren;
          });
          var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("617d");
          function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
            var canvas = opt_canvasPool && opt_canvasPool.length ? opt_canvasPool.shift() : _has_js__WEBPACK_IMPORTED_MODULE_0__[
              /* WORKER_OFFSCREEN_CANVAS */
              "g"
            ] ? new OffscreenCanvas(opt_width || 300, opt_height || 300) : document.createElement("canvas");
            if (opt_width) {
              canvas.width = opt_width;
            }
            if (opt_height) {
              canvas.height = opt_height;
            }
            return (
              /** @type {CanvasRenderingContext2D} */
              canvas.getContext("2d", opt_Context2DSettings)
            );
          }
          function outerWidth(element) {
            var width = element.offsetWidth;
            var style = getComputedStyle(element);
            width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
            return width;
          }
          function outerHeight(element) {
            var height = element.offsetHeight;
            var style = getComputedStyle(element);
            height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
            return height;
          }
          function replaceNode(newNode, oldNode) {
            var parent = oldNode.parentNode;
            if (parent) {
              parent.replaceChild(newNode, oldNode);
            }
          }
          function removeNode(node) {
            return node && node.parentNode ? node.parentNode.removeChild(node) : null;
          }
          function removeChildren(node) {
            while (node.lastChild) {
              node.removeChild(node.lastChild);
            }
          }
          function replaceChildren(node, children) {
            var oldChildren = node.childNodes;
            for (var i = 0; true; ++i) {
              var oldChild = oldChildren[i];
              var newChild = children[i];
              if (!oldChild && !newChild) {
                break;
              }
              if (oldChild === newChild) {
                continue;
              }
              if (!oldChild) {
                node.appendChild(newChild);
                continue;
              }
              if (!newChild) {
                node.removeChild(oldChild);
                --i;
                continue;
              }
              node.insertBefore(newChild, oldChild);
            }
          }
        }
      ),
      /***/
      "0cfb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var fails = __webpack_require__("d039");
          var createElement = __webpack_require__("cc12");
          module2.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        }
      ),
      /***/
      "0ec0": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("da5c");
          var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("cef7");
          var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
          var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
          var __extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Target = (
            /** @class */
            function(_super) {
              __extends(Target2, _super);
              function Target2(opt_target) {
                var _this = _super.call(this) || this;
                _this.eventTarget_ = opt_target;
                _this.pendingRemovals_ = null;
                _this.dispatching_ = null;
                _this.listeners_ = null;
                return _this;
              }
              Target2.prototype.addEventListener = function(type, listener) {
                if (!type || !listener) {
                  return;
                }
                var listeners = this.listeners_ || (this.listeners_ = {});
                var listenersForType = listeners[type] || (listeners[type] = []);
                if (listenersForType.indexOf(listener) === -1) {
                  listenersForType.push(listener);
                }
              };
              Target2.prototype.dispatchEvent = function(event) {
                var evt = typeof event === "string" ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__[
                  /* default */
                  "a"
                ](event) : event;
                var type = evt.type;
                if (!evt.target) {
                  evt.target = this.eventTarget_ || this;
                }
                var listeners = this.listeners_ && this.listeners_[type];
                var propagate;
                if (listeners) {
                  var dispatching = this.dispatching_ || (this.dispatching_ = {});
                  var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
                  if (!(type in dispatching)) {
                    dispatching[type] = 0;
                    pendingRemovals[type] = 0;
                  }
                  ++dispatching[type];
                  for (var i = 0, ii = listeners.length; i < ii; ++i) {
                    if ("handleEvent" in listeners[i]) {
                      propagate = /** @type {import("../events.js").ListenerObject} */
                      listeners[i].handleEvent(evt);
                    } else {
                      propagate = /** @type {import("../events.js").ListenerFunction} */
                      listeners[i].call(this, evt);
                    }
                    if (propagate === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                    }
                  }
                  --dispatching[type];
                  if (dispatching[type] === 0) {
                    var pr = pendingRemovals[type];
                    delete pendingRemovals[type];
                    while (pr--) {
                      this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__[
                        /* VOID */
                        "c"
                      ]);
                    }
                    delete dispatching[type];
                  }
                  return propagate;
                }
              };
              Target2.prototype.disposeInternal = function() {
                this.listeners_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[
                  /* clear */
                  "b"
                ])(this.listeners_);
              };
              Target2.prototype.getListeners = function(type) {
                return this.listeners_ && this.listeners_[type] || void 0;
              };
              Target2.prototype.hasListener = function(opt_type) {
                if (!this.listeners_) {
                  return false;
                }
                return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
              };
              Target2.prototype.removeEventListener = function(type, listener) {
                var listeners = this.listeners_ && this.listeners_[type];
                if (listeners) {
                  var index = listeners.indexOf(listener);
                  if (index !== -1) {
                    if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                      listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__[
                        /* VOID */
                        "c"
                      ];
                      ++this.pendingRemovals_[type];
                    } else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                        delete this.listeners_[type];
                      }
                    }
                  }
                }
              };
              return Target2;
            }(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__[
              /* default */
              "a"
            ])
          );
          __webpack_exports__["a"] = Target;
        }
      ),
      /***/
      "1300": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return abstract;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return getUid;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return VERSION;
          });
          function abstract() {
            return (
              /** @type {?} */
              function() {
                throw new Error("Unimplemented abstract method.");
              }()
            );
          }
          var uidCounter_ = 0;
          function getUid(obj) {
            return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
          }
          var VERSION = "6.6.1";
        }
      ),
      /***/
      "159b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var DOMIterables = __webpack_require__("fdbc");
          var forEach = __webpack_require__("17c2");
          var createNonEnumerableProperty = __webpack_require__("9112");
          for (var COLLECTION_NAME in DOMIterables) {
            var Collection = global[COLLECTION_NAME];
            var CollectionPrototype = Collection && Collection.prototype;
            if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
            } catch (error) {
              CollectionPrototype.forEach = forEach;
            }
          }
        }
      ),
      /***/
      "17c2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $forEach = __webpack_require__("b727").forEach;
          var arrayMethodIsStrict = __webpack_require__("a640");
          var STRICT_METHOD = arrayMethodIsStrict("forEach");
          module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
            return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          } : [].forEach;
        }
      ),
      /***/
      "1be4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          module2.exports = getBuiltIn("document", "documentElement");
        }
      ),
      /***/
      "1c0b": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            if (typeof it != "function") {
              throw TypeError(String(it) + " is not a function");
            }
            return it;
          };
        }
      ),
      /***/
      "1c7e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          var ITERATOR = wellKnownSymbol("iterator");
          var SAFE_CLOSING = false;
          try {
            var called = 0;
            var iteratorWithReturn = {
              next: function() {
                return { done: !!called++ };
              },
              "return": function() {
                SAFE_CLOSING = true;
              }
            };
            iteratorWithReturn[ITERATOR] = function() {
              return this;
            };
            Array.from(iteratorWithReturn, function() {
              throw 2;
            });
          } catch (error) {
          }
          module2.exports = function(exec, SKIP_CLOSING) {
            if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
            var ITERATION_SUPPORT = false;
            try {
              var object = {};
              object[ITERATOR] = function() {
                return {
                  next: function() {
                    return { done: ITERATION_SUPPORT = true };
                  }
                };
              };
              exec(object);
            } catch (error) {
            }
            return ITERATION_SUPPORT;
          };
        }
      ),
      /***/
      "1d80": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            if (it == void 0) throw TypeError("Can't call method on " + it);
            return it;
          };
        }
      ),
      /***/
      "1dde": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var wellKnownSymbol = __webpack_require__("b622");
          var V8_VERSION = __webpack_require__("2d00");
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(METHOD_NAME) {
            return V8_VERSION >= 51 || !fails(function() {
              var array = [];
              var constructor = array.constructor = {};
              constructor[SPECIES] = function() {
                return { foo: 1 };
              };
              return array[METHOD_NAME](Boolean).foo !== 1;
            });
          };
        }
      ),
      /***/
      "1e8d": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return listen;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return listenOnce;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return unlistenByKey;
          });
          var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("38f3");
          function listen(target, type, listener, opt_this, opt_once) {
            if (opt_this && opt_this !== target) {
              listener = listener.bind(opt_this);
            }
            if (opt_once) {
              var originalListener_1 = listener;
              listener = function() {
                target.removeEventListener(type, listener);
                originalListener_1.apply(this, arguments);
              };
            }
            var eventsKey = {
              target,
              type,
              listener
            };
            target.addEventListener(type, listener);
            return eventsKey;
          }
          function listenOnce(target, type, listener, opt_this) {
            return listen(target, type, listener, opt_this, true);
          }
          function unlistenByKey(key) {
            if (key && key.target) {
              key.target.removeEventListener(key.type, key.listener);
              Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[
                /* clear */
                "b"
              ])(key);
            }
          }
        }
      ),
      /***/
      "23cb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var max = Math.max;
          var min = Math.min;
          module2.exports = function(index, length) {
            var integer = toInteger(index);
            return integer < 0 ? max(integer + length, 0) : min(integer, length);
          };
        }
      ),
      /***/
      "23e7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var createNonEnumerableProperty = __webpack_require__("9112");
          var redefine = __webpack_require__("6eeb");
          var setGlobal = __webpack_require__("ce4e");
          var copyConstructorProperties = __webpack_require__("e893");
          var isForced = __webpack_require__("94ca");
          module2.exports = function(options, source) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = global;
            } else if (STATIC) {
              target = global[TARGET] || setGlobal(TARGET, {});
            } else {
              target = (global[TARGET] || {}).prototype;
            }
            if (target) for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target, key, sourceProperty, options);
            }
          };
        }
      ),
      /***/
      "241c": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("ca84");
          var enumBugKeys = __webpack_require__("7839");
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        }
      ),
      /***/
      "2532": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var notARegExp = __webpack_require__("5a34");
          var requireObjectCoercible = __webpack_require__("1d80");
          var correctIsRegExpLogic = __webpack_require__("ab13");
          $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
            includes: function includes(searchString) {
              return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        }
      ),
      /***/
      "25a5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          !function(t, i) {
            true ? module2.exports = i() : void 0;
          }(this, function() {
            "use strict";
            function t(t2, r2, e2, a2, h2) {
              !function t3(n2, r3, e3, a3, h3) {
                for (; a3 > e3; ) {
                  if (a3 - e3 > 600) {
                    var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                    t3(n2, r3, m2, c2, h3);
                  }
                  var p2 = n2[r3], d2 = e3, x = a3;
                  for (i(n2, e3, r3), h3(n2[a3], p2) > 0 && i(n2, e3, a3); d2 < x; ) {
                    for (i(n2, d2, x), d2++, x--; h3(n2[d2], p2) < 0; ) d2++;
                    for (; h3(n2[x], p2) > 0; ) x--;
                  }
                  0 === h3(n2[e3], p2) ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
                }
              }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n);
            }
            function i(t2, i2, n2) {
              var r2 = t2[i2];
              t2[i2] = t2[n2], t2[n2] = r2;
            }
            function n(t2, i2) {
              return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
            }
            var r = function(t2) {
              void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
            };
            function e(t2, i2, n2) {
              if (!n2) return i2.indexOf(t2);
              for (var r2 = 0; r2 < i2.length; r2++) if (n2(t2, i2[r2])) return r2;
              return -1;
            }
            function a(t2, i2) {
              h(t2, 0, t2.children.length, i2, t2);
            }
            function h(t2, i2, n2, r2, e2) {
              e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
              for (var a2 = i2; a2 < n2; a2++) {
                var h2 = t2.children[a2];
                o(e2, t2.leaf ? r2(h2) : h2);
              }
              return e2;
            }
            function o(t2, i2) {
              return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
            }
            function s(t2, i2) {
              return t2.minX - i2.minX;
            }
            function l(t2, i2) {
              return t2.minY - i2.minY;
            }
            function f(t2) {
              return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
            }
            function u(t2) {
              return t2.maxX - t2.minX + (t2.maxY - t2.minY);
            }
            function m(t2, i2) {
              return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
            }
            function c(t2, i2) {
              return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
            }
            function p(t2) {
              return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            }
            function d(i2, n2, r2, e2, a2) {
              for (var h2 = [n2, r2]; h2.length; ) if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e2)) {
                var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
                t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
              }
            }
            return r.prototype.all = function() {
              return this._all(this.data, []);
            }, r.prototype.search = function(t2) {
              var i2 = this.data, n2 = [];
              if (!c(t2, i2)) return n2;
              for (var r2 = this.toBBox, e2 = []; i2; ) {
                for (var a2 = 0; a2 < i2.children.length; a2++) {
                  var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
                  c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e2.push(h2));
                }
                i2 = e2.pop();
              }
              return n2;
            }, r.prototype.collides = function(t2) {
              var i2 = this.data;
              if (!c(t2, i2)) return false;
              for (var n2 = []; i2; ) {
                for (var r2 = 0; r2 < i2.children.length; r2++) {
                  var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
                  if (c(t2, a2)) {
                    if (i2.leaf || m(t2, a2)) return true;
                    n2.push(e2);
                  }
                }
                i2 = n2.pop();
              }
              return false;
            }, r.prototype.load = function(t2) {
              if (!t2 || !t2.length) return this;
              if (t2.length < this._minEntries) {
                for (var i2 = 0; i2 < t2.length; i2++) this.insert(t2[i2]);
                return this;
              }
              var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
              if (this.data.children.length) if (this.data.height === n2.height) this._splitRoot(this.data, n2);
              else {
                if (this.data.height < n2.height) {
                  var r2 = this.data;
                  this.data = n2, n2 = r2;
                }
                this._insert(n2, this.data.height - n2.height - 1, true);
              }
              else this.data = n2;
              return this;
            }, r.prototype.insert = function(t2) {
              return t2 && this._insert(t2, this.data.height - 1), this;
            }, r.prototype.clear = function() {
              return this.data = p([]), this;
            }, r.prototype.remove = function(t2, i2) {
              if (!t2) return this;
              for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
                if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
                  var f2 = e(t2, h2.children, i2);
                  if (-1 !== f2) return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
                }
                a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
              }
              return this;
            }, r.prototype.toBBox = function(t2) {
              return t2;
            }, r.prototype.compareMinX = function(t2, i2) {
              return t2.minX - i2.minX;
            }, r.prototype.compareMinY = function(t2, i2) {
              return t2.minY - i2.minY;
            }, r.prototype.toJSON = function() {
              return this.data;
            }, r.prototype.fromJSON = function(t2) {
              return this.data = t2, this;
            }, r.prototype._all = function(t2, i2) {
              for (var n2 = []; t2; ) t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
              return i2;
            }, r.prototype._build = function(t2, i2, n2, r2) {
              var e2, h2 = n2 - i2 + 1, o2 = this._maxEntries;
              if (h2 <= o2) return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
              r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
              var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
              d(t2, i2, n2, l2, this.compareMinX);
              for (var f2 = i2; f2 <= n2; f2 += l2) {
                var u2 = Math.min(f2 + l2 - 1, n2);
                d(t2, f2, u2, s2, this.compareMinY);
                for (var m2 = f2; m2 <= u2; m2 += s2) {
                  var c2 = Math.min(m2 + s2 - 1, u2);
                  e2.children.push(this._build(t2, m2, c2, r2 - 1));
                }
              }
              return a(e2, this.toBBox), e2;
            }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
              for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
                for (var e2 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
                  var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
                  u2 < a2 ? (a2 = u2, e2 = l2 < e2 ? l2 : e2, h2 = s2) : u2 === a2 && l2 < e2 && (e2 = l2, h2 = s2);
                }
                i2 = h2 || i2.children[0];
              }
              var m2, c2;
              return i2;
            }, r.prototype._insert = function(t2, i2, n2) {
              var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
              for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; ) this._split(e2, i2), i2--;
              this._adjustParentBBoxes(r2, e2, i2);
            }, r.prototype._split = function(t2, i2) {
              var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
              this._chooseSplitAxis(n2, e2, r2);
              var h2 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
              o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
            }, r.prototype._splitRoot = function(t2, i2) {
              this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
            }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
              for (var r2, e2, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
                var d2 = h(t2, 0, p2, this.toBBox), x = h(t2, p2, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u2 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x);
                v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
              }
              return r2 || n2 - i2;
            }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
              var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
              this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
            }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
              t2.children.sort(r2);
              for (var e2 = this.toBBox, a2 = h(t2, 0, i2, e2), s2 = h(t2, n2 - i2, n2, e2), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
                var m2 = t2.children[f2];
                o(a2, t2.leaf ? e2(m2) : m2), l2 += u(a2);
              }
              for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
                var p2 = t2.children[c2];
                o(s2, t2.leaf ? e2(p2) : p2), l2 += u(s2);
              }
              return l2;
            }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
              for (var r2 = n2; r2 >= 0; r2--) o(i2[r2], t2);
            }, r.prototype._condense = function(t2) {
              for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--) 0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
            }, r;
          });
        }
      ),
      /***/
      "2a62": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          module2.exports = function(iterator) {
            var returnMethod = iterator["return"];
            if (returnMethod !== void 0) {
              return anObject(returnMethod.call(iterator)).value;
            }
          };
        }
      ),
      /***/
      "2d00": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var userAgent = __webpack_require__("342f");
          var process2 = global.process;
          var versions = process2 && process2.versions;
          var v8 = versions && versions.v8;
          var match, version;
          if (v8) {
            match = v8.split(".");
            version = match[0] < 4 ? 1 : match[0] + match[1];
          } else if (userAgent) {
            match = userAgent.match(/Edge\/(\d+)/);
            if (!match || match[1] >= 74) {
              match = userAgent.match(/Chrome\/(\d+)/);
              if (match) version = match[1];
            }
          }
          module2.exports = version && +version;
        }
      ),
      /***/
      "342f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          module2.exports = getBuiltIn("navigator", "userAgent") || "";
        }
      ),
      /***/
      "35a1": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var classof = __webpack_require__("f5df");
          var Iterators = __webpack_require__("3f8c");
          var wellKnownSymbol = __webpack_require__("b622");
          var ITERATOR = wellKnownSymbol("iterator");
          module2.exports = function(it) {
            if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
        }
      ),
      /***/
      "35a7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return unByKey;
          });
          var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0ec0");
          var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
          var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1e8d");
          var __extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Observable = (
            /** @class */
            function(_super) {
              __extends(Observable2, _super);
              function Observable2() {
                var _this = _super.call(this) || this;
                _this.on = _this.onInternal;
                _this.once = _this.onceInternal;
                _this.un = _this.unInternal;
                _this.revision_ = 0;
                return _this;
              }
              Observable2.prototype.changed = function() {
                ++this.revision_;
                this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[
                  /* default */
                  "a"
                ].CHANGE);
              };
              Observable2.prototype.getRevision = function() {
                return this.revision_;
              };
              Observable2.prototype.onInternal = function(type, listener) {
                if (Array.isArray(type)) {
                  var len = type.length;
                  var keys = new Array(len);
                  for (var i = 0; i < len; ++i) {
                    keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                      /* listen */
                      "a"
                    ])(this, type[i], listener);
                  }
                  return keys;
                } else {
                  return Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                    /* listen */
                    "a"
                  ])(
                    this,
                    /** @type {string} */
                    type,
                    listener
                  );
                }
              };
              Observable2.prototype.onceInternal = function(type, listener) {
                var key;
                if (Array.isArray(type)) {
                  var len = type.length;
                  key = new Array(len);
                  for (var i = 0; i < len; ++i) {
                    key[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                      /* listenOnce */
                      "b"
                    ])(this, type[i], listener);
                  }
                } else {
                  key = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                    /* listenOnce */
                    "b"
                  ])(
                    this,
                    /** @type {string} */
                    type,
                    listener
                  );
                }
                listener.ol_key = key;
                return key;
              };
              Observable2.prototype.unInternal = function(type, listener) {
                var key = (
                  /** @type {Object} */
                  listener.ol_key
                );
                if (key) {
                  unByKey(key);
                } else if (Array.isArray(type)) {
                  for (var i = 0, ii = type.length; i < ii; ++i) {
                    this.removeEventListener(type[i], listener);
                  }
                } else {
                  this.removeEventListener(type, listener);
                }
              };
              return Observable2;
            }(_events_Target_js__WEBPACK_IMPORTED_MODULE_0__[
              /* default */
              "a"
            ])
          );
          Observable.prototype.on;
          Observable.prototype.once;
          Observable.prototype.un;
          function unByKey(key) {
            if (Array.isArray(key)) {
              for (var i = 0, ii = key.length; i < ii; ++i) {
                Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                  /* unlistenByKey */
                  "c"
                ])(key[i]);
              }
            } else {
              Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[
                /* unlistenByKey */
                "c"
              ])(
                /** @type {import("./events.js").EventsKey} */
                key
              );
            }
          }
          __webpack_exports__["a"] = Observable;
        }
      ),
      /***/
      "37e8": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var definePropertyModule = __webpack_require__("9bf2");
          var anObject = __webpack_require__("825a");
          var objectKeys = __webpack_require__("df75");
          module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = objectKeys(Properties);
            var length = keys.length;
            var index = 0;
            var key;
            while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
            return O;
          };
        }
      ),
      /***/
      "38f3": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return assign;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return clear;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return getValues;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return isEmpty;
          });
          var assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
            if (target === void 0 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== void 0 && source !== null) {
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    output[key] = source[key];
                  }
                }
              }
            }
            return output;
          };
          function clear(object) {
            for (var property in object) {
              delete object[property];
            }
          }
          var getValues = typeof Object.values === "function" ? Object.values : function(object) {
            var values = [];
            for (var property in object) {
              values.push(object[property]);
            }
            return values;
          };
          function isEmpty(object) {
            var property;
            for (property in object) {
              return false;
            }
            return !property;
          }
        }
      ),
      /***/
      "3900": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
          var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("592d");
          var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
          var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1e8d");
          var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0999");
          var __extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Control = (
            /** @class */
            function(_super) {
              __extends(Control2, _super);
              function Control2(options) {
                var _this = _super.call(this) || this;
                var element = options.element;
                if (element && !options.target && !element.style.pointerEvents) {
                  element.style.pointerEvents = "auto";
                }
                _this.element = element ? element : null;
                _this.target_ = null;
                _this.map_ = null;
                _this.listenerKeys = [];
                if (options.render) {
                  _this.render = options.render;
                }
                if (options.target) {
                  _this.setTarget(options.target);
                }
                return _this;
              }
              Control2.prototype.disposeInternal = function() {
                Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[
                  /* removeNode */
                  "e"
                ])(this.element);
                _super.prototype.disposeInternal.call(this);
              };
              Control2.prototype.getMap = function() {
                return this.map_;
              };
              Control2.prototype.setMap = function(map) {
                if (this.map_) {
                  Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[
                    /* removeNode */
                    "e"
                  ])(this.element);
                }
                for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
                  Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[
                    /* unlistenByKey */
                    "c"
                  ])(this.listenerKeys[i]);
                }
                this.listenerKeys.length = 0;
                this.map_ = map;
                if (this.map_) {
                  var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
                  target.appendChild(this.element);
                  if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_2__[
                    /* VOID */
                    "c"
                  ]) {
                    this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[
                      /* listen */
                      "a"
                    ])(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__[
                      /* default */
                      "a"
                    ].POSTRENDER, this.render, this));
                  }
                  map.render();
                }
              };
              Control2.prototype.render = function(mapEvent) {
              };
              Control2.prototype.setTarget = function(target) {
                this.target_ = typeof target === "string" ? document.getElementById(target) : target;
              };
              return Control2;
            }(_Object_js__WEBPACK_IMPORTED_MODULE_0__[
              /* default */
              "a"
            ])
          );
          __webpack_exports__["default"] = Control;
        }
      ),
      /***/
      "3bbe": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(it) {
            if (!isObject2(it) && it !== null) {
              throw TypeError("Can't set " + String(it) + " as a prototype");
            }
            return it;
          };
        }
      ),
      /***/
      "3ca3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var charAt = __webpack_require__("6547").charAt;
          var InternalStateModule = __webpack_require__("69f3");
          var defineIterator = __webpack_require__("7dd0");
          var STRING_ITERATOR = "String Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
          defineIterator(String, "String", function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: String(iterated),
              index: 0
            });
          }, function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index = state.index;
            var point;
            if (index >= string.length) return { value: void 0, done: true };
            point = charAt(string, index);
            state.index += point.length;
            return { value: point, done: false };
          });
        }
      ),
      /***/
      "3f8c": (
        /***/
        function(module2, exports2) {
          module2.exports = {};
        }
      ),
      /***/
      "428f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          module2.exports = global;
        }
      ),
      /***/
      "44ad": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var classof = __webpack_require__("c6b6");
          var split = "".split;
          module2.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split.call(it, "") : Object(it);
          } : Object;
        }
      ),
      /***/
      "44d2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          var create = __webpack_require__("7c73");
          var definePropertyModule = __webpack_require__("9bf2");
          var UNSCOPABLES = wellKnownSymbol("unscopables");
          var ArrayPrototype = Array.prototype;
          if (ArrayPrototype[UNSCOPABLES] == void 0) {
            definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
              configurable: true,
              value: create(null)
            });
          }
          module2.exports = function(key) {
            ArrayPrototype[UNSCOPABLES][key] = true;
          };
        }
      ),
      /***/
      "44e7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          var classof = __webpack_require__("c6b6");
          var wellKnownSymbol = __webpack_require__("b622");
          var MATCH = wellKnownSymbol("match");
          module2.exports = function(it) {
            var isRegExp;
            return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
          };
        }
      ),
      /***/
      "4930": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var V8_VERSION = __webpack_require__("2d00");
          var fails = __webpack_require__("d039");
          module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            var symbol = Symbol();
            return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
            !Symbol.sham && V8_VERSION && V8_VERSION < 41;
          });
        }
      ),
      /***/
      "4ae1": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var getBuiltIn = __webpack_require__("d066");
          var aFunction = __webpack_require__("1c0b");
          var anObject = __webpack_require__("825a");
          var isObject2 = __webpack_require__("861d");
          var create = __webpack_require__("7c73");
          var bind = __webpack_require__("0538");
          var fails = __webpack_require__("d039");
          var nativeConstruct = getBuiltIn("Reflect", "construct");
          var NEW_TARGET_BUG = fails(function() {
            function F() {
            }
            return !(nativeConstruct(function() {
            }, [], F) instanceof F);
          });
          var ARGS_BUG = !fails(function() {
            nativeConstruct(function() {
            });
          });
          var FORCED = NEW_TARGET_BUG || ARGS_BUG;
          $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
            construct: function construct(Target, args) {
              aFunction(Target);
              anObject(args);
              var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
              if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
              if (Target == newTarget) {
                switch (args.length) {
                  case 0:
                    return new Target();
                  case 1:
                    return new Target(args[0]);
                  case 2:
                    return new Target(args[0], args[1]);
                  case 3:
                    return new Target(args[0], args[1], args[2]);
                  case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
                }
                var $args = [null];
                $args.push.apply($args, args);
                return new (bind.apply(Target, $args))();
              }
              var proto = newTarget.prototype;
              var instance = create(isObject2(proto) ? proto : Object.prototype);
              var result = Function.apply.call(Target, instance, args);
              return isObject2(result) ? result : instance;
            }
          });
        }
      ),
      /***/
      "4d64": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("fc6a");
          var toLength = __webpack_require__("50c4");
          var toAbsoluteIndex = __webpack_require__("23cb");
          var createMethod = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = toLength(O.length);
              var index = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el) while (length > index) {
                value = O[index++];
                if (value != value) return true;
              }
              else for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
              }
              return !IS_INCLUDES && -1;
            };
          };
          module2.exports = {
            // `Array.prototype.includes` method
            // https://tc39.es/ecma262/#sec-array.prototype.includes
            includes: createMethod(true),
            // `Array.prototype.indexOf` method
            // https://tc39.es/ecma262/#sec-array.prototype.indexof
            indexOf: createMethod(false)
          };
        }
      ),
      /***/
      "4de4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $filter = __webpack_require__("b727").filter;
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            filter: function filter(callbackfn) {
              return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        }
      ),
      /***/
      "4df4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bind = __webpack_require__("0366");
          var toObject = __webpack_require__("7b0b");
          var callWithSafeIterationClosing = __webpack_require__("9bdd");
          var isArrayIteratorMethod = __webpack_require__("e95a");
          var toLength = __webpack_require__("50c4");
          var createProperty = __webpack_require__("8418");
          var getIteratorMethod = __webpack_require__("35a1");
          module2.exports = function from(arrayLike) {
            var O = toObject(arrayLike);
            var C = typeof this == "function" ? this : Array;
            var argumentsLength = arguments.length;
            var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
            var mapping = mapfn !== void 0;
            var iteratorMethod = getIteratorMethod(O);
            var index = 0;
            var length, result, step, iterator, next, value;
            if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
            if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
              iterator = iteratorMethod.call(O);
              next = iterator.next;
              result = new C();
              for (; !(step = next.call(iterator)).done; index++) {
                value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
                createProperty(result, index, value);
              }
            } else {
              length = toLength(O.length);
              result = new C(length);
              for (; length > index; index++) {
                value = mapping ? mapfn(O[index], index) : O[index];
                createProperty(result, index, value);
              }
            }
            result.length = index;
            return result;
          };
        }
      ),
      /***/
      "50c4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var min = Math.min;
          module2.exports = function(argument) {
            return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
          };
        }
      ),
      /***/
      "5135": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toObject = __webpack_require__("7b0b");
          var hasOwnProperty = {}.hasOwnProperty;
          module2.exports = Object.hasOwn || function hasOwn(it, key) {
            return hasOwnProperty.call(toObject(it), key);
          };
        }
      ),
      /***/
      "5692": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var IS_PURE = __webpack_require__("c430");
          var store = __webpack_require__("c6cd");
          (module2.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.14.0",
            mode: IS_PURE ? "pure" : "global",
            copyright: " 2021 Denis Pushkarev (zloirock.ru)"
          });
        }
      ),
      /***/
      "56ef": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          var getOwnPropertyNamesModule = __webpack_require__("241c");
          var getOwnPropertySymbolsModule = __webpack_require__("7418");
          var anObject = __webpack_require__("825a");
          module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
        }
      ),
      /***/
      "57cb": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return TRUE;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return FALSE;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return VOID;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return memoizeOne;
          });
          var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9f5e");
          function TRUE() {
            return true;
          }
          function FALSE() {
            return false;
          }
          function VOID() {
          }
          function memoizeOne(fn) {
            var called = false;
            var lastResult;
            var lastArgs;
            var lastThis;
            return function() {
              var nextArgs = Array.prototype.slice.call(arguments);
              if (!called || this !== lastThis || !Object(_array_js__WEBPACK_IMPORTED_MODULE_0__[
                /* equals */
                "b"
              ])(nextArgs, lastArgs)) {
                called = true;
                lastThis = this;
                lastArgs = nextArgs;
                lastResult = fn.apply(this, arguments);
              }
              return lastResult;
            };
          }
        }
      ),
      /***/
      "5899": (
        /***/
        function(module2, exports2) {
          module2.exports = "	\n\v\f\r \u2028\u2029\uFEFF";
        }
      ),
      /***/
      "58a8": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("1d80");
          var whitespaces = __webpack_require__("5899");
          var whitespace = "[" + whitespaces + "]";
          var ltrim = RegExp("^" + whitespace + whitespace + "*");
          var rtrim = RegExp(whitespace + whitespace + "*$");
          var createMethod = function(TYPE) {
            return function($this) {
              var string = String(requireObjectCoercible($this));
              if (TYPE & 1) string = string.replace(ltrim, "");
              if (TYPE & 2) string = string.replace(rtrim, "");
              return string;
            };
          };
          module2.exports = {
            // `String.prototype.{ trimLeft, trimStart }` methods
            // https://tc39.es/ecma262/#sec-string.prototype.trimstart
            start: createMethod(1),
            // `String.prototype.{ trimRight, trimEnd }` methods
            // https://tc39.es/ecma262/#sec-string.prototype.trimend
            end: createMethod(2),
            // `String.prototype.trim` method
            // https://tc39.es/ecma262/#sec-string.prototype.trim
            trim: createMethod(3)
          };
        }
      ),
      /***/
      "592d": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_exports__["a"] = {
            /**
             * Triggered after a map frame is rendered.
             * @event module:ol/MapEvent~MapEvent#postrender
             * @api
             */
            POSTRENDER: "postrender",
            /**
             * Triggered when the map starts moving.
             * @event module:ol/MapEvent~MapEvent#movestart
             * @api
             */
            MOVESTART: "movestart",
            /**
             * Triggered after the map is moved.
             * @event module:ol/MapEvent~MapEvent#moveend
             * @api
             */
            MOVEEND: "moveend"
          };
        }
      ),
      /***/
      "5a34": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isRegExp = __webpack_require__("44e7");
          module2.exports = function(it) {
            if (isRegExp(it)) {
              throw TypeError("The method doesn't accept regular expressions");
            }
            return it;
          };
        }
      ),
      /***/
      "5bc0": (
        /***/
        function(module2, exports2, __webpack_require__) {
        }
      ),
      /***/
      "5c6c": (
        /***/
        function(module2, exports2) {
          module2.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        }
      ),
      /***/
      "617d": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return FIREFOX;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return WEBKIT;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return MAC;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return DEVICE_PIXEL_RATIO;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return WORKER_OFFSCREEN_CANVAS;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return IMAGE_DECODE;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return PASSIVE_EVENT_LISTENERS;
          });
          var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
          var FIREFOX = ua.indexOf("firefox") !== -1;
          var SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
          var WEBKIT = ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
          var MAC = ua.indexOf("macintosh") !== -1;
          var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
          var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
          var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
          var PASSIVE_EVENT_LISTENERS = function() {
            var passive = false;
            try {
              var options = Object.defineProperty({}, "passive", {
                get: function() {
                  passive = true;
                }
              });
              window.addEventListener("_", null, options);
              window.removeEventListener("_", null, options);
            } catch (error) {
            }
            return passive;
          }();
        }
      ),
      /***/
      "6547": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var requireObjectCoercible = __webpack_require__("1d80");
          var createMethod = function(CONVERT_TO_STRING) {
            return function($this, pos) {
              var S = String(requireObjectCoercible($this));
              var position = toInteger(pos);
              var size = S.length;
              var first, second;
              if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
              first = S.charCodeAt(position);
              return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
            };
          };
          module2.exports = {
            // `String.prototype.codePointAt` method
            // https://tc39.es/ecma262/#sec-string.prototype.codepointat
            codeAt: createMethod(false),
            // `String.prototype.at` method
            // https://github.com/mathiasbynens/String.prototype.at
            charAt: createMethod(true)
          };
        }
      ),
      /***/
      "658f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          !function(t, e) {
            true ? module2.exports = e(__webpack_require__("3900")) : void 0;
          }(this, function(t) {
            "use strict";
            function e(t2) {
              return t2 && "object" == typeof t2 && "default" in t2 ? t2 : { default: t2 };
            }
            var n = e(t), i = "ol-ctx-menu", o = { namespace: i, container: i + "-container", separator: i + "-separator", submenu: i + "-submenu", hidden: i + "-hidden", icon: i + "-icon", zoomIn: i + "-zoom-in", zoomOut: i + "-zoom-out", unselectable: "ol-unselectable" }, s = o, a = "beforeopen", r = "open", l = "close", c = "contextmenu", h = { width: 150, scrollAt: 4, eventType: c, defaultItems: true }, p = [{ text: "Zoom In", classname: o.zoomIn + " " + o.icon, callback: function(t2, e2) {
              var n2 = e2.getView();
              n2.animate({ zoom: +n2.getZoom() + 1, duration: 700, center: t2.coordinate });
            } }, { text: "Zoom Out", classname: o.zoomOut + " " + o.icon, callback: function(t2, e2) {
              var n2 = e2.getView();
              n2.animate({ zoom: +n2.getZoom() - 1, duration: 700, center: t2.coordinate });
            } }];
            function u(t2, e2) {
              if (void 0 === e2 && (e2 = "Assertion failed"), !t2) {
                if ("undefined" != typeof Error) throw new Error(e2);
                throw e2;
              }
            }
            function d(t2) {
              return /^\d+$/.test(t2);
            }
            function m(t2, e2) {
              return t2.classList ? t2.classList.contains(e2) : g(e2).test(t2.className);
            }
            function f(t2, e2, n2) {
              void 0 === e2 && (e2 = window.document);
              var i2 = Array.prototype.slice, o2 = [];
              if (/^(#?[\w-]+|\.[\w-.]+)$/.test(t2)) switch (t2[0]) {
                case "#":
                  o2 = [y(t2.substr(1))];
                  break;
                case ".":
                  o2 = i2.call(e2.getElementsByClassName(t2.substr(1).replace(/\./g, " ")));
                  break;
                default:
                  o2 = i2.call(e2.getElementsByTagName(t2));
              }
              else o2 = i2.call(e2.querySelectorAll(t2));
              return n2 ? o2 : o2[0];
            }
            function y(t2) {
              return t2 = "#" === t2[0] ? t2.substr(1, t2.length) : t2, document.getElementById(t2);
            }
            function v(t2) {
              var e2 = document.createDocumentFragment(), n2 = document.createElement("div");
              for (n2.innerHTML = t2; n2.firstChild; ) e2.appendChild(n2.firstChild);
              return e2;
            }
            function g(t2) {
              return new RegExp("(^|\\s+) " + t2 + " (\\s+|$)");
            }
            function b(t2, e2, n2) {
              t2.classList ? t2.classList.add(e2) : t2.className = (t2.className + " " + e2).trim(), n2 && d(n2) && window.setTimeout(function() {
                return C(t2, e2);
              }, n2);
            }
            function C(t2, e2, n2) {
              t2.classList ? t2.classList.remove(e2) : t2.className = t2.className.replace(g(e2), " ").trim(), n2 && d(n2) && window.setTimeout(function() {
                return b(t2, e2);
              }, n2);
            }
            var E = function(t2) {
              return this.Base = t2, this.map = void 0, this.viewport = void 0, this.coordinateClicked = void 0, this.pixelClicked = void 0, this.lineHeight = 0, this.items = {}, this.opened = false, this.submenu = { left: t2.options.width - 15 + "px", lastLeft: "" }, this.eventHandler = this.handleEvent.bind(this), this.eventMapMoveHandler = this.handleMapMoveEvent.bind(this), this;
            };
            E.prototype.init = function(t2) {
              this.map = t2, this.viewport = t2.getViewport(), this.setListeners(), this.Base.Html.createMenu(), this.lineHeight = this.getItemsLength() > 0 ? this.Base.container.offsetHeight / this.getItemsLength() : this.Base.Html.cloneAndGetLineHeight();
            }, E.prototype.getItemsLength = function() {
              var t2 = this, e2 = 0;
              return Object.keys(this.items).forEach(function(n2) {
                t2.items[n2].submenu || t2.items[n2].separator || e2++;
              }), e2;
            }, E.prototype.getPixelClicked = function() {
              return this.pixelClicked;
            }, E.prototype.getCoordinateClicked = function() {
              return this.coordinateClicked;
            }, E.prototype.positionContainer = function(t2) {
              var e2 = this, n2 = this.Base.container, i2 = this.map.getSize(), o2 = i2[1] - t2[1], a2 = i2[0] - t2[0], r2 = n2.offsetWidth, l2 = Math.round(this.lineHeight * this.getItemsLength()), c2 = f("li." + s.submenu + ">div", n2, true);
              a2 >= r2 ? (n2.style.right = "auto", n2.style.left = t2[0] + 5 + "px") : (n2.style.left = "auto", n2.style.right = "15px"), o2 >= l2 ? (n2.style.bottom = "auto", n2.style.top = t2[1] - 10 + "px") : (n2.style.top = "auto", n2.style.bottom = 0), function t3(e3, n3, i3) {
                if (Array.isArray(e3)) e3.forEach(function(e4) {
                  return t3(e4, n3, i3);
                });
                else for (var o3 = Array.isArray(n3) ? n3 : n3.split(/\s+/), s2 = o3.length; s2--; ) m(e3, o3[s2]) && C(e3, o3[s2], i3);
              }(n2, s.hidden), c2.length && (this.submenu.lastLeft = a2 < 2 * r2 ? "-" + r2 + "px" : this.submenu.left, c2.forEach(function(t3) {
                var n3, i3, s2, a3 = { w: window.innerWidth || document.documentElement.clientWidth, h: window.innerHeight || document.documentElement.clientHeight }, r3 = (i3 = (n3 = t3).getBoundingClientRect(), s2 = document.documentElement, { left: i3.left + window.pageXOffset - s2.clientLeft, top: i3.top + window.pageYOffset - s2.clientTop, width: n3.offsetWidth, height: n3.offsetHeight }), l3 = r3.height, c3 = o2 - l3;
                c3 < 0 && (c3 = l3 - (a3.h - r3.top), t3.style.top = "-" + c3 + "px"), t3.style.left = e2.submenu.lastLeft;
              }));
            }, E.prototype.openMenu = function(t2, e2) {
              this.Base.dispatchEvent({ type: r, pixel: t2, coordinate: e2 }), this.opened = true, this.positionContainer(t2);
            }, E.prototype.closeMenu = function() {
              this.opened = false, function t2(e2, n2, i2) {
                if (Array.isArray(e2)) e2.forEach(function(e3) {
                  return t2(e3, n2);
                });
                else for (var o2 = Array.isArray(n2) ? n2 : n2.split(/\s+/), s2 = o2.length; s2--; ) m(e2, o2[s2]) || b(e2, o2[s2], i2);
              }(this.Base.container, s.hidden), this.Base.dispatchEvent({ type: l });
            }, E.prototype.setListeners = function() {
              this.viewport.addEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.on("movestart", this.eventMapMoveHandler);
            }, E.prototype.removeListeners = function() {
              this.viewport.removeEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.un("movestart", this.eventMapMoveHandler);
            }, E.prototype.handleEvent = function(t2) {
              var e2 = this;
              this.coordinateClicked = this.map.getEventCoordinate(t2), this.pixelClicked = this.map.getEventPixel(t2), this.Base.dispatchEvent({ type: a, pixel: this.pixelClicked, coordinate: this.coordinateClicked }), this.Base.disabled || (this.Base.options.eventType === c && (t2.stopPropagation(), t2.preventDefault()), this.openMenu(this.pixelClicked, this.coordinateClicked), t2.target.addEventListener("pointerdown", { handleEvent: function(n2) {
                e2.opened && (e2.closeMenu(), n2.stopPropagation(), t2.target.removeEventListener(n2.type, this, false));
              } }, false));
            }, E.prototype.handleMapMoveEvent = function(t2) {
              this.closeMenu();
            }, E.prototype.setItemListener = function(t2, e2) {
              var n2, i2 = this;
              t2 && "function" == typeof this.items[e2].callback && (n2 = this.items[e2].callback, t2.addEventListener("click", function(t3) {
                t3.preventDefault();
                var o2 = { coordinate: i2.getCoordinateClicked(), data: i2.items[e2].data || null };
                i2.closeMenu(), n2(o2, i2.map);
              }, false));
            };
            var w = function(t2) {
              return this.Base = t2, this.Base.container = this.container = this.createContainer(true), this;
            };
            return w.prototype.createContainer = function(t2) {
              var e2 = document.createElement("div"), n2 = document.createElement("ul"), i2 = [s.container, s.unselectable];
              return t2 && i2.push(s.hidden), e2.className = i2.join(" "), e2.style.width = parseInt(this.Base.options.width, 10) + "px", e2.appendChild(n2), e2;
            }, w.prototype.createMenu = function() {
              var t2 = [];
              if ("items" in this.Base.options ? t2 = this.Base.options.defaultItems ? this.Base.options.items.concat(p) : this.Base.options.items : this.Base.options.defaultItems && (t2 = p), 0 === t2.length) return false;
              t2.forEach(this.addMenuEntry, this);
            }, w.prototype.addMenuEntry = function(t2) {
              var e2, n2 = this;
              if (t2.items && Array.isArray(t2.items)) {
                t2.classname = t2.classname || "", e2 = s.submenu, ~t2.classname.indexOf(e2) || (t2.classname = t2.classname.length ? " " + s.submenu : s.submenu);
                var i2 = this.generateHtmlAndPublish(this.container, t2), o2 = this.createContainer();
                o2.style.left = this.Base.Internal.submenu.lastLeft || this.Base.Internal.submenu.left, i2.appendChild(o2), t2.items.forEach(function(t3) {
                  n2.generateHtmlAndPublish(o2, t3, true);
                });
              } else this.generateHtmlAndPublish(this.container, t2);
            }, w.prototype.generateHtmlAndPublish = function(t2, e2, n2) {
              var i2, o2, a2 = "_" + Math.random().toString(36).substr(2, 9), r2 = false;
              return "string" == typeof e2 && "-" === e2.trim() ? (i2 = v('<li id="' + a2 + '" class="' + s.separator + '"><hr></li>'), o2 = [].slice.call(i2.childNodes, 0)[0], t2.firstChild.appendChild(i2), r2 = true) : (e2.classname = e2.classname || "", i2 = v("<span>" + e2.text + "</span>"), o2 = document.createElement("li"), e2.icon && ("" === e2.classname ? e2.classname = s.icon : -1 === e2.classname.indexOf(s.icon) && (e2.classname += " " + s.icon), o2.setAttribute("style", "background-image:url(" + e2.icon + ")")), o2.id = a2, o2.className = e2.classname, o2.appendChild(i2), t2.firstChild.appendChild(o2)), this.Base.Internal.items[a2] = { id: a2, submenu: n2 || 0, separator: r2, callback: e2.callback, data: e2.data || null }, this.Base.Internal.setItemListener(o2, a2), o2;
            }, w.prototype.removeMenuEntry = function(t2) {
              var e2 = f("#" + t2, this.container.firstChild);
              e2 && this.container.firstChild.removeChild(e2), delete this.Base.Internal.items[t2];
            }, w.prototype.cloneAndGetLineHeight = function() {
              var t2 = this.container.cloneNode(), e2 = v("<span>Foo</span>"), n2 = v("<span>Foo</span>"), i2 = document.createElement("li"), o2 = document.createElement("li");
              i2.appendChild(e2), o2.appendChild(n2), t2.appendChild(i2), t2.appendChild(o2), this.container.parentNode.appendChild(t2);
              var s2 = t2.offsetHeight / 2;
              return this.container.parentNode.removeChild(t2), s2;
            }, function(t2) {
              function e2(e3) {
                void 0 === e3 && (e3 = {}), u("object" == typeof e3, "@param `opt_options` should be object type!"), this.options = function(t3, e4) {
                  var n2 = {};
                  for (var i2 in t3) n2[i2] = t3[i2];
                  for (var o2 in e4) n2[o2] = e4[o2];
                  return n2;
                }(h, e3), this.disabled = false, this.Internal = new E(this), this.Html = new w(this), t2.call(this, { element: this.container });
              }
              return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.clear = function() {
                Object.keys(this.Internal.items).forEach(this.Html.removeMenuEntry, this.Html);
              }, e2.prototype.close = function() {
                this.Internal.closeMenu();
              }, e2.prototype.enable = function() {
                this.disabled = false;
              }, e2.prototype.disable = function() {
                this.disabled = true;
              }, e2.prototype.getDefaultItems = function() {
                return p;
              }, e2.prototype.countItems = function() {
                return Object.keys(this.Internal.items).length;
              }, e2.prototype.extend = function(t3) {
                u(Array.isArray(t3), "@param `arr` should be an Array."), t3.forEach(this.push, this);
              }, e2.prototype.isOpen = function() {
                return this.Internal.opened;
              }, e2.prototype.updatePosition = function(t3) {
                u(Array.isArray(t3), "@param `pixel` should be an Array."), this.isOpen() && this.Internal.positionContainer(t3);
              }, e2.prototype.pop = function() {
                var t3 = Object.keys(this.Internal.items);
                this.Html.removeMenuEntry(t3[t3.length - 1]);
              }, e2.prototype.push = function(t3) {
                u(null != t3, "@param `item` must be informed."), this.Html.addMenuEntry(t3);
              }, e2.prototype.shift = function() {
                this.Html.removeMenuEntry(Object.keys(this.Internal.items)[0]);
              }, e2.prototype.setMap = function(e3) {
                t2.prototype.setMap.call(this, e3), e3 ? this.Internal.init(e3, this) : this.Internal.removeListeners();
              }, e2;
            }(n.default);
          });
        }
      ),
      /***/
      "65f0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          var isArray2 = __webpack_require__("e8b5");
          var wellKnownSymbol = __webpack_require__("b622");
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(originalArray, length) {
            var C;
            if (isArray2(originalArray)) {
              C = originalArray.constructor;
              if (typeof C == "function" && (C === Array || isArray2(C.prototype))) C = void 0;
              else if (isObject2(C)) {
                C = C[SPECIES];
                if (C === null) C = void 0;
              }
            }
            return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
          };
        }
      ),
      /***/
      "69f3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
          var global = __webpack_require__("da84");
          var isObject2 = __webpack_require__("861d");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var objectHas = __webpack_require__("5135");
          var shared = __webpack_require__("c6cd");
          var sharedKey = __webpack_require__("f772");
          var hiddenKeys = __webpack_require__("d012");
          var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
          var WeakMap2 = global.WeakMap;
          var set, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject2(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP || shared.state) {
            var store = shared.state || (shared.state = new WeakMap2());
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set = function(it, metadata) {
              if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              createNonEnumerableProperty(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return objectHas(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return objectHas(it, STATE);
            };
          }
          module2.exports = {
            set,
            get,
            has,
            enforce,
            getterFor
          };
        }
      ),
      /***/
      "6eeb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var has = __webpack_require__("5135");
          var setGlobal = __webpack_require__("ce4e");
          var inspectSource = __webpack_require__("8925");
          var InternalStateModule = __webpack_require__("69f3");
          var getInternalState = InternalStateModule.get;
          var enforceInternalState = InternalStateModule.enforce;
          var TEMPLATE = String(String).split("String");
          (module2.exports = function(O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            var state;
            if (typeof value == "function") {
              if (typeof key == "string" && !has(value, "name")) {
                createNonEnumerableProperty(value, "name", key);
              }
              state = enforceInternalState(value);
              if (!state.source) {
                state.source = TEMPLATE.join(typeof key == "string" ? key : "");
              }
            }
            if (O === global) {
              if (simple) O[key] = value;
              else setGlobal(key, value);
              return;
            } else if (!unsafe) {
              delete O[key];
            } else if (!noTargetGet && O[key]) {
              simple = true;
            }
            if (simple) O[key] = value;
            else createNonEnumerableProperty(O, key, value);
          })(Function.prototype, "toString", function toString() {
            return typeof this == "function" && getInternalState(this).source || inspectSource(this);
          });
        }
      ),
      /***/
      "6f53": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var objectKeys = __webpack_require__("df75");
          var toIndexedObject = __webpack_require__("fc6a");
          var propertyIsEnumerable = __webpack_require__("d1e7").f;
          var createMethod = function(TO_ENTRIES) {
            return function(it) {
              var O = toIndexedObject(it);
              var keys = objectKeys(O);
              var length = keys.length;
              var i = 0;
              var result = [];
              var key;
              while (length > i) {
                key = keys[i++];
                if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
                  result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
                }
              }
              return result;
            };
          };
          module2.exports = {
            // `Object.entries` method
            // https://tc39.es/ecma262/#sec-object.entries
            entries: createMethod(true),
            // `Object.values` method
            // https://tc39.es/ecma262/#sec-object.values
            values: createMethod(false)
          };
        }
      ),
      /***/
      "7156": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          var setPrototypeOf = __webpack_require__("d2bb");
          module2.exports = function($this, dummy, Wrapper) {
            var NewTarget, NewTargetPrototype;
            if (
              // it can work only with native `setPrototypeOf`
              setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
              typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
            ) setPrototypeOf($this, NewTargetPrototype);
            return $this;
          };
        }
      ),
      /***/
      "7418": (
        /***/
        function(module2, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        }
      ),
      /***/
      "746f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var path = __webpack_require__("428f");
          var has = __webpack_require__("5135");
          var wrappedWellKnownSymbolModule = __webpack_require__("e538");
          var defineProperty = __webpack_require__("9bf2").f;
          module2.exports = function(NAME) {
            var Symbol2 = path.Symbol || (path.Symbol = {});
            if (!has(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME)
            });
          };
        }
      ),
      /***/
      "7839": (
        /***/
        function(module2, exports2) {
          module2.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        }
      ),
      /***/
      "7915": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = Pbf;
          var ieee754 = __webpack_require__("9152");
          function Pbf(buf) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
            this.pos = 0;
            this.type = 0;
            this.length = this.buf.length;
          }
          Pbf.Varint = 0;
          Pbf.Fixed64 = 1;
          Pbf.Bytes = 2;
          Pbf.Fixed32 = 5;
          var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
          var TEXT_DECODER_MIN_LENGTH = 12;
          var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
          Pbf.prototype = {
            destroy: function() {
              this.buf = null;
            },
            // === READING =================================================================
            readFields: function(readField, result, end) {
              end = end || this.length;
              while (this.pos < end) {
                var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
                this.type = val & 7;
                readField(tag, result, this);
                if (this.pos === startPos) this.skip(val);
              }
              return result;
            },
            readMessage: function(readField, result) {
              return this.readFields(readField, result, this.readVarint() + this.pos);
            },
            readFixed32: function() {
              var val = readUInt32(this.buf, this.pos);
              this.pos += 4;
              return val;
            },
            readSFixed32: function() {
              var val = readInt32(this.buf, this.pos);
              this.pos += 4;
              return val;
            },
            // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
            readFixed64: function() {
              var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
              this.pos += 8;
              return val;
            },
            readSFixed64: function() {
              var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
              this.pos += 8;
              return val;
            },
            readFloat: function() {
              var val = ieee754.read(this.buf, this.pos, true, 23, 4);
              this.pos += 4;
              return val;
            },
            readDouble: function() {
              var val = ieee754.read(this.buf, this.pos, true, 52, 8);
              this.pos += 8;
              return val;
            },
            readVarint: function(isSigned) {
              var buf = this.buf, val, b;
              b = buf[this.pos++];
              val = b & 127;
              if (b < 128) return val;
              b = buf[this.pos++];
              val |= (b & 127) << 7;
              if (b < 128) return val;
              b = buf[this.pos++];
              val |= (b & 127) << 14;
              if (b < 128) return val;
              b = buf[this.pos++];
              val |= (b & 127) << 21;
              if (b < 128) return val;
              b = buf[this.pos];
              val |= (b & 15) << 28;
              return readVarintRemainder(val, isSigned, this);
            },
            readVarint64: function() {
              return this.readVarint(true);
            },
            readSVarint: function() {
              var num = this.readVarint();
              return num % 2 === 1 ? (num + 1) / -2 : num / 2;
            },
            readBoolean: function() {
              return Boolean(this.readVarint());
            },
            readString: function() {
              var end = this.readVarint() + this.pos;
              var pos = this.pos;
              this.pos = end;
              if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
                return readUtf8TextDecoder(this.buf, pos, end);
              }
              return readUtf8(this.buf, pos, end);
            },
            readBytes: function() {
              var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
              this.pos = end;
              return buffer;
            },
            // verbose for performance reasons; doesn't affect gzipped size
            readPackedVarint: function(arr, isSigned) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readVarint(isSigned));
              return arr;
            },
            readPackedSVarint: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readSVarint());
              return arr;
            },
            readPackedBoolean: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readBoolean());
              return arr;
            },
            readPackedFloat: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readFloat());
              return arr;
            },
            readPackedDouble: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readDouble());
              return arr;
            },
            readPackedFixed32: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readFixed32());
              return arr;
            },
            readPackedSFixed32: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readSFixed32());
              return arr;
            },
            readPackedFixed64: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readFixed64());
              return arr;
            },
            readPackedSFixed64: function(arr) {
              if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
              var end = readPackedEnd(this);
              arr = arr || [];
              while (this.pos < end) arr.push(this.readSFixed64());
              return arr;
            },
            skip: function(val) {
              var type = val & 7;
              if (type === Pbf.Varint) while (this.buf[this.pos++] > 127) {
              }
              else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
              else if (type === Pbf.Fixed32) this.pos += 4;
              else if (type === Pbf.Fixed64) this.pos += 8;
              else throw new Error("Unimplemented type: " + type);
            },
            // === WRITING =================================================================
            writeTag: function(tag, type) {
              this.writeVarint(tag << 3 | type);
            },
            realloc: function(min) {
              var length = this.length || 16;
              while (length < this.pos + min) length *= 2;
              if (length !== this.length) {
                var buf = new Uint8Array(length);
                buf.set(this.buf);
                this.buf = buf;
                this.length = length;
              }
            },
            finish: function() {
              this.length = this.pos;
              this.pos = 0;
              return this.buf.subarray(0, this.length);
            },
            writeFixed32: function(val) {
              this.realloc(4);
              writeInt32(this.buf, val, this.pos);
              this.pos += 4;
            },
            writeSFixed32: function(val) {
              this.realloc(4);
              writeInt32(this.buf, val, this.pos);
              this.pos += 4;
            },
            writeFixed64: function(val) {
              this.realloc(8);
              writeInt32(this.buf, val & -1, this.pos);
              writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
              this.pos += 8;
            },
            writeSFixed64: function(val) {
              this.realloc(8);
              writeInt32(this.buf, val & -1, this.pos);
              writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
              this.pos += 8;
            },
            writeVarint: function(val) {
              val = +val || 0;
              if (val > 268435455 || val < 0) {
                writeBigVarint(val, this);
                return;
              }
              this.realloc(4);
              this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
              if (val <= 127) return;
              this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
              if (val <= 127) return;
              this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
              if (val <= 127) return;
              this.buf[this.pos++] = val >>> 7 & 127;
            },
            writeSVarint: function(val) {
              this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
            },
            writeBoolean: function(val) {
              this.writeVarint(Boolean(val));
            },
            writeString: function(str) {
              str = String(str);
              this.realloc(str.length * 4);
              this.pos++;
              var startPos = this.pos;
              this.pos = writeUtf8(this.buf, str, this.pos);
              var len = this.pos - startPos;
              if (len >= 128) makeRoomForExtraLength(startPos, len, this);
              this.pos = startPos - 1;
              this.writeVarint(len);
              this.pos += len;
            },
            writeFloat: function(val) {
              this.realloc(4);
              ieee754.write(this.buf, val, this.pos, true, 23, 4);
              this.pos += 4;
            },
            writeDouble: function(val) {
              this.realloc(8);
              ieee754.write(this.buf, val, this.pos, true, 52, 8);
              this.pos += 8;
            },
            writeBytes: function(buffer) {
              var len = buffer.length;
              this.writeVarint(len);
              this.realloc(len);
              for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
            },
            writeRawMessage: function(fn, obj) {
              this.pos++;
              var startPos = this.pos;
              fn(obj, this);
              var len = this.pos - startPos;
              if (len >= 128) makeRoomForExtraLength(startPos, len, this);
              this.pos = startPos - 1;
              this.writeVarint(len);
              this.pos += len;
            },
            writeMessage: function(tag, fn, obj) {
              this.writeTag(tag, Pbf.Bytes);
              this.writeRawMessage(fn, obj);
            },
            writePackedVarint: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
            },
            writePackedSVarint: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
            },
            writePackedBoolean: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
            },
            writePackedFloat: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
            },
            writePackedDouble: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
            },
            writePackedFixed32: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
            },
            writePackedSFixed32: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
            },
            writePackedFixed64: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
            },
            writePackedSFixed64: function(tag, arr) {
              if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
            },
            writeBytesField: function(tag, buffer) {
              this.writeTag(tag, Pbf.Bytes);
              this.writeBytes(buffer);
            },
            writeFixed32Field: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed32);
              this.writeFixed32(val);
            },
            writeSFixed32Field: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed32);
              this.writeSFixed32(val);
            },
            writeFixed64Field: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed64);
              this.writeFixed64(val);
            },
            writeSFixed64Field: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed64);
              this.writeSFixed64(val);
            },
            writeVarintField: function(tag, val) {
              this.writeTag(tag, Pbf.Varint);
              this.writeVarint(val);
            },
            writeSVarintField: function(tag, val) {
              this.writeTag(tag, Pbf.Varint);
              this.writeSVarint(val);
            },
            writeStringField: function(tag, str) {
              this.writeTag(tag, Pbf.Bytes);
              this.writeString(str);
            },
            writeFloatField: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed32);
              this.writeFloat(val);
            },
            writeDoubleField: function(tag, val) {
              this.writeTag(tag, Pbf.Fixed64);
              this.writeDouble(val);
            },
            writeBooleanField: function(tag, val) {
              this.writeVarintField(tag, Boolean(val));
            }
          };
          function readVarintRemainder(l, s, p) {
            var buf = p.buf, h, b;
            b = buf[p.pos++];
            h = (b & 112) >> 4;
            if (b < 128) return toNum(l, h, s);
            b = buf[p.pos++];
            h |= (b & 127) << 3;
            if (b < 128) return toNum(l, h, s);
            b = buf[p.pos++];
            h |= (b & 127) << 10;
            if (b < 128) return toNum(l, h, s);
            b = buf[p.pos++];
            h |= (b & 127) << 17;
            if (b < 128) return toNum(l, h, s);
            b = buf[p.pos++];
            h |= (b & 127) << 24;
            if (b < 128) return toNum(l, h, s);
            b = buf[p.pos++];
            h |= (b & 1) << 31;
            if (b < 128) return toNum(l, h, s);
            throw new Error("Expected varint not more than 10 bytes");
          }
          function readPackedEnd(pbf) {
            return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
          }
          function toNum(low, high, isSigned) {
            if (isSigned) {
              return high * 4294967296 + (low >>> 0);
            }
            return (high >>> 0) * 4294967296 + (low >>> 0);
          }
          function writeBigVarint(val, pbf) {
            var low, high;
            if (val >= 0) {
              low = val % 4294967296 | 0;
              high = val / 4294967296 | 0;
            } else {
              low = ~(-val % 4294967296);
              high = ~(-val / 4294967296);
              if (low ^ 4294967295) {
                low = low + 1 | 0;
              } else {
                low = 0;
                high = high + 1 | 0;
              }
            }
            if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
              throw new Error("Given varint doesn't fit into 10 bytes");
            }
            pbf.realloc(10);
            writeBigVarintLow(low, high, pbf);
            writeBigVarintHigh(high, pbf);
          }
          function writeBigVarintLow(low, high, pbf) {
            pbf.buf[pbf.pos++] = low & 127 | 128;
            low >>>= 7;
            pbf.buf[pbf.pos++] = low & 127 | 128;
            low >>>= 7;
            pbf.buf[pbf.pos++] = low & 127 | 128;
            low >>>= 7;
            pbf.buf[pbf.pos++] = low & 127 | 128;
            low >>>= 7;
            pbf.buf[pbf.pos] = low & 127;
          }
          function writeBigVarintHigh(high, pbf) {
            var lsb = (high & 7) << 4;
            pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
            if (!high) return;
            pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
            if (!high) return;
            pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
            if (!high) return;
            pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
            if (!high) return;
            pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
            if (!high) return;
            pbf.buf[pbf.pos++] = high & 127;
          }
          function makeRoomForExtraLength(startPos, len, pbf) {
            var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
            pbf.realloc(extraLen);
            for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
          }
          function writePackedVarint(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);
          }
          function writePackedSVarint(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);
          }
          function writePackedFloat(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);
          }
          function writePackedDouble(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);
          }
          function writePackedBoolean(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);
          }
          function writePackedFixed32(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);
          }
          function writePackedSFixed32(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);
          }
          function writePackedFixed64(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);
          }
          function writePackedSFixed64(arr, pbf) {
            for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);
          }
          function readUInt32(buf, pos) {
            return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
          }
          function writeInt32(buf, val, pos) {
            buf[pos] = val;
            buf[pos + 1] = val >>> 8;
            buf[pos + 2] = val >>> 16;
            buf[pos + 3] = val >>> 24;
          }
          function readInt32(buf, pos) {
            return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
          }
          function readUtf8(buf, pos, end) {
            var str = "";
            var i = pos;
            while (i < end) {
              var b0 = buf[i];
              var c = null;
              var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
              if (i + bytesPerSequence > end) break;
              var b1, b2, b3;
              if (bytesPerSequence === 1) {
                if (b0 < 128) {
                  c = b0;
                }
              } else if (bytesPerSequence === 2) {
                b1 = buf[i + 1];
                if ((b1 & 192) === 128) {
                  c = (b0 & 31) << 6 | b1 & 63;
                  if (c <= 127) {
                    c = null;
                  }
                }
              } else if (bytesPerSequence === 3) {
                b1 = buf[i + 1];
                b2 = buf[i + 2];
                if ((b1 & 192) === 128 && (b2 & 192) === 128) {
                  c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
                  if (c <= 2047 || c >= 55296 && c <= 57343) {
                    c = null;
                  }
                }
              } else if (bytesPerSequence === 4) {
                b1 = buf[i + 1];
                b2 = buf[i + 2];
                b3 = buf[i + 3];
                if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
                  c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
                  if (c <= 65535 || c >= 1114112) {
                    c = null;
                  }
                }
              }
              if (c === null) {
                c = 65533;
                bytesPerSequence = 1;
              } else if (c > 65535) {
                c -= 65536;
                str += String.fromCharCode(c >>> 10 & 1023 | 55296);
                c = 56320 | c & 1023;
              }
              str += String.fromCharCode(c);
              i += bytesPerSequence;
            }
            return str;
          }
          function readUtf8TextDecoder(buf, pos, end) {
            return utf8TextDecoder.decode(buf.subarray(pos, end));
          }
          function writeUtf8(buf, str, pos) {
            for (var i = 0, c, lead; i < str.length; i++) {
              c = str.charCodeAt(i);
              if (c > 55295 && c < 57344) {
                if (lead) {
                  if (c < 56320) {
                    buf[pos++] = 239;
                    buf[pos++] = 191;
                    buf[pos++] = 189;
                    lead = c;
                    continue;
                  } else {
                    c = lead - 55296 << 10 | c - 56320 | 65536;
                    lead = null;
                  }
                } else {
                  if (c > 56319 || i + 1 === str.length) {
                    buf[pos++] = 239;
                    buf[pos++] = 191;
                    buf[pos++] = 189;
                  } else {
                    lead = c;
                  }
                  continue;
                }
              } else if (lead) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = null;
              }
              if (c < 128) {
                buf[pos++] = c;
              } else {
                if (c < 2048) {
                  buf[pos++] = c >> 6 | 192;
                } else {
                  if (c < 65536) {
                    buf[pos++] = c >> 12 | 224;
                  } else {
                    buf[pos++] = c >> 18 | 240;
                    buf[pos++] = c >> 12 & 63 | 128;
                  }
                  buf[pos++] = c >> 6 & 63 | 128;
                }
                buf[pos++] = c & 63 | 128;
              }
            }
            return pos;
          }
        }
      ),
      /***/
      "7b0b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("1d80");
          module2.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        }
      ),
      /***/
      "7b4f": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_exports__["a"] = {
            /**
             * Triggered when a property is changed.
             * @event module:ol/Object.ObjectEvent#propertychange
             * @api
             */
            PROPERTYCHANGE: "propertychange"
          };
        }
      ),
      /***/
      "7c73": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          var defineProperties = __webpack_require__("37e8");
          var enumBugKeys = __webpack_require__("7839");
          var hiddenKeys = __webpack_require__("d012");
          var html = __webpack_require__("1be4");
          var documentCreateElement = __webpack_require__("cc12");
          var sharedKey = __webpack_require__("f772");
          var GT = ">";
          var LT = "<";
          var PROTOTYPE = "prototype";
          var SCRIPT = "script";
          var IE_PROTO = sharedKey("IE_PROTO");
          var EmptyConstructor = function() {
          };
          var scriptTag = function(content) {
            return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
          };
          var NullProtoObjectViaActiveX = function(activeXDocument2) {
            activeXDocument2.write(scriptTag(""));
            activeXDocument2.close();
            var temp = activeXDocument2.parentWindow.Object;
            activeXDocument2 = null;
            return temp;
          };
          var NullProtoObjectViaIFrame = function() {
            var iframe = documentCreateElement("iframe");
            var JS = "java" + SCRIPT + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(JS);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(scriptTag("document.F=Object"));
            iframeDocument.close();
            return iframeDocument.F;
          };
          var activeXDocument;
          var NullProtoObject = function() {
            try {
              activeXDocument = document.domain && new ActiveXObject("htmlfile");
            } catch (error) {
            }
            NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
            var length = enumBugKeys.length;
            while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
            return NullProtoObject();
          };
          hiddenKeys[IE_PROTO] = true;
          module2.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              EmptyConstructor[PROTOTYPE] = anObject(O);
              result = new EmptyConstructor();
              EmptyConstructor[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else result = NullProtoObject();
            return Properties === void 0 ? result : defineProperties(result, Properties);
          };
        }
      ),
      /***/
      "7d05": (
        /***/
        function(module2, exports2, __webpack_require__) {
        }
      ),
      /***/
      "7dd0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var createIteratorConstructor = __webpack_require__("9ed3");
          var getPrototypeOf = __webpack_require__("e163");
          var setPrototypeOf = __webpack_require__("d2bb");
          var setToStringTag = __webpack_require__("d44e");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var redefine = __webpack_require__("6eeb");
          var wellKnownSymbol = __webpack_require__("b622");
          var IS_PURE = __webpack_require__("c430");
          var Iterators = __webpack_require__("3f8c");
          var IteratorsCore = __webpack_require__("ae93");
          var IteratorPrototype = IteratorsCore.IteratorPrototype;
          var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
          var ITERATOR = wellKnownSymbol("iterator");
          var KEYS = "keys";
          var VALUES = "values";
          var ENTRIES = "entries";
          var returnThis = function() {
            return this;
          };
          module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
            createIteratorConstructor(IteratorConstructor, NAME, next);
            var getIterationMethod = function(KIND) {
              if (KIND === DEFAULT && defaultIterator) return defaultIterator;
              if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
              switch (KIND) {
                case KEYS:
                  return function keys() {
                    return new IteratorConstructor(this, KIND);
                  };
                case VALUES:
                  return function values() {
                    return new IteratorConstructor(this, KIND);
                  };
                case ENTRIES:
                  return function entries() {
                    return new IteratorConstructor(this, KIND);
                  };
              }
              return function() {
                return new IteratorConstructor(this);
              };
            };
            var TO_STRING_TAG = NAME + " Iterator";
            var INCORRECT_VALUES_NAME = false;
            var IterablePrototype = Iterable.prototype;
            var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
            var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
            var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
            var CurrentIteratorPrototype, methods, KEY;
            if (anyNativeIterator) {
              CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
              if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                  if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                  } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                    createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                  }
                }
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
              }
            }
            if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return nativeIterator.call(this);
              };
            }
            if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
              createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
            }
            Iterators[NAME] = defaultIterator;
            if (DEFAULT) {
              methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
              };
              if (FORCED) for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  redefine(IterablePrototype, KEY, methods[KEY]);
                }
              }
              else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
            }
            return methods;
          };
        }
      ),
      /***/
      "7f9a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var inspectSource = __webpack_require__("8925");
          var WeakMap2 = global.WeakMap;
          module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
        }
      ),
      /***/
      "825a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(it) {
            if (!isObject2(it)) {
              throw TypeError(String(it) + " is not an object");
            }
            return it;
          };
        }
      ),
      /***/
      "83ab": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          module2.exports = !fails(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        }
      ),
      /***/
      "8418": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var toPrimitive = __webpack_require__("c04e");
          var definePropertyModule = __webpack_require__("9bf2");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          module2.exports = function(object, key, value) {
            var propertyKey = toPrimitive(key);
            if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else object[propertyKey] = value;
          };
        }
      ),
      /***/
      "861d": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        }
      ),
      /***/
      "872d": (
        /***/
        function(module2, exports2, __webpack_require__) {
        }
      ),
      /***/
      "8875": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(root, factory) {
            if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })(typeof self !== "undefined" ? self : this, function() {
            function getCurrentScript() {
              var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
              if (!descriptor && "currentScript" in document && document.currentScript) {
                return document.currentScript;
              }
              if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                return document.currentScript;
              }
              try {
                throw new Error();
              } catch (err) {
                var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                if (scriptLocation === currentLocation) {
                  pageSource = document.documentElement.outerHTML;
                  inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                  inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                }
                for (var i = 0; i < scripts.length; i++) {
                  if (scripts[i].readyState === "interactive") {
                    return scripts[i];
                  }
                  if (scripts[i].src === scriptLocation) {
                    return scripts[i];
                  }
                  if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                    return scripts[i];
                  }
                }
                return null;
              }
            }
            ;
            return getCurrentScript;
          });
        }
      ),
      /***/
      "8925": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var store = __webpack_require__("c6cd");
          var functionToString = Function.toString;
          if (typeof store.inspectSource != "function") {
            store.inspectSource = function(it) {
              return functionToString.call(it);
            };
          }
          module2.exports = store.inspectSource;
        }
      ),
      /***/
      "8bbf": (
        /***/
        function(module2, exports2) {
          module2.exports = require_vue();
        }
      ),
      /***/
      "90e3": (
        /***/
        function(module2, exports2) {
          var id = 0;
          var postfix = Math.random();
          module2.exports = function(key) {
            return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
          };
        }
      ),
      /***/
      "9112": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var definePropertyModule = __webpack_require__("9bf2");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          module2.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        }
      ),
      /***/
      "9152": (
        /***/
        function(module2, exports2) {
          exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
          exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
            }
            e = e << mLen | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
            }
            buffer[offset + i - d] |= s * 128;
          };
        }
      ),
      /***/
      "94ca": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
          };
          var normalize = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module2.exports = isForced;
        }
      ),
      /***/
      "9bdd": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          var iteratorClose = __webpack_require__("2a62");
          module2.exports = function(iterator, fn, value, ENTRIES) {
            try {
              return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (error) {
              iteratorClose(iterator);
              throw error;
            }
          };
        }
      ),
      /***/
      "9bf2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var IE8_DOM_DEFINE = __webpack_require__("0cfb");
          var anObject = __webpack_require__("825a");
          var toPrimitive = __webpack_require__("c04e");
          var $defineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
              return $defineProperty(O, P, Attributes);
            } catch (error) {
            }
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          };
        }
      ),
      /***/
      "9ed3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
          var create = __webpack_require__("7c73");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          var setToStringTag = __webpack_require__("d44e");
          var Iterators = __webpack_require__("3f8c");
          var returnThis = function() {
            return this;
          };
          module2.exports = function(IteratorConstructor, NAME, next) {
            var TO_STRING_TAG = NAME + " Iterator";
            IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
            setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
            Iterators[TO_STRING_TAG] = returnThis;
            return IteratorConstructor;
          };
        }
      ),
      /***/
      "9f5e": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return binarySearch;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return numberSafeCompareFunction;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return includes;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return linearFindNearest;
          });
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return reverseSubArray;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return extend2;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return find;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return equals;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return findIndex;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return isSorted;
          });
          function binarySearch(haystack, needle, opt_comparator) {
            var mid, cmp;
            var comparator = opt_comparator || numberSafeCompareFunction;
            var low = 0;
            var high = haystack.length;
            var found = false;
            while (low < high) {
              mid = low + (high - low >> 1);
              cmp = +comparator(haystack[mid], needle);
              if (cmp < 0) {
                low = mid + 1;
              } else {
                high = mid;
                found = !cmp;
              }
            }
            return found ? low : ~low;
          }
          function numberSafeCompareFunction(a, b) {
            return a > b ? 1 : a < b ? -1 : 0;
          }
          function includes(arr, obj) {
            return arr.indexOf(obj) >= 0;
          }
          function linearFindNearest(arr, target, direction) {
            var n = arr.length;
            if (arr[0] <= target) {
              return 0;
            } else if (target <= arr[n - 1]) {
              return n - 1;
            } else {
              var i = void 0;
              if (direction > 0) {
                for (i = 1; i < n; ++i) {
                  if (arr[i] < target) {
                    return i - 1;
                  }
                }
              } else if (direction < 0) {
                for (i = 1; i < n; ++i) {
                  if (arr[i] <= target) {
                    return i;
                  }
                }
              } else {
                for (i = 1; i < n; ++i) {
                  if (arr[i] == target) {
                    return i;
                  } else if (arr[i] < target) {
                    if (typeof direction === "function") {
                      if (direction(target, arr[i - 1], arr[i]) > 0) {
                        return i - 1;
                      } else {
                        return i;
                      }
                    } else if (arr[i - 1] - target < target - arr[i]) {
                      return i - 1;
                    } else {
                      return i;
                    }
                  }
                }
              }
              return n - 1;
            }
          }
          function reverseSubArray(arr, begin, end) {
            while (begin < end) {
              var tmp = arr[begin];
              arr[begin] = arr[end];
              arr[end] = tmp;
              ++begin;
              --end;
            }
          }
          function extend2(arr, data) {
            var extension = Array.isArray(data) ? data : [data];
            var length = extension.length;
            for (var i = 0; i < length; i++) {
              arr[arr.length] = extension[i];
            }
          }
          function remove(arr, obj) {
            var i = arr.indexOf(obj);
            var found = i > -1;
            if (found) {
              arr.splice(i, 1);
            }
            return found;
          }
          function find(arr, func) {
            var length = arr.length >>> 0;
            var value;
            for (var i = 0; i < length; i++) {
              value = arr[i];
              if (func(value, i, arr)) {
                return value;
              }
            }
            return null;
          }
          function equals(arr1, arr2) {
            var len1 = arr1.length;
            if (len1 !== arr2.length) {
              return false;
            }
            for (var i = 0; i < len1; i++) {
              if (arr1[i] !== arr2[i]) {
                return false;
              }
            }
            return true;
          }
          function stableSort(arr, compareFnc) {
            var length = arr.length;
            var tmp = Array(arr.length);
            var i;
            for (i = 0; i < length; i++) {
              tmp[i] = { index: i, value: arr[i] };
            }
            tmp.sort(function(a, b) {
              return compareFnc(a.value, b.value) || a.index - b.index;
            });
            for (i = 0; i < arr.length; i++) {
              arr[i] = tmp[i].value;
            }
          }
          function findIndex(arr, func) {
            var index;
            var found = !arr.every(function(el, idx) {
              index = idx;
              return !func(el, idx, arr);
            });
            return found ? index : -1;
          }
          function isSorted(arr, opt_func, opt_strict) {
            var compare = opt_func || numberSafeCompareFunction;
            return arr.every(function(currentVal, index) {
              if (index === 0) {
                return true;
              }
              var res = compare(arr[index - 1], currentVal);
              return !(res > 0 || opt_strict && res === 0);
            });
          }
        }
      ),
      /***/
      "a4d3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var global = __webpack_require__("da84");
          var getBuiltIn = __webpack_require__("d066");
          var IS_PURE = __webpack_require__("c430");
          var DESCRIPTORS = __webpack_require__("83ab");
          var NATIVE_SYMBOL = __webpack_require__("4930");
          var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
          var fails = __webpack_require__("d039");
          var has = __webpack_require__("5135");
          var isArray2 = __webpack_require__("e8b5");
          var isObject2 = __webpack_require__("861d");
          var anObject = __webpack_require__("825a");
          var toObject = __webpack_require__("7b0b");
          var toIndexedObject = __webpack_require__("fc6a");
          var toPrimitive = __webpack_require__("c04e");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          var nativeObjectCreate = __webpack_require__("7c73");
          var objectKeys = __webpack_require__("df75");
          var getOwnPropertyNamesModule = __webpack_require__("241c");
          var getOwnPropertyNamesExternal = __webpack_require__("057f");
          var getOwnPropertySymbolsModule = __webpack_require__("7418");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var definePropertyModule = __webpack_require__("9bf2");
          var propertyIsEnumerableModule = __webpack_require__("d1e7");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var redefine = __webpack_require__("6eeb");
          var shared = __webpack_require__("5692");
          var sharedKey = __webpack_require__("f772");
          var hiddenKeys = __webpack_require__("d012");
          var uid = __webpack_require__("90e3");
          var wellKnownSymbol = __webpack_require__("b622");
          var wrappedWellKnownSymbolModule = __webpack_require__("e538");
          var defineWellKnownSymbol = __webpack_require__("746f");
          var setToStringTag = __webpack_require__("d44e");
          var InternalStateModule = __webpack_require__("69f3");
          var $forEach = __webpack_require__("b727").forEach;
          var HIDDEN = sharedKey("hidden");
          var SYMBOL = "Symbol";
          var PROTOTYPE = "prototype";
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(SYMBOL);
          var ObjectPrototype = Object[PROTOTYPE];
          var $Symbol = global.Symbol;
          var $stringify = getBuiltIn("JSON", "stringify");
          var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var nativeDefineProperty = definePropertyModule.f;
          var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
          var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
          var AllSymbols = shared("symbols");
          var ObjectPrototypeSymbols = shared("op-symbols");
          var StringToSymbolRegistry = shared("string-to-symbol-registry");
          var SymbolToStringRegistry = shared("symbol-to-string-registry");
          var WellKnownSymbolsStore = shared("wks");
          var QObject = global.QObject;
          var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
          var setSymbolDescriptor = DESCRIPTORS && fails(function() {
            return nativeObjectCreate(nativeDefineProperty({}, "a", {
              get: function() {
                return nativeDefineProperty(this, "a", { value: 7 }).a;
              }
            })).a != 7;
          }) ? function(O, P, Attributes) {
            var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
            if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
            nativeDefineProperty(O, P, Attributes);
            if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
              nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
            }
          } : nativeDefineProperty;
          var wrap = function(tag, description) {
            var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
            setInternalState(symbol, {
              type: SYMBOL,
              tag,
              description
            });
            if (!DESCRIPTORS) symbol.description = description;
            return symbol;
          };
          var isSymbol2 = USE_SYMBOL_AS_UID ? function(it) {
            return typeof it == "symbol";
          } : function(it) {
            return Object(it) instanceof $Symbol;
          };
          var $defineProperty = function defineProperty(O, P, Attributes) {
            if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
            anObject(O);
            var key = toPrimitive(P, true);
            anObject(Attributes);
            if (has(AllSymbols, key)) {
              if (!Attributes.enumerable) {
                if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                O[HIDDEN][key] = true;
              } else {
                if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
                Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
              }
              return setSymbolDescriptor(O, key, Attributes);
            }
            return nativeDefineProperty(O, key, Attributes);
          };
          var $defineProperties = function defineProperties(O, Properties) {
            anObject(O);
            var properties = toIndexedObject(Properties);
            var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
            $forEach(keys, function(key) {
              if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
            });
            return O;
          };
          var $create = function create(O, Properties) {
            return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
          };
          var $propertyIsEnumerable = function propertyIsEnumerable(V) {
            var P = toPrimitive(V, true);
            var enumerable = nativePropertyIsEnumerable.call(this, P);
            if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
            return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
          };
          var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
            var it = toIndexedObject(O);
            var key = toPrimitive(P, true);
            if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
            var descriptor = nativeGetOwnPropertyDescriptor(it, key);
            if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
              descriptor.enumerable = true;
            }
            return descriptor;
          };
          var $getOwnPropertyNames = function getOwnPropertyNames(O) {
            var names = nativeGetOwnPropertyNames(toIndexedObject(O));
            var result = [];
            $forEach(names, function(key) {
              if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
            });
            return result;
          };
          var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
            var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
            var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
            var result = [];
            $forEach(names, function(key) {
              if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
                result.push(AllSymbols[key]);
              }
            });
            return result;
          };
          if (!NATIVE_SYMBOL) {
            $Symbol = function Symbol2() {
              if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor");
              var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
              var tag = uid(description);
              var setter = function(value) {
                if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
                if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
              };
              if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
              return wrap(tag, description);
            };
            redefine($Symbol[PROTOTYPE], "toString", function toString() {
              return getInternalState(this).tag;
            });
            redefine($Symbol, "withoutSetter", function(description) {
              return wrap(uid(description), description);
            });
            propertyIsEnumerableModule.f = $propertyIsEnumerable;
            definePropertyModule.f = $defineProperty;
            getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
            getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
            getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
            wrappedWellKnownSymbolModule.f = function(name) {
              return wrap(wellKnownSymbol(name), name);
            };
            if (DESCRIPTORS) {
              nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                configurable: true,
                get: function description() {
                  return getInternalState(this).description;
                }
              });
              if (!IS_PURE) {
                redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
              }
            }
          }
          $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
            Symbol: $Symbol
          });
          $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
            defineWellKnownSymbol(name);
          });
          $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
            // `Symbol.for` method
            // https://tc39.es/ecma262/#sec-symbol.for
            "for": function(key) {
              var string = String(key);
              if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
              var symbol = $Symbol(string);
              StringToSymbolRegistry[string] = symbol;
              SymbolToStringRegistry[symbol] = string;
              return symbol;
            },
            // `Symbol.keyFor` method
            // https://tc39.es/ecma262/#sec-symbol.keyfor
            keyFor: function keyFor(sym) {
              if (!isSymbol2(sym)) throw TypeError(sym + " is not a symbol");
              if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
            },
            useSetter: function() {
              USE_SETTER = true;
            },
            useSimple: function() {
              USE_SETTER = false;
            }
          });
          $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
            // `Object.create` method
            // https://tc39.es/ecma262/#sec-object.create
            create: $create,
            // `Object.defineProperty` method
            // https://tc39.es/ecma262/#sec-object.defineproperty
            defineProperty: $defineProperty,
            // `Object.defineProperties` method
            // https://tc39.es/ecma262/#sec-object.defineproperties
            defineProperties: $defineProperties,
            // `Object.getOwnPropertyDescriptor` method
            // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor
          });
          $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
            // `Object.getOwnPropertyNames` method
            // https://tc39.es/ecma262/#sec-object.getownpropertynames
            getOwnPropertyNames: $getOwnPropertyNames,
            // `Object.getOwnPropertySymbols` method
            // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
            getOwnPropertySymbols: $getOwnPropertySymbols
          });
          $({ target: "Object", stat: true, forced: fails(function() {
            getOwnPropertySymbolsModule.f(1);
          }) }, {
            getOwnPropertySymbols: function getOwnPropertySymbols(it) {
              return getOwnPropertySymbolsModule.f(toObject(it));
            }
          });
          if ($stringify) {
            var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
              var symbol = $Symbol();
              return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
            });
            $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              stringify: function stringify(it, replacer, space) {
                var args = [it];
                var index = 1;
                var $replacer;
                while (arguments.length > index) args.push(arguments[index++]);
                $replacer = replacer;
                if (!isObject2(replacer) && it === void 0 || isSymbol2(it)) return;
                if (!isArray2(replacer)) replacer = function(key, value) {
                  if (typeof $replacer == "function") value = $replacer.call(this, key, value);
                  if (!isSymbol2(value)) return value;
                };
                args[1] = replacer;
                return $stringify.apply(null, args);
              }
            });
          }
          if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
            createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
          }
          setToStringTag($Symbol, SYMBOL);
          hiddenKeys[HIDDEN] = true;
        }
      ),
      /***/
      "a630": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var from = __webpack_require__("4df4");
          var checkCorrectnessOfIteration = __webpack_require__("1c7e");
          var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
            Array.from(iterable);
          });
          $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
            from
          });
        }
      ),
      /***/
      "a640": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fails = __webpack_require__("d039");
          module2.exports = function(METHOD_NAME, argument) {
            var method = [][METHOD_NAME];
            return !!method && fails(function() {
              method.call(null, argument || function() {
                throw 1;
              }, 1);
            });
          };
        }
      ),
      /***/
      "a691": (
        /***/
        function(module2, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module2.exports = function(argument) {
            return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
          };
        }
      ),
      /***/
      "a9e3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var DESCRIPTORS = __webpack_require__("83ab");
          var global = __webpack_require__("da84");
          var isForced = __webpack_require__("94ca");
          var redefine = __webpack_require__("6eeb");
          var has = __webpack_require__("5135");
          var classof = __webpack_require__("c6b6");
          var inheritIfRequired = __webpack_require__("7156");
          var toPrimitive = __webpack_require__("c04e");
          var fails = __webpack_require__("d039");
          var create = __webpack_require__("7c73");
          var getOwnPropertyNames = __webpack_require__("241c").f;
          var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var defineProperty = __webpack_require__("9bf2").f;
          var trim = __webpack_require__("58a8").trim;
          var NUMBER = "Number";
          var NativeNumber = global[NUMBER];
          var NumberPrototype = NativeNumber.prototype;
          var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
          var toNumber = function(argument) {
            var it = toPrimitive(argument, false);
            var first, third, radix, maxCode, digits, length, index, code;
            if (typeof it == "string" && it.length > 2) {
              it = trim(it);
              first = it.charCodeAt(0);
              if (first === 43 || first === 45) {
                third = it.charCodeAt(2);
                if (third === 88 || third === 120) return NaN;
              } else if (first === 48) {
                switch (it.charCodeAt(1)) {
                  case 66:
                  case 98:
                    radix = 2;
                    maxCode = 49;
                    break;
                  // fast equal of /^0b[01]+$/i
                  case 79:
                  case 111:
                    radix = 8;
                    maxCode = 55;
                    break;
                  // fast equal of /^0o[0-7]+$/i
                  default:
                    return +it;
                }
                digits = it.slice(2);
                length = digits.length;
                for (index = 0; index < length; index++) {
                  code = digits.charCodeAt(index);
                  if (code < 48 || code > maxCode) return NaN;
                }
                return parseInt(digits, radix);
              }
            }
            return +it;
          };
          if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
            var NumberWrapper = function Number2(value) {
              var it = arguments.length < 1 ? 0 : value;
              var dummy = this;
              return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
                NumberPrototype.valueOf.call(dummy);
              }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
            };
            for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
              // ES3:
              "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(",")
            ), j = 0, key; keys.length > j; j++) {
              if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
                defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
              }
            }
            NumberWrapper.prototype = NumberPrototype;
            NumberPrototype.constructor = NumberWrapper;
            redefine(global, NUMBER, NumberWrapper);
          }
        }
      ),
      /***/
      "ab13": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          var MATCH = wellKnownSymbol("match");
          module2.exports = function(METHOD_NAME) {
            var regexp = /./;
            try {
              "/./"[METHOD_NAME](regexp);
            } catch (error1) {
              try {
                regexp[MATCH] = false;
                return "/./"[METHOD_NAME](regexp);
              } catch (error2) {
              }
            }
            return false;
          };
        }
      ),
      /***/
      "ae93": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fails = __webpack_require__("d039");
          var getPrototypeOf = __webpack_require__("e163");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var has = __webpack_require__("5135");
          var wellKnownSymbol = __webpack_require__("b622");
          var IS_PURE = __webpack_require__("c430");
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var returnThis = function() {
            return this;
          };
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
            var test = {};
            return IteratorPrototype[ITERATOR].call(test) !== test;
          });
          if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
          if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
            createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
          }
          module2.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        }
      ),
      /***/
      "b041": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
          var classof = __webpack_require__("f5df");
          module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
            return "[object " + classof(this) + "]";
          };
        }
      ),
      /***/
      "b0c0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var defineProperty = __webpack_require__("9bf2").f;
          var FunctionPrototype = Function.prototype;
          var FunctionPrototypeToString = FunctionPrototype.toString;
          var nameRE = /^\s*function ([^ (]*)/;
          var NAME = "name";
          if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
            defineProperty(FunctionPrototype, NAME, {
              configurable: true,
              get: function() {
                try {
                  return FunctionPrototypeToString.call(this).match(nameRE)[1];
                } catch (error) {
                  return "";
                }
              }
            });
          }
        }
      ),
      /***/
      "b622": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var shared = __webpack_require__("5692");
          var has = __webpack_require__("5135");
          var uid = __webpack_require__("90e3");
          var NATIVE_SYMBOL = __webpack_require__("4930");
          var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
          var WellKnownSymbolsStore = shared("wks");
          var Symbol2 = global.Symbol;
          var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
          module2.exports = function(name) {
            if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
              if (NATIVE_SYMBOL && has(Symbol2, name)) {
                WellKnownSymbolsStore[name] = Symbol2[name];
              } else {
                WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
              }
            }
            return WellKnownSymbolsStore[name];
          };
        }
      ),
      /***/
      "b64b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var toObject = __webpack_require__("7b0b");
          var nativeKeys = __webpack_require__("df75");
          var fails = __webpack_require__("d039");
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeKeys(1);
          });
          $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
            keys: function keys(it) {
              return nativeKeys(toObject(it));
            }
          });
        }
      ),
      /***/
      "b727": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var bind = __webpack_require__("0366");
          var IndexedObject = __webpack_require__("44ad");
          var toObject = __webpack_require__("7b0b");
          var toLength = __webpack_require__("50c4");
          var arraySpeciesCreate = __webpack_require__("65f0");
          var push = [].push;
          var createMethod = function(TYPE) {
            var IS_MAP = TYPE == 1;
            var IS_FILTER = TYPE == 2;
            var IS_SOME = TYPE == 3;
            var IS_EVERY = TYPE == 4;
            var IS_FIND_INDEX = TYPE == 6;
            var IS_FILTER_OUT = TYPE == 7;
            var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            return function($this, callbackfn, that, specificCreate) {
              var O = toObject($this);
              var self2 = IndexedObject(O);
              var boundFunction = bind(callbackfn, that, 3);
              var length = toLength(self2.length);
              var index = 0;
              var create = specificCreate || arraySpeciesCreate;
              var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0;
              var value, result;
              for (; length > index; index++) if (NO_HOLES || index in self2) {
                value = self2[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                  if (IS_MAP) target[index] = result;
                  else if (result) switch (TYPE) {
                    case 3:
                      return true;
                    // some
                    case 5:
                      return value;
                    // find
                    case 6:
                      return index;
                    // findIndex
                    case 2:
                      push.call(target, value);
                  }
                  else switch (TYPE) {
                    case 4:
                      return false;
                    // every
                    case 7:
                      push.call(target, value);
                  }
                }
              }
              return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
            };
          };
          module2.exports = {
            // `Array.prototype.forEach` method
            // https://tc39.es/ecma262/#sec-array.prototype.foreach
            forEach: createMethod(0),
            // `Array.prototype.map` method
            // https://tc39.es/ecma262/#sec-array.prototype.map
            map: createMethod(1),
            // `Array.prototype.filter` method
            // https://tc39.es/ecma262/#sec-array.prototype.filter
            filter: createMethod(2),
            // `Array.prototype.some` method
            // https://tc39.es/ecma262/#sec-array.prototype.some
            some: createMethod(3),
            // `Array.prototype.every` method
            // https://tc39.es/ecma262/#sec-array.prototype.every
            every: createMethod(4),
            // `Array.prototype.find` method
            // https://tc39.es/ecma262/#sec-array.prototype.find
            find: createMethod(5),
            // `Array.prototype.findIndex` method
            // https://tc39.es/ecma262/#sec-array.prototype.findIndex
            findIndex: createMethod(6),
            // `Array.prototype.filterOut` method
            // https://github.com/tc39/proposal-array-filtering
            filterOut: createMethod(7)
          };
        }
      ),
      /***/
      "c04e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(input, PREFERRED_STRING) {
            if (!isObject2(input)) return input;
            var fn, val;
            if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input))) return val;
            if (typeof (fn = input.valueOf) == "function" && !isObject2(val = fn.call(input))) return val;
            if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input))) return val;
            throw TypeError("Can't convert object to primitive value");
          };
        }
      ),
      /***/
      "c430": (
        /***/
        function(module2, exports2) {
          module2.exports = false;
        }
      ),
      /***/
      "c6b6": (
        /***/
        function(module2, exports2) {
          var toString = {}.toString;
          module2.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        }
      ),
      /***/
      "c6cd": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var setGlobal = __webpack_require__("ce4e");
          var SHARED = "__core-js_shared__";
          var store = global[SHARED] || setGlobal(SHARED, {});
          module2.exports = store;
        }
      ),
      /***/
      "c8ba": (
        /***/
        function(module2, exports2) {
          var g;
          g = /* @__PURE__ */ function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object") g = window;
          }
          module2.exports = g;
        }
      ),
      /***/
      "ca84": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var has = __webpack_require__("5135");
          var toIndexedObject = __webpack_require__("fc6a");
          var indexOf = __webpack_require__("4d64").indexOf;
          var hiddenKeys = __webpack_require__("d012");
          module2.exports = function(object, names) {
            var O = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
            while (names.length > i) if (has(O, key = names[i++])) {
              ~indexOf(result, key) || result.push(key);
            }
            return result;
          };
        }
      ),
      /***/
      "caad": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $includes = __webpack_require__("4d64").includes;
          var addToUnscopables = __webpack_require__("44d2");
          $({ target: "Array", proto: true }, {
            includes: function includes(el) {
              return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
          addToUnscopables("includes");
        }
      ),
      /***/
      "cc12": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var isObject2 = __webpack_require__("861d");
          var document2 = global.document;
          var EXISTS = isObject2(document2) && isObject2(document2.createElement);
          module2.exports = function(it) {
            return EXISTS ? document2.createElement(it) : {};
          };
        }
      ),
      /***/
      "ce4e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var createNonEnumerableProperty = __webpack_require__("9112");
          module2.exports = function(key, value) {
            try {
              createNonEnumerableProperty(global, key, value);
            } catch (error) {
              global[key] = value;
            }
            return value;
          };
        }
      ),
      /***/
      "cef7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return stopPropagation;
          });
          var BaseEvent = (
            /** @class */
            function() {
              function BaseEvent2(type) {
                this.propagationStopped;
                this.defaultPrevented;
                this.type = type;
                this.target = null;
              }
              BaseEvent2.prototype.preventDefault = function() {
                this.defaultPrevented = true;
              };
              BaseEvent2.prototype.stopPropagation = function() {
                this.propagationStopped = true;
              };
              return BaseEvent2;
            }()
          );
          function stopPropagation(evt) {
            evt.stopPropagation();
          }
          function preventDefault(evt) {
            evt.preventDefault();
          }
          __webpack_exports__["a"] = BaseEvent;
        }
      ),
      /***/
      "d012": (
        /***/
        function(module2, exports2) {
          module2.exports = {};
        }
      ),
      /***/
      "d039": (
        /***/
        function(module2, exports2) {
          module2.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        }
      ),
      /***/
      "d066": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var path = __webpack_require__("428f");
          var global = __webpack_require__("da84");
          var aFunction = function(variable) {
            return typeof variable == "function" ? variable : void 0;
          };
          module2.exports = function(namespace, method) {
            return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
          };
        }
      ),
      /***/
      "d1e7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $propertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : $propertyIsEnumerable;
        }
      ),
      /***/
      "d28b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var defineWellKnownSymbol = __webpack_require__("746f");
          defineWellKnownSymbol("iterator");
        }
      ),
      /***/
      "d2bb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          var aPossiblePrototype = __webpack_require__("3bbe");
          module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var CORRECT_SETTER = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              CORRECT_SETTER = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O, proto) {
              anObject(O);
              aPossiblePrototype(proto);
              if (CORRECT_SETTER) setter.call(O, proto);
              else O.__proto__ = proto;
              return O;
            };
          }() : void 0);
        }
      ),
      /***/
      "d3b7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
          var redefine = __webpack_require__("6eeb");
          var toString = __webpack_require__("b041");
          if (!TO_STRING_TAG_SUPPORT) {
            redefine(Object.prototype, "toString", toString, { unsafe: true });
          }
        }
      ),
      /***/
      "d44e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var defineProperty = __webpack_require__("9bf2").f;
          var has = __webpack_require__("5135");
          var wellKnownSymbol = __webpack_require__("b622");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module2.exports = function(it, TAG, STATIC) {
            if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
              defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
            }
          };
        }
      ),
      /***/
      "d81d": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $map = __webpack_require__("b727").map;
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            map: function map(callbackfn) {
              return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        }
      ),
      /***/
      "da5c": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var Disposable = (
            /** @class */
            function() {
              function Disposable2() {
                this.disposed = false;
              }
              Disposable2.prototype.dispose = function() {
                if (!this.disposed) {
                  this.disposed = true;
                  this.disposeInternal();
                }
              };
              Disposable2.prototype.disposeInternal = function() {
              };
              return Disposable2;
            }()
          );
          __webpack_exports__["a"] = Disposable;
        }
      ),
      /***/
      "da84": (
        /***/
        function(module2, exports2, __webpack_require__) {
          (function(global) {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = // eslint-disable-next-line es/no-global-this -- safe
            check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
            check(typeof self == "object" && self) || check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
            /* @__PURE__ */ function() {
              return this;
            }() || Function("return this")();
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "dbb4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var DESCRIPTORS = __webpack_require__("83ab");
          var ownKeys = __webpack_require__("56ef");
          var toIndexedObject = __webpack_require__("fc6a");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var createProperty = __webpack_require__("8418");
          $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
            getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
              var O = toIndexedObject(object);
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              var keys = ownKeys(O);
              var result = {};
              var index = 0;
              var key, descriptor;
              while (keys.length > index) {
                descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                if (descriptor !== void 0) createProperty(result, key, descriptor);
              }
              return result;
            }
          });
        }
      ),
      /***/
      "dbd0": (
        /***/
        function(module2, exports2, __webpack_require__) {
        }
      ),
      /***/
      "ddb0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var DOMIterables = __webpack_require__("fdbc");
          var ArrayIteratorMethods = __webpack_require__("e260");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var wellKnownSymbol = __webpack_require__("b622");
          var ITERATOR = wellKnownSymbol("iterator");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var ArrayValues = ArrayIteratorMethods.values;
          for (var COLLECTION_NAME in DOMIterables) {
            var Collection = global[COLLECTION_NAME];
            var CollectionPrototype = Collection && Collection.prototype;
            if (CollectionPrototype) {
              if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
              if (!CollectionPrototype[TO_STRING_TAG]) {
                createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
              }
              if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                  createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                } catch (error) {
                  CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                }
              }
            }
          }
        }
      ),
      /***/
      "df75": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("ca84");
          var enumBugKeys = __webpack_require__("7839");
          module2.exports = Object.keys || function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        }
      ),
      /***/
      "e01a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var DESCRIPTORS = __webpack_require__("83ab");
          var global = __webpack_require__("da84");
          var has = __webpack_require__("5135");
          var isObject2 = __webpack_require__("861d");
          var defineProperty = __webpack_require__("9bf2").f;
          var copyConstructorProperties = __webpack_require__("e893");
          var NativeSymbol = global.Symbol;
          if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
          NativeSymbol().description !== void 0)) {
            var EmptyStringDescriptionStore = {};
            var SymbolWrapper = function Symbol2() {
              var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
              var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
              if (description === "") EmptyStringDescriptionStore[result] = true;
              return result;
            };
            copyConstructorProperties(SymbolWrapper, NativeSymbol);
            var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
            symbolPrototype.constructor = SymbolWrapper;
            var symbolToString = symbolPrototype.toString;
            var native = String(NativeSymbol("test")) == "Symbol(test)";
            var regexp = /^Symbol\((.*)\)[^)]+$/;
            defineProperty(symbolPrototype, "description", {
              configurable: true,
              get: function description() {
                var symbol = isObject2(this) ? this.valueOf() : this;
                var string = symbolToString.call(symbol);
                if (has(EmptyStringDescriptionStore, symbol)) return "";
                var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                return desc === "" ? void 0 : desc;
              }
            });
            $({ global: true, forced: true }, {
              Symbol: SymbolWrapper
            });
          }
        }
      ),
      /***/
      "e163": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var has = __webpack_require__("5135");
          var toObject = __webpack_require__("7b0b");
          var sharedKey = __webpack_require__("f772");
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
          var IE_PROTO = sharedKey("IE_PROTO");
          var ObjectPrototype = Object.prototype;
          module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
            O = toObject(O);
            if (has(O, IE_PROTO)) return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectPrototype : null;
          };
        }
      ),
      /***/
      "e177": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          module2.exports = !fails(function() {
            function F() {
            }
            F.prototype.constructor = null;
            return Object.getPrototypeOf(new F()) !== F.prototype;
          });
        }
      ),
      /***/
      "e260": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var toIndexedObject = __webpack_require__("fc6a");
          var addToUnscopables = __webpack_require__("44d2");
          var Iterators = __webpack_require__("3f8c");
          var InternalStateModule = __webpack_require__("69f3");
          var defineIterator = __webpack_require__("7dd0");
          var ARRAY_ITERATOR = "Array Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
          module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
            setInternalState(this, {
              type: ARRAY_ITERATOR,
              target: toIndexedObject(iterated),
              // target
              index: 0,
              // next index
              kind
              // kind
            });
          }, function() {
            var state = getInternalState(this);
            var target = state.target;
            var kind = state.kind;
            var index = state.index++;
            if (!target || index >= target.length) {
              state.target = void 0;
              return { value: void 0, done: true };
            }
            if (kind == "keys") return { value: index, done: false };
            if (kind == "values") return { value: target[index], done: false };
            return { value: [index, target[index]], done: false };
          }, "values");
          Iterators.Arguments = Iterators.Array;
          addToUnscopables("keys");
          addToUnscopables("values");
          addToUnscopables("entries");
        }
      ),
      /***/
      "e269": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cef7");
          var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7b4f");
          var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("35a7");
          var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
          var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("1300");
          var __extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ObjectEvent = (
            /** @class */
            function(_super) {
              __extends(ObjectEvent2, _super);
              function ObjectEvent2(type, key, oldValue) {
                var _this = _super.call(this, type) || this;
                _this.key = key;
                _this.oldValue = oldValue;
                return _this;
              }
              return ObjectEvent2;
            }(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__[
              /* default */
              "a"
            ])
          );
          var BaseObject = (
            /** @class */
            function(_super) {
              __extends(BaseObject2, _super);
              function BaseObject2(opt_values) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                Object(_util_js__WEBPACK_IMPORTED_MODULE_4__[
                  /* getUid */
                  "c"
                ])(_this);
                _this.values_ = null;
                if (opt_values !== void 0) {
                  _this.setProperties(opt_values);
                }
                return _this;
              }
              BaseObject2.prototype.get = function(key) {
                var value;
                if (this.values_ && this.values_.hasOwnProperty(key)) {
                  value = this.values_[key];
                }
                return value;
              };
              BaseObject2.prototype.getKeys = function() {
                return this.values_ && Object.keys(this.values_) || [];
              };
              BaseObject2.prototype.getProperties = function() {
                return this.values_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[
                  /* assign */
                  "a"
                ])({}, this.values_) || {};
              };
              BaseObject2.prototype.hasProperties = function() {
                return !!this.values_;
              };
              BaseObject2.prototype.notify = function(key, oldValue) {
                var eventType;
                eventType = "change:" + key;
                this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
                eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__[
                  /* default */
                  "a"
                ].PROPERTYCHANGE;
                this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
              };
              BaseObject2.prototype.addChangeListener = function(key, listener) {
                this.addEventListener("change:" + key, listener);
              };
              BaseObject2.prototype.removeChangeListener = function(key, listener) {
                this.removeEventListener("change:" + key, listener);
              };
              BaseObject2.prototype.set = function(key, value, opt_silent) {
                var values = this.values_ || (this.values_ = {});
                if (opt_silent) {
                  values[key] = value;
                } else {
                  var oldValue = values[key];
                  values[key] = value;
                  if (oldValue !== value) {
                    this.notify(key, oldValue);
                  }
                }
              };
              BaseObject2.prototype.setProperties = function(values, opt_silent) {
                for (var key in values) {
                  this.set(key, values[key], opt_silent);
                }
              };
              BaseObject2.prototype.applyProperties = function(source) {
                if (!source.values_) {
                  return;
                }
                Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[
                  /* assign */
                  "a"
                ])(this.values_ || (this.values_ = {}), source.values_);
              };
              BaseObject2.prototype.unset = function(key, opt_silent) {
                if (this.values_ && key in this.values_) {
                  var oldValue = this.values_[key];
                  delete this.values_[key];
                  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[
                    /* isEmpty */
                    "d"
                  ])(this.values_)) {
                    this.values_ = null;
                  }
                  if (!opt_silent) {
                    this.notify(key, oldValue);
                  }
                }
              };
              return BaseObject2;
            }(_Observable_js__WEBPACK_IMPORTED_MODULE_2__[
              /* default */
              "a"
            ])
          );
          __webpack_exports__["a"] = BaseObject;
        }
      ),
      /***/
      "e439": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var fails = __webpack_require__("d039");
          var toIndexedObject = __webpack_require__("fc6a");
          var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var DESCRIPTORS = __webpack_require__("83ab");
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeGetOwnPropertyDescriptor(1);
          });
          var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
          $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
              return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
            }
          });
        }
      ),
      /***/
      "e538": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          exports2.f = wellKnownSymbol;
        }
      ),
      /***/
      "e893": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var has = __webpack_require__("5135");
          var ownKeys = __webpack_require__("56ef");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var definePropertyModule = __webpack_require__("9bf2");
          module2.exports = function(target, source) {
            var keys = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          };
        }
      ),
      /***/
      "e8b5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var classof = __webpack_require__("c6b6");
          module2.exports = Array.isArray || function isArray2(arg) {
            return classof(arg) == "Array";
          };
        }
      ),
      /***/
      "e95a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          var Iterators = __webpack_require__("3f8c");
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        }
      ),
      /***/
      "f5df": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
          var classofRaw = __webpack_require__("c6b6");
          var wellKnownSymbol = __webpack_require__("b622");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error) {
            }
          };
          module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
            var O, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
          };
        }
      ),
      /***/
      "f772": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var shared = __webpack_require__("5692");
          var uid = __webpack_require__("90e3");
          var keys = shared("keys");
          module2.exports = function(key) {
            return keys[key] || (keys[key] = uid(key));
          };
        }
      ),
      /***/
      "fb15": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "install", function() {
            return (
              /* reexport */
              src_install
            );
          });
          __webpack_require__.d(__webpack_exports__, "Map", function() {
            return (
              /* reexport */
              map_namespaceObject
            );
          });
          __webpack_require__.d(__webpack_exports__, "Layers", function() {
            return (
              /* reexport */
              layers_namespaceObject
            );
          });
          __webpack_require__.d(__webpack_exports__, "Sources", function() {
            return (
              /* reexport */
              sources_namespaceObject
            );
          });
          __webpack_require__.d(__webpack_exports__, "MapControls", function() {
            return (
              /* reexport */
              mapControls_namespaceObject
            );
          });
          __webpack_require__.d(__webpack_exports__, "Geometries", function() {
            return (
              /* reexport */
              geometries_namespaceObject
            );
          });
          __webpack_require__.d(__webpack_exports__, "Styles", function() {
            return (
              /* reexport */
              styles_namespaceObject
            );
          });
          var extent_namespaceObject = {};
          __webpack_require__.r(extent_namespaceObject);
          __webpack_require__.d(extent_namespaceObject, "boundingExtent", function() {
            return boundingExtent;
          });
          __webpack_require__.d(extent_namespaceObject, "buffer", function() {
            return extent_buffer;
          });
          __webpack_require__.d(extent_namespaceObject, "clone", function() {
            return clone;
          });
          __webpack_require__.d(extent_namespaceObject, "closestSquaredDistanceXY", function() {
            return closestSquaredDistanceXY;
          });
          __webpack_require__.d(extent_namespaceObject, "containsCoordinate", function() {
            return containsCoordinate;
          });
          __webpack_require__.d(extent_namespaceObject, "containsExtent", function() {
            return containsExtent;
          });
          __webpack_require__.d(extent_namespaceObject, "containsXY", function() {
            return containsXY;
          });
          __webpack_require__.d(extent_namespaceObject, "coordinateRelationship", function() {
            return coordinateRelationship;
          });
          __webpack_require__.d(extent_namespaceObject, "createEmpty", function() {
            return createEmpty;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdate", function() {
            return createOrUpdate;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdateEmpty", function() {
            return createOrUpdateEmpty;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromCoordinate", function() {
            return createOrUpdateFromCoordinate;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromCoordinates", function() {
            return createOrUpdateFromCoordinates;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromFlatCoordinates", function() {
            return createOrUpdateFromFlatCoordinates;
          });
          __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromRings", function() {
            return createOrUpdateFromRings;
          });
          __webpack_require__.d(extent_namespaceObject, "equals", function() {
            return equals;
          });
          __webpack_require__.d(extent_namespaceObject, "approximatelyEquals", function() {
            return approximatelyEquals;
          });
          __webpack_require__.d(extent_namespaceObject, "extend", function() {
            return extend2;
          });
          __webpack_require__.d(extent_namespaceObject, "extendCoordinate", function() {
            return extendCoordinate;
          });
          __webpack_require__.d(extent_namespaceObject, "extendCoordinates", function() {
            return extendCoordinates;
          });
          __webpack_require__.d(extent_namespaceObject, "extendFlatCoordinates", function() {
            return extendFlatCoordinates;
          });
          __webpack_require__.d(extent_namespaceObject, "extendRings", function() {
            return extendRings;
          });
          __webpack_require__.d(extent_namespaceObject, "extendXY", function() {
            return extendXY;
          });
          __webpack_require__.d(extent_namespaceObject, "forEachCorner", function() {
            return forEachCorner;
          });
          __webpack_require__.d(extent_namespaceObject, "getArea", function() {
            return getArea;
          });
          __webpack_require__.d(extent_namespaceObject, "getBottomLeft", function() {
            return getBottomLeft;
          });
          __webpack_require__.d(extent_namespaceObject, "getBottomRight", function() {
            return getBottomRight;
          });
          __webpack_require__.d(extent_namespaceObject, "getCenter", function() {
            return extent_getCenter;
          });
          __webpack_require__.d(extent_namespaceObject, "getCorner", function() {
            return getCorner;
          });
          __webpack_require__.d(extent_namespaceObject, "getEnlargedArea", function() {
            return getEnlargedArea;
          });
          __webpack_require__.d(extent_namespaceObject, "getForViewAndSize", function() {
            return getForViewAndSize;
          });
          __webpack_require__.d(extent_namespaceObject, "getHeight", function() {
            return getHeight;
          });
          __webpack_require__.d(extent_namespaceObject, "getIntersectionArea", function() {
            return getIntersectionArea;
          });
          __webpack_require__.d(extent_namespaceObject, "getIntersection", function() {
            return getIntersection;
          });
          __webpack_require__.d(extent_namespaceObject, "getMargin", function() {
            return getMargin;
          });
          __webpack_require__.d(extent_namespaceObject, "getSize", function() {
            return getSize;
          });
          __webpack_require__.d(extent_namespaceObject, "getTopLeft", function() {
            return getTopLeft;
          });
          __webpack_require__.d(extent_namespaceObject, "getTopRight", function() {
            return getTopRight;
          });
          __webpack_require__.d(extent_namespaceObject, "getWidth", function() {
            return getWidth;
          });
          __webpack_require__.d(extent_namespaceObject, "intersects", function() {
            return extent_intersects;
          });
          __webpack_require__.d(extent_namespaceObject, "isEmpty", function() {
            return extent_isEmpty;
          });
          __webpack_require__.d(extent_namespaceObject, "returnOrUpdate", function() {
            return returnOrUpdate;
          });
          __webpack_require__.d(extent_namespaceObject, "scaleFromCenter", function() {
            return scaleFromCenter;
          });
          __webpack_require__.d(extent_namespaceObject, "intersectsSegment", function() {
            return intersectsSegment;
          });
          __webpack_require__.d(extent_namespaceObject, "applyTransform", function() {
            return applyTransform;
          });
          __webpack_require__.d(extent_namespaceObject, "wrapX", function() {
            return extent_wrapX;
          });
          var easing_namespaceObject = {};
          __webpack_require__.r(easing_namespaceObject);
          __webpack_require__.d(easing_namespaceObject, "easeIn", function() {
            return easeIn;
          });
          __webpack_require__.d(easing_namespaceObject, "easeOut", function() {
            return easeOut;
          });
          __webpack_require__.d(easing_namespaceObject, "inAndOut", function() {
            return inAndOut;
          });
          __webpack_require__.d(easing_namespaceObject, "linear", function() {
            return linear;
          });
          __webpack_require__.d(easing_namespaceObject, "upAndDown", function() {
            return upAndDown;
          });
          var condition_namespaceObject = {};
          __webpack_require__.r(condition_namespaceObject);
          __webpack_require__.d(condition_namespaceObject, "all", function() {
            return condition_all;
          });
          __webpack_require__.d(condition_namespaceObject, "altKeyOnly", function() {
            return altKeyOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "altShiftKeysOnly", function() {
            return altShiftKeysOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "focus", function() {
            return condition_focus;
          });
          __webpack_require__.d(condition_namespaceObject, "focusWithTabindex", function() {
            return focusWithTabindex;
          });
          __webpack_require__.d(condition_namespaceObject, "always", function() {
            return always;
          });
          __webpack_require__.d(condition_namespaceObject, "click", function() {
            return click;
          });
          __webpack_require__.d(condition_namespaceObject, "mouseActionButton", function() {
            return mouseActionButton;
          });
          __webpack_require__.d(condition_namespaceObject, "never", function() {
            return never;
          });
          __webpack_require__.d(condition_namespaceObject, "pointerMove", function() {
            return pointerMove;
          });
          __webpack_require__.d(condition_namespaceObject, "singleClick", function() {
            return singleClick;
          });
          __webpack_require__.d(condition_namespaceObject, "doubleClick", function() {
            return doubleClick;
          });
          __webpack_require__.d(condition_namespaceObject, "noModifierKeys", function() {
            return noModifierKeys;
          });
          __webpack_require__.d(condition_namespaceObject, "platformModifierKeyOnly", function() {
            return platformModifierKeyOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "shiftKeyOnly", function() {
            return shiftKeyOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "targetNotEditable", function() {
            return targetNotEditable;
          });
          __webpack_require__.d(condition_namespaceObject, "mouseOnly", function() {
            return mouseOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "touchOnly", function() {
            return touchOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "penOnly", function() {
            return penOnly;
          });
          __webpack_require__.d(condition_namespaceObject, "primaryAction", function() {
            return primaryAction;
          });
          var map_namespaceObject = {};
          __webpack_require__.r(map_namespaceObject);
          __webpack_require__.d(map_namespaceObject, "default", function() {
            return components_map;
          });
          __webpack_require__.d(map_namespaceObject, "install", function() {
            return install;
          });
          __webpack_require__.d(map_namespaceObject, "Map", function() {
            return map_Map;
          });
          __webpack_require__.d(map_namespaceObject, "View", function() {
            return map_View;
          });
          __webpack_require__.d(map_namespaceObject, "Feature", function() {
            return map_Feature;
          });
          __webpack_require__.d(map_namespaceObject, "Overlay", function() {
            return map_Overlay;
          });
          __webpack_require__.d(map_namespaceObject, "GeoLocation", function() {
            return GeoLocation;
          });
          var loadingstrategy_namespaceObject = {};
          __webpack_require__.r(loadingstrategy_namespaceObject);
          __webpack_require__.d(loadingstrategy_namespaceObject, "all", function() {
            return loadingstrategy_all;
          });
          __webpack_require__.d(loadingstrategy_namespaceObject, "bbox", function() {
            return loadingstrategy_bbox;
          });
          __webpack_require__.d(loadingstrategy_namespaceObject, "tile", function() {
            return loadingstrategy_tile;
          });
          var layers_namespaceObject = {};
          __webpack_require__.r(layers_namespaceObject);
          __webpack_require__.d(layers_namespaceObject, "default", function() {
            return components_layers;
          });
          __webpack_require__.d(layers_namespaceObject, "install", function() {
            return layers_install;
          });
          __webpack_require__.d(layers_namespaceObject, "TileLayer", function() {
            return layers_TileLayer;
          });
          __webpack_require__.d(layers_namespaceObject, "ImageLayer", function() {
            return layers_ImageLayer;
          });
          __webpack_require__.d(layers_namespaceObject, "VectorLayer", function() {
            return layers_VectorLayer;
          });
          __webpack_require__.d(layers_namespaceObject, "AnimatedClusterLayer", function() {
            return AnimatedClusterLayer;
          });
          var sources_namespaceObject = {};
          __webpack_require__.r(sources_namespaceObject);
          __webpack_require__.d(sources_namespaceObject, "default", function() {
            return components_sources;
          });
          __webpack_require__.d(sources_namespaceObject, "install", function() {
            return sources_install;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceXYZ", function() {
            return SourceXYZ;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceOSM", function() {
            return SourceOSM;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceImageStatic", function() {
            return SourceImageStatic;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceWMTS", function() {
            return SourceWMTS;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceVector", function() {
            return SourceVector;
          });
          __webpack_require__.d(sources_namespaceObject, "SourceCluster", function() {
            return SourceCluster;
          });
          var mapControls_namespaceObject = {};
          __webpack_require__.r(mapControls_namespaceObject);
          __webpack_require__.d(mapControls_namespaceObject, "default", function() {
            return mapControls;
          });
          __webpack_require__.d(mapControls_namespaceObject, "install", function() {
            return mapControls_install;
          });
          __webpack_require__.d(mapControls_namespaceObject, "FullScreenControl", function() {
            return FullScreenControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "MousePositionControl", function() {
            return MousePositionControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "AttributionControl", function() {
            return AttributionControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "OverviewMapControl", function() {
            return OverviewMapControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "ScaleLineControl", function() {
            return ScaleLineControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "ZoomControl", function() {
            return ZoomControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "ZoomSliderControl", function() {
            return ZoomSliderControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "ZoomToExtentControl", function() {
            return ZoomToExtentControl;
          });
          __webpack_require__.d(mapControls_namespaceObject, "ContextMenuControl", function() {
            return ContextMenuControl;
          });
          var geometries_namespaceObject = {};
          __webpack_require__.r(geometries_namespaceObject);
          __webpack_require__.d(geometries_namespaceObject, "default", function() {
            return components_geometries;
          });
          __webpack_require__.d(geometries_namespaceObject, "install", function() {
            return geometries_install;
          });
          __webpack_require__.d(geometries_namespaceObject, "Point", function() {
            return geometries_Point;
          });
          __webpack_require__.d(geometries_namespaceObject, "LineString", function() {
            return geometries_LineString;
          });
          __webpack_require__.d(geometries_namespaceObject, "Polygon", function() {
            return geometries_Polygon;
          });
          __webpack_require__.d(geometries_namespaceObject, "MultiPoint", function() {
            return geometries_MultiPoint;
          });
          __webpack_require__.d(geometries_namespaceObject, "MultiLineString", function() {
            return geometries_MultiLineString;
          });
          __webpack_require__.d(geometries_namespaceObject, "MultiPolygon", function() {
            return geometries_MultiPolygon;
          });
          var styles_namespaceObject = {};
          __webpack_require__.r(styles_namespaceObject);
          __webpack_require__.d(styles_namespaceObject, "default", function() {
            return components_styles;
          });
          __webpack_require__.d(styles_namespaceObject, "install", function() {
            return styles_install;
          });
          __webpack_require__.d(styles_namespaceObject, "Style", function() {
            return styles_Style;
          });
          __webpack_require__.d(styles_namespaceObject, "Stroke", function() {
            return styles_Stroke;
          });
          __webpack_require__.d(styles_namespaceObject, "Fill", function() {
            return styles_Fill;
          });
          __webpack_require__.d(styles_namespaceObject, "Icon", function() {
            return styles_Icon;
          });
          __webpack_require__.d(styles_namespaceObject, "Text", function() {
            return styles_Text;
          });
          var components_interaction_namespaceObject = {};
          __webpack_require__.r(components_interaction_namespaceObject);
          __webpack_require__.d(components_interaction_namespaceObject, "default", function() {
            return components_interaction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "install", function() {
            return interaction_install;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "SelectInteraction", function() {
            return SelectInteraction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "ClusterSelectInteraction", function() {
            return ClusterSelectInteraction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "DrawInteraction", function() {
            return DrawInteraction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "SnapInteraction", function() {
            return SnapInteraction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "ModifyInteraction", function() {
            return ModifyInteraction;
          });
          __webpack_require__.d(components_interaction_namespaceObject, "TransformInteraction", function() {
            return TransformInteraction;
          });
          var animations_namespaceObject = {};
          __webpack_require__.r(animations_namespaceObject);
          __webpack_require__.d(animations_namespaceObject, "default", function() {
            return animations;
          });
          __webpack_require__.d(animations_namespaceObject, "install", function() {
            return animations_install;
          });
          __webpack_require__.d(animations_namespaceObject, "FeatureAnimation", function() {
            return FeatureAnimation;
          });
          __webpack_require__.d(animations_namespaceObject, "DropAnimation", function() {
            return DropAnimation;
          });
          __webpack_require__.d(animations_namespaceObject, "ShakeAnimation", function() {
            return ShakeAnimation;
          });
          __webpack_require__.d(animations_namespaceObject, "ZoomAnimation", function() {
            return ZoomAnimation;
          });
          __webpack_require__.d(animations_namespaceObject, "TeleportAnimation", function() {
            return TeleportAnimation;
          });
          __webpack_require__.d(animations_namespaceObject, "FadeAnimation", function() {
            return FadeAnimation;
          });
          var geom_namespaceObject = {};
          __webpack_require__.r(geom_namespaceObject);
          __webpack_require__.d(geom_namespaceObject, "Circle", function() {
            return geom_Circle;
          });
          __webpack_require__.d(geom_namespaceObject, "Geometry", function() {
            return geom_Geometry;
          });
          __webpack_require__.d(geom_namespaceObject, "GeometryCollection", function() {
            return geom_GeometryCollection;
          });
          __webpack_require__.d(geom_namespaceObject, "LinearRing", function() {
            return geom_LinearRing;
          });
          __webpack_require__.d(geom_namespaceObject, "LineString", function() {
            return geom_LineString;
          });
          __webpack_require__.d(geom_namespaceObject, "MultiLineString", function() {
            return geom_MultiLineString;
          });
          __webpack_require__.d(geom_namespaceObject, "MultiPoint", function() {
            return geom_MultiPoint;
          });
          __webpack_require__.d(geom_namespaceObject, "MultiPolygon", function() {
            return geom_MultiPolygon;
          });
          __webpack_require__.d(geom_namespaceObject, "Point", function() {
            return geom_Point;
          });
          __webpack_require__.d(geom_namespaceObject, "Polygon", function() {
            return geom_Polygon;
          });
          __webpack_require__.d(geom_namespaceObject, "SimpleGeometry", function() {
            return geom_SimpleGeometry;
          });
          var format_namespaceObject = {};
          __webpack_require__.r(format_namespaceObject);
          __webpack_require__.d(format_namespaceObject, "EsriJSON", function() {
            return format_EsriJSON;
          });
          __webpack_require__.d(format_namespaceObject, "GeoJSON", function() {
            return format_GeoJSON;
          });
          __webpack_require__.d(format_namespaceObject, "GML", function() {
            return format_GML;
          });
          __webpack_require__.d(format_namespaceObject, "GPX", function() {
            return format_GPX;
          });
          __webpack_require__.d(format_namespaceObject, "IGC", function() {
            return format_IGC;
          });
          __webpack_require__.d(format_namespaceObject, "IIIFInfo", function() {
            return format_IIIFInfo;
          });
          __webpack_require__.d(format_namespaceObject, "KML", function() {
            return format_KML;
          });
          __webpack_require__.d(format_namespaceObject, "MVT", function() {
            return format_MVT;
          });
          __webpack_require__.d(format_namespaceObject, "OWS", function() {
            return format_OWS;
          });
          __webpack_require__.d(format_namespaceObject, "Polyline", function() {
            return format_Polyline;
          });
          __webpack_require__.d(format_namespaceObject, "TopoJSON", function() {
            return format_TopoJSON;
          });
          __webpack_require__.d(format_namespaceObject, "WFS", function() {
            return format_WFS;
          });
          __webpack_require__.d(format_namespaceObject, "WKT", function() {
            return format_WKT;
          });
          __webpack_require__.d(format_namespaceObject, "WMSCapabilities", function() {
            return format_WMSCapabilities;
          });
          __webpack_require__.d(format_namespaceObject, "WMSGetFeatureInfo", function() {
            return format_WMSGetFeatureInfo;
          });
          __webpack_require__.d(format_namespaceObject, "WMTSCapabilities", function() {
            return format_WMTSCapabilities;
          });
          if (typeof window !== "undefined") {
            var currentScript = window.document.currentScript;
            if (true) {
              var getCurrentScript = __webpack_require__("8875");
              currentScript = getCurrentScript();
              if (!("currentScript" in document)) {
                Object.defineProperty(document, "currentScript", { get: getCurrentScript });
              }
            }
            var setPublicPath_src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
            if (setPublicPath_src) {
              __webpack_require__.p = setPublicPath_src[1];
            }
          }
          var setPublicPath = null;
          var es_function_name = __webpack_require__("b0c0");
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
          function Mapvue_type_template_id_39e43851_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", {
              ref: function ref(el) {
                return $setup.mapRef = el;
              }
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")], 512);
          }
          var es_number_constructor = __webpack_require__("a9e3");
          var Disposable = __webpack_require__("da5c");
          var functions = __webpack_require__("57cb");
          var util = __webpack_require__("1300");
          var has = __webpack_require__("617d");
          var __extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var AssertionError_AssertionError = (
            /** @class */
            function(_super) {
              __extends(AssertionError, _super);
              function AssertionError(code) {
                var _this = this;
                var path = util[
                  "a"
                  /* VERSION */
                ] === "latest" ? util[
                  "a"
                  /* VERSION */
                ] : "v" + util[
                  "a"
                  /* VERSION */
                ].split("-")[0];
                var message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
                _this = _super.call(this, message) || this;
                _this.code = code;
                _this.name = "AssertionError";
                _this.message = message;
                return _this;
              }
              return AssertionError;
            }(Error)
          );
          var ol_AssertionError = AssertionError_AssertionError;
          function assert2(assertion, errorCode) {
            if (!assertion) {
              throw new ol_AssertionError(errorCode);
            }
          }
          var tmp_ = new Array(6);
          function create() {
            return [1, 0, 0, 1, 0, 0];
          }
          function transform_reset(transform2) {
            return transform_set(transform2, 1, 0, 0, 1, 0, 0);
          }
          function multiply(transform1, transform2) {
            var a1 = transform1[0];
            var b1 = transform1[1];
            var c1 = transform1[2];
            var d1 = transform1[3];
            var e1 = transform1[4];
            var f1 = transform1[5];
            var a2 = transform2[0];
            var b2 = transform2[1];
            var c2 = transform2[2];
            var d2 = transform2[3];
            var e2 = transform2[4];
            var f2 = transform2[5];
            transform1[0] = a1 * a2 + c1 * b2;
            transform1[1] = b1 * a2 + d1 * b2;
            transform1[2] = a1 * c2 + c1 * d2;
            transform1[3] = b1 * c2 + d1 * d2;
            transform1[4] = a1 * e2 + c1 * f2 + e1;
            transform1[5] = b1 * e2 + d1 * f2 + f1;
            return transform1;
          }
          function transform_set(transform2, a, b, c, d, e, f) {
            transform2[0] = a;
            transform2[1] = b;
            transform2[2] = c;
            transform2[3] = d;
            transform2[4] = e;
            transform2[5] = f;
            return transform2;
          }
          function setFromArray(transform1, transform2) {
            transform1[0] = transform2[0];
            transform1[1] = transform2[1];
            transform1[2] = transform2[2];
            transform1[3] = transform2[3];
            transform1[4] = transform2[4];
            transform1[5] = transform2[5];
            return transform1;
          }
          function apply(transform2, coordinate) {
            var x = coordinate[0];
            var y = coordinate[1];
            coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
            coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
            return coordinate;
          }
          function rotate(transform2, angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            return multiply(transform2, transform_set(tmp_, cos, sin, -sin, cos, 0, 0));
          }
          function transform_scale(transform2, x, y) {
            return multiply(transform2, transform_set(tmp_, x, 0, 0, y, 0, 0));
          }
          function makeScale(target, x, y) {
            return transform_set(target, x, 0, 0, y, 0, 0);
          }
          function transform_translate(transform2, dx, dy) {
            return multiply(transform2, transform_set(tmp_, 1, 0, 0, 1, dx, dy));
          }
          function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
            var sin = Math.sin(angle);
            var cos = Math.cos(angle);
            transform2[0] = sx * cos;
            transform2[1] = sy * sin;
            transform2[2] = -sx * sin;
            transform2[3] = sy * cos;
            transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
            transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
            return transform2;
          }
          function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
            return transform_toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
          }
          function invert(source) {
            return makeInverse(source, source);
          }
          function makeInverse(target, source) {
            var det = determinant(source);
            assert2(det !== 0, 32);
            var a = source[0];
            var b = source[1];
            var c = source[2];
            var d = source[3];
            var e = source[4];
            var f = source[5];
            target[0] = d / det;
            target[1] = -b / det;
            target[2] = -c / det;
            target[3] = a / det;
            target[4] = (c * f - d * e) / det;
            target[5] = -(a * f - b * e) / det;
            return target;
          }
          function determinant(mat) {
            return mat[0] * mat[3] - mat[1] * mat[2];
          }
          var transformStringDiv;
          function transform_toString(mat) {
            var transformString = "matrix(" + mat.join(", ") + ")";
            if (has[
              "g"
              /* WORKER_OFFSCREEN_CANVAS */
            ]) {
              return transformString;
            }
            var node = transformStringDiv || (transformStringDiv = document.createElement("div"));
            node.style.transform = transformString;
            return node.style.transform;
          }
          var Corner = {
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_RIGHT: "bottom-right",
            TOP_LEFT: "top-left",
            TOP_RIGHT: "top-right"
          };
          var Relationship = {
            UNKNOWN: 0,
            INTERSECTING: 1,
            ABOVE: 2,
            RIGHT: 4,
            BELOW: 8,
            LEFT: 16
          };
          function boundingExtent(coordinates) {
            var extent = createEmpty();
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              extendCoordinate(extent, coordinates[i]);
            }
            return extent;
          }
          function _boundingExtentXYs(xs, ys, opt_extent) {
            var minX = Math.min.apply(null, xs);
            var minY = Math.min.apply(null, ys);
            var maxX = Math.max.apply(null, xs);
            var maxY = Math.max.apply(null, ys);
            return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
          }
          function extent_buffer(extent, value, opt_extent) {
            if (opt_extent) {
              opt_extent[0] = extent[0] - value;
              opt_extent[1] = extent[1] - value;
              opt_extent[2] = extent[2] + value;
              opt_extent[3] = extent[3] + value;
              return opt_extent;
            } else {
              return [
                extent[0] - value,
                extent[1] - value,
                extent[2] + value,
                extent[3] + value
              ];
            }
          }
          function clone(extent, opt_extent) {
            if (opt_extent) {
              opt_extent[0] = extent[0];
              opt_extent[1] = extent[1];
              opt_extent[2] = extent[2];
              opt_extent[3] = extent[3];
              return opt_extent;
            } else {
              return extent.slice();
            }
          }
          function closestSquaredDistanceXY(extent, x, y) {
            var dx, dy;
            if (x < extent[0]) {
              dx = extent[0] - x;
            } else if (extent[2] < x) {
              dx = x - extent[2];
            } else {
              dx = 0;
            }
            if (y < extent[1]) {
              dy = extent[1] - y;
            } else if (extent[3] < y) {
              dy = y - extent[3];
            } else {
              dy = 0;
            }
            return dx * dx + dy * dy;
          }
          function containsCoordinate(extent, coordinate) {
            return containsXY(extent, coordinate[0], coordinate[1]);
          }
          function containsExtent(extent1, extent2) {
            return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
          }
          function containsXY(extent, x, y) {
            return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
          }
          function coordinateRelationship(extent, coordinate) {
            var minX = extent[0];
            var minY = extent[1];
            var maxX = extent[2];
            var maxY = extent[3];
            var x = coordinate[0];
            var y = coordinate[1];
            var relationship = Relationship.UNKNOWN;
            if (x < minX) {
              relationship = relationship | Relationship.LEFT;
            } else if (x > maxX) {
              relationship = relationship | Relationship.RIGHT;
            }
            if (y < minY) {
              relationship = relationship | Relationship.BELOW;
            } else if (y > maxY) {
              relationship = relationship | Relationship.ABOVE;
            }
            if (relationship === Relationship.UNKNOWN) {
              relationship = Relationship.INTERSECTING;
            }
            return relationship;
          }
          function createEmpty() {
            return [Infinity, Infinity, -Infinity, -Infinity];
          }
          function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
            if (opt_extent) {
              opt_extent[0] = minX;
              opt_extent[1] = minY;
              opt_extent[2] = maxX;
              opt_extent[3] = maxY;
              return opt_extent;
            } else {
              return [minX, minY, maxX, maxY];
            }
          }
          function createOrUpdateEmpty(opt_extent) {
            return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
          }
          function createOrUpdateFromCoordinate(coordinate, opt_extent) {
            var x = coordinate[0];
            var y = coordinate[1];
            return createOrUpdate(x, y, x, y, opt_extent);
          }
          function createOrUpdateFromCoordinates(coordinates, opt_extent) {
            var extent = createOrUpdateEmpty(opt_extent);
            return extendCoordinates(extent, coordinates);
          }
          function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
            var extent = createOrUpdateEmpty(opt_extent);
            return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
          }
          function createOrUpdateFromRings(rings, opt_extent) {
            var extent = createOrUpdateEmpty(opt_extent);
            return extendRings(extent, rings);
          }
          function equals(extent1, extent2) {
            return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
          }
          function approximatelyEquals(extent1, extent2, tolerance) {
            return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
          }
          function extend2(extent1, extent2) {
            if (extent2[0] < extent1[0]) {
              extent1[0] = extent2[0];
            }
            if (extent2[2] > extent1[2]) {
              extent1[2] = extent2[2];
            }
            if (extent2[1] < extent1[1]) {
              extent1[1] = extent2[1];
            }
            if (extent2[3] > extent1[3]) {
              extent1[3] = extent2[3];
            }
            return extent1;
          }
          function extendCoordinate(extent, coordinate) {
            if (coordinate[0] < extent[0]) {
              extent[0] = coordinate[0];
            }
            if (coordinate[0] > extent[2]) {
              extent[2] = coordinate[0];
            }
            if (coordinate[1] < extent[1]) {
              extent[1] = coordinate[1];
            }
            if (coordinate[1] > extent[3]) {
              extent[3] = coordinate[1];
            }
          }
          function extendCoordinates(extent, coordinates) {
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              extendCoordinate(extent, coordinates[i]);
            }
            return extent;
          }
          function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
            for (; offset < end; offset += stride) {
              extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
            }
            return extent;
          }
          function extendRings(extent, rings) {
            for (var i = 0, ii = rings.length; i < ii; ++i) {
              extendCoordinates(extent, rings[i]);
            }
            return extent;
          }
          function extendXY(extent, x, y) {
            extent[0] = Math.min(extent[0], x);
            extent[1] = Math.min(extent[1], y);
            extent[2] = Math.max(extent[2], x);
            extent[3] = Math.max(extent[3], y);
          }
          function forEachCorner(extent, callback) {
            var val;
            val = callback(getBottomLeft(extent));
            if (val) {
              return val;
            }
            val = callback(getBottomRight(extent));
            if (val) {
              return val;
            }
            val = callback(getTopRight(extent));
            if (val) {
              return val;
            }
            val = callback(getTopLeft(extent));
            if (val) {
              return val;
            }
            return false;
          }
          function getArea(extent) {
            var area = 0;
            if (!extent_isEmpty(extent)) {
              area = getWidth(extent) * getHeight(extent);
            }
            return area;
          }
          function getBottomLeft(extent) {
            return [extent[0], extent[1]];
          }
          function getBottomRight(extent) {
            return [extent[2], extent[1]];
          }
          function extent_getCenter(extent) {
            return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
          }
          function getCorner(extent, corner) {
            var coordinate;
            if (corner === Corner.BOTTOM_LEFT) {
              coordinate = getBottomLeft(extent);
            } else if (corner === Corner.BOTTOM_RIGHT) {
              coordinate = getBottomRight(extent);
            } else if (corner === Corner.TOP_LEFT) {
              coordinate = getTopLeft(extent);
            } else if (corner === Corner.TOP_RIGHT) {
              coordinate = getTopRight(extent);
            } else {
              assert2(false, 13);
            }
            return coordinate;
          }
          function getEnlargedArea(extent1, extent2) {
            var minX = Math.min(extent1[0], extent2[0]);
            var minY = Math.min(extent1[1], extent2[1]);
            var maxX = Math.max(extent1[2], extent2[2]);
            var maxY = Math.max(extent1[3], extent2[3]);
            return (maxX - minX) * (maxY - minY);
          }
          function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
            var dx = resolution * size[0] / 2;
            var dy = resolution * size[1] / 2;
            var cosRotation = Math.cos(rotation);
            var sinRotation = Math.sin(rotation);
            var xCos = dx * cosRotation;
            var xSin = dx * sinRotation;
            var yCos = dy * cosRotation;
            var ySin = dy * sinRotation;
            var x = center[0];
            var y = center[1];
            var x0 = x - xCos + ySin;
            var x1 = x - xCos - ySin;
            var x2 = x + xCos - ySin;
            var x3 = x + xCos + ySin;
            var y0 = y - xSin - yCos;
            var y1 = y - xSin + yCos;
            var y2 = y + xSin + yCos;
            var y3 = y + xSin - yCos;
            return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
          }
          function getHeight(extent) {
            return extent[3] - extent[1];
          }
          function getIntersectionArea(extent1, extent2) {
            var intersection = getIntersection(extent1, extent2);
            return getArea(intersection);
          }
          function getIntersection(extent1, extent2, opt_extent) {
            var intersection = opt_extent ? opt_extent : createEmpty();
            if (extent_intersects(extent1, extent2)) {
              if (extent1[0] > extent2[0]) {
                intersection[0] = extent1[0];
              } else {
                intersection[0] = extent2[0];
              }
              if (extent1[1] > extent2[1]) {
                intersection[1] = extent1[1];
              } else {
                intersection[1] = extent2[1];
              }
              if (extent1[2] < extent2[2]) {
                intersection[2] = extent1[2];
              } else {
                intersection[2] = extent2[2];
              }
              if (extent1[3] < extent2[3]) {
                intersection[3] = extent1[3];
              } else {
                intersection[3] = extent2[3];
              }
            } else {
              createOrUpdateEmpty(intersection);
            }
            return intersection;
          }
          function getMargin(extent) {
            return getWidth(extent) + getHeight(extent);
          }
          function getSize(extent) {
            return [extent[2] - extent[0], extent[3] - extent[1]];
          }
          function getTopLeft(extent) {
            return [extent[0], extent[3]];
          }
          function getTopRight(extent) {
            return [extent[2], extent[3]];
          }
          function getWidth(extent) {
            return extent[2] - extent[0];
          }
          function extent_intersects(extent1, extent2) {
            return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
          }
          function extent_isEmpty(extent) {
            return extent[2] < extent[0] || extent[3] < extent[1];
          }
          function returnOrUpdate(extent, opt_extent) {
            if (opt_extent) {
              opt_extent[0] = extent[0];
              opt_extent[1] = extent[1];
              opt_extent[2] = extent[2];
              opt_extent[3] = extent[3];
              return opt_extent;
            } else {
              return extent;
            }
          }
          function scaleFromCenter(extent, value) {
            var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
            var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
            extent[0] -= deltaX;
            extent[2] += deltaX;
            extent[1] -= deltaY;
            extent[3] += deltaY;
          }
          function intersectsSegment(extent, start, end) {
            var intersects = false;
            var startRel = coordinateRelationship(extent, start);
            var endRel = coordinateRelationship(extent, end);
            if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
              intersects = true;
            } else {
              var minX = extent[0];
              var minY = extent[1];
              var maxX = extent[2];
              var maxY = extent[3];
              var startX = start[0];
              var startY = start[1];
              var endX = end[0];
              var endY = end[1];
              var slope = (endY - startY) / (endX - startX);
              var x = void 0, y = void 0;
              if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
                x = endX - (endY - maxY) / slope;
                intersects = x >= minX && x <= maxX;
              }
              if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
                y = endY - (endX - maxX) * slope;
                intersects = y >= minY && y <= maxY;
              }
              if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
                x = endX - (endY - minY) / slope;
                intersects = x >= minX && x <= maxX;
              }
              if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
                y = endY - (endX - minX) * slope;
                intersects = y >= minY && y <= maxY;
              }
            }
            return intersects;
          }
          function applyTransform(extent, transformFn, opt_extent, opt_stops) {
            var coordinates = [];
            if (opt_stops > 1) {
              var width = extent[2] - extent[0];
              var height = extent[3] - extent[1];
              for (var i = 0; i < opt_stops; ++i) {
                coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
              }
            } else {
              coordinates = [
                extent[0],
                extent[1],
                extent[2],
                extent[1],
                extent[2],
                extent[3],
                extent[0],
                extent[3]
              ];
            }
            transformFn(coordinates, coordinates, 2);
            var xs = [];
            var ys = [];
            for (var i = 0, l = coordinates.length; i < l; i += 2) {
              xs.push(coordinates[i]);
              ys.push(coordinates[i + 1]);
            }
            return _boundingExtentXYs(xs, ys, opt_extent);
          }
          function extent_wrapX(extent, projection) {
            var projectionExtent = projection.getExtent();
            var center = extent_getCenter(extent);
            if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
              var worldWidth = getWidth(projectionExtent);
              var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
              var offset = worldsAway * worldWidth;
              extent[0] -= offset;
              extent[2] -= offset;
            }
            return extent;
          }
          function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
          }
          var cosh = function() {
            var cosh2;
            if ("cosh" in Math) {
              cosh2 = Math.cosh;
            } else {
              cosh2 = function(x) {
                var y = (
                  /** @type {Math} */
                  Math.exp(x)
                );
                return (y + 1 / y) / 2;
              };
            }
            return cosh2;
          }();
          var log2 = function() {
            var log22;
            if ("log2" in Math) {
              log22 = Math.log2;
            } else {
              log22 = function(x) {
                return Math.log(x) * Math.LOG2E;
              };
            }
            return log22;
          }();
          function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
            var dx = x2 - x1;
            var dy = y2 - y1;
            if (dx !== 0 || dy !== 0) {
              var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
              if (t > 1) {
                x1 = x2;
                y1 = y2;
              } else if (t > 0) {
                x1 += dx * t;
                y1 += dy * t;
              }
            }
            return math_squaredDistance(x, y, x1, y1);
          }
          function math_squaredDistance(x1, y1, x2, y2) {
            var dx = x2 - x1;
            var dy = y2 - y1;
            return dx * dx + dy * dy;
          }
          function solveLinearSystem(mat) {
            var n = mat.length;
            for (var i = 0; i < n; i++) {
              var maxRow = i;
              var maxEl = Math.abs(mat[i][i]);
              for (var r = i + 1; r < n; r++) {
                var absValue = Math.abs(mat[r][i]);
                if (absValue > maxEl) {
                  maxEl = absValue;
                  maxRow = r;
                }
              }
              if (maxEl === 0) {
                return null;
              }
              var tmp = mat[maxRow];
              mat[maxRow] = mat[i];
              mat[i] = tmp;
              for (var j = i + 1; j < n; j++) {
                var coef = -mat[j][i] / mat[i][i];
                for (var k = i; k < n + 1; k++) {
                  if (i == k) {
                    mat[j][k] = 0;
                  } else {
                    mat[j][k] += coef * mat[i][k];
                  }
                }
              }
            }
            var x = new Array(n);
            for (var l = n - 1; l >= 0; l--) {
              x[l] = mat[l][n] / mat[l][l];
              for (var m = l - 1; m >= 0; m--) {
                mat[m][n] -= mat[m][l] * x[l];
              }
            }
            return x;
          }
          function toDegrees(angleInRadians) {
            return angleInRadians * 180 / Math.PI;
          }
          function toRadians(angleInDegrees) {
            return angleInDegrees * Math.PI / 180;
          }
          function modulo(a, b) {
            var r = a % b;
            return r * b < 0 ? r + b : r;
          }
          function lerp(a, b, x) {
            return a + x * (b - a);
          }
          var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
          var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
          function asString(color) {
            if (typeof color === "string") {
              return color;
            } else {
              return color_toString(color);
            }
          }
          function fromNamed(color) {
            var el = document.createElement("div");
            el.style.color = color;
            if (el.style.color !== "") {
              document.body.appendChild(el);
              var rgb = getComputedStyle(el).color;
              document.body.removeChild(el);
              return rgb;
            } else {
              return "";
            }
          }
          var fromString = /* @__PURE__ */ function() {
            var MAX_CACHE_SIZE = 1024;
            var cache = {};
            var cacheSize = 0;
            return (
              /**
               * @param {string} s String.
               * @return {Color} Color.
               */
              function(s) {
                var color;
                if (cache.hasOwnProperty(s)) {
                  color = cache[s];
                } else {
                  if (cacheSize >= MAX_CACHE_SIZE) {
                    var i = 0;
                    for (var key in cache) {
                      if ((i++ & 3) === 0) {
                        delete cache[key];
                        --cacheSize;
                      }
                    }
                  }
                  color = fromStringInternal_(s);
                  cache[s] = color;
                  ++cacheSize;
                }
                return color;
              }
            );
          }();
          function asArray(color) {
            if (Array.isArray(color)) {
              return color;
            } else {
              return fromString(color);
            }
          }
          function fromStringInternal_(s) {
            var r, g, b, a, color;
            if (NAMED_COLOR_RE_.exec(s)) {
              s = fromNamed(s);
            }
            if (HEX_COLOR_RE_.exec(s)) {
              var n = s.length - 1;
              var d = (
                // number of digits per channel
                void 0
              );
              if (n <= 4) {
                d = 1;
              } else {
                d = 2;
              }
              var hasAlpha = n === 4 || n === 8;
              r = parseInt(s.substr(1 + 0 * d, d), 16);
              g = parseInt(s.substr(1 + 1 * d, d), 16);
              b = parseInt(s.substr(1 + 2 * d, d), 16);
              if (hasAlpha) {
                a = parseInt(s.substr(1 + 3 * d, d), 16);
              } else {
                a = 255;
              }
              if (d == 1) {
                r = (r << 4) + r;
                g = (g << 4) + g;
                b = (b << 4) + b;
                if (hasAlpha) {
                  a = (a << 4) + a;
                }
              }
              color = [r, g, b, a / 255];
            } else if (s.indexOf("rgba(") == 0) {
              color = s.slice(5, -1).split(",").map(Number);
              normalize(color);
            } else if (s.indexOf("rgb(") == 0) {
              color = s.slice(4, -1).split(",").map(Number);
              color.push(1);
              normalize(color);
            } else {
              assert2(false, 14);
            }
            return color;
          }
          function normalize(color) {
            color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
            color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
            color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
            color[3] = clamp(color[3], 0, 1);
            return color;
          }
          function color_toString(color) {
            var r = color[0];
            if (r != (r | 0)) {
              r = r + 0.5 | 0;
            }
            var g = color[1];
            if (g != (g | 0)) {
              g = g + 0.5 | 0;
            }
            var b = color[2];
            if (b != (b | 0)) {
              b = b + 0.5 | 0;
            }
            var a = color[3] === void 0 ? 1 : color[3];
            return "rgba(" + r + "," + g + "," + b + "," + a + ")";
          }
          function isStringColor(s) {
            if (NAMED_COLOR_RE_.test(s)) {
              s = fromNamed(s);
            }
            return HEX_COLOR_RE_.test(s) || s.indexOf("rgba(") === 0 || s.indexOf("rgb(") === 0;
          }
          var IconImageCache = (
            /** @class */
            function() {
              function IconImageCache2() {
                this.cache_ = {};
                this.cacheSize_ = 0;
                this.maxCacheSize_ = 32;
              }
              IconImageCache2.prototype.clear = function() {
                this.cache_ = {};
                this.cacheSize_ = 0;
              };
              IconImageCache2.prototype.canExpireCache = function() {
                return this.cacheSize_ > this.maxCacheSize_;
              };
              IconImageCache2.prototype.expire = function() {
                if (this.canExpireCache()) {
                  var i = 0;
                  for (var key in this.cache_) {
                    var iconImage = this.cache_[key];
                    if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                      delete this.cache_[key];
                      --this.cacheSize_;
                    }
                  }
                }
              };
              IconImageCache2.prototype.get = function(src, crossOrigin, color) {
                var key = getKey(src, crossOrigin, color);
                return key in this.cache_ ? this.cache_[key] : null;
              };
              IconImageCache2.prototype.set = function(src, crossOrigin, color, iconImage) {
                var key = getKey(src, crossOrigin, color);
                this.cache_[key] = iconImage;
                ++this.cacheSize_;
              };
              IconImageCache2.prototype.setSize = function(maxCacheSize) {
                this.maxCacheSize_ = maxCacheSize;
                this.expire();
              };
              return IconImageCache2;
            }()
          );
          function getKey(src, crossOrigin, color) {
            var colorString = color ? asString(color) : "null";
            return crossOrigin + ":" + src + ":" + colorString;
          }
          var style_IconImageCache = IconImageCache;
          var shared = new IconImageCache();
          var ol_Object = __webpack_require__("e269");
          var Property = {
            OPACITY: "opacity",
            VISIBLE: "visible",
            EXTENT: "extent",
            Z_INDEX: "zIndex",
            MAX_RESOLUTION: "maxResolution",
            MIN_RESOLUTION: "minResolution",
            MAX_ZOOM: "maxZoom",
            MIN_ZOOM: "minZoom",
            SOURCE: "source"
          };
          var ol_obj = __webpack_require__("38f3");
          var Base_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Base_BaseLayer = (
            /** @class */
            function(_super) {
              Base_extends(BaseLayer, _super);
              function BaseLayer(options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var properties = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options);
                if (typeof options.properties === "object") {
                  delete properties.properties;
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(properties, options.properties);
                }
                properties[Property.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
                assert2(typeof properties[Property.OPACITY] === "number", 64);
                properties[Property.VISIBLE] = options.visible !== void 0 ? options.visible : true;
                properties[Property.Z_INDEX] = options.zIndex;
                properties[Property.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
                properties[Property.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
                properties[Property.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
                properties[Property.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
                _this.className_ = properties.className !== void 0 ? options.className : "ol-layer";
                delete properties.className;
                _this.setProperties(properties);
                _this.state_ = null;
                return _this;
              }
              BaseLayer.prototype.getClassName = function() {
                return this.className_;
              };
              BaseLayer.prototype.getLayerState = function(opt_managed) {
                var state = this.state_ || /** @type {?} */
                {
                  layer: this,
                  managed: opt_managed === void 0 ? true : opt_managed
                };
                var zIndex = this.getZIndex();
                state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
                state.sourceState = this.getSourceState();
                state.visible = this.getVisible();
                state.extent = this.getExtent();
                state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
                state.maxResolution = this.getMaxResolution();
                state.minResolution = Math.max(this.getMinResolution(), 0);
                state.minZoom = this.getMinZoom();
                state.maxZoom = this.getMaxZoom();
                this.state_ = state;
                return state;
              };
              BaseLayer.prototype.getLayersArray = function(opt_array) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              BaseLayer.prototype.getLayerStatesArray = function(opt_states) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              BaseLayer.prototype.getExtent = function() {
                return (
                  /** @type {import("../extent.js").Extent|undefined} */
                  this.get(Property.EXTENT)
                );
              };
              BaseLayer.prototype.getMaxResolution = function() {
                return (
                  /** @type {number} */
                  this.get(Property.MAX_RESOLUTION)
                );
              };
              BaseLayer.prototype.getMinResolution = function() {
                return (
                  /** @type {number} */
                  this.get(Property.MIN_RESOLUTION)
                );
              };
              BaseLayer.prototype.getMinZoom = function() {
                return (
                  /** @type {number} */
                  this.get(Property.MIN_ZOOM)
                );
              };
              BaseLayer.prototype.getMaxZoom = function() {
                return (
                  /** @type {number} */
                  this.get(Property.MAX_ZOOM)
                );
              };
              BaseLayer.prototype.getOpacity = function() {
                return (
                  /** @type {number} */
                  this.get(Property.OPACITY)
                );
              };
              BaseLayer.prototype.getSourceState = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              BaseLayer.prototype.getVisible = function() {
                return (
                  /** @type {boolean} */
                  this.get(Property.VISIBLE)
                );
              };
              BaseLayer.prototype.getZIndex = function() {
                return (
                  /** @type {number} */
                  this.get(Property.Z_INDEX)
                );
              };
              BaseLayer.prototype.setExtent = function(extent) {
                this.set(Property.EXTENT, extent);
              };
              BaseLayer.prototype.setMaxResolution = function(maxResolution) {
                this.set(Property.MAX_RESOLUTION, maxResolution);
              };
              BaseLayer.prototype.setMinResolution = function(minResolution) {
                this.set(Property.MIN_RESOLUTION, minResolution);
              };
              BaseLayer.prototype.setMaxZoom = function(maxZoom) {
                this.set(Property.MAX_ZOOM, maxZoom);
              };
              BaseLayer.prototype.setMinZoom = function(minZoom) {
                this.set(Property.MIN_ZOOM, minZoom);
              };
              BaseLayer.prototype.setOpacity = function(opacity) {
                assert2(typeof opacity === "number", 64);
                this.set(Property.OPACITY, opacity);
              };
              BaseLayer.prototype.setVisible = function(visible) {
                this.set(Property.VISIBLE, visible);
              };
              BaseLayer.prototype.setZIndex = function(zindex) {
                this.set(Property.Z_INDEX, zindex);
              };
              BaseLayer.prototype.disposeInternal = function() {
                if (this.state_) {
                  this.state_.layer = null;
                  this.state_ = null;
                }
                _super.prototype.disposeInternal.call(this);
              };
              return BaseLayer;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          var Base = Base_BaseLayer;
          var EventType = __webpack_require__("01d4");
          var render_EventType = {
            /**
             * Triggered before a layer is rendered.
             * @event module:ol/render/Event~RenderEvent#prerender
             * @api
             */
            PRERENDER: "prerender",
            /**
             * Triggered after a layer is rendered.
             * @event module:ol/render/Event~RenderEvent#postrender
             * @api
             */
            POSTRENDER: "postrender",
            /**
             * Triggered before layers are rendered.
             * The event object will not have a `context` set.
             * @event module:ol/render/Event~RenderEvent#precompose
             * @api
             */
            PRECOMPOSE: "precompose",
            /**
             * Triggered after all layers are rendered.
             * The event object will not have a `context` set.
             * @event module:ol/render/Event~RenderEvent#postcompose
             * @api
             */
            POSTCOMPOSE: "postcompose",
            /**
             * Triggered when rendering is complete, i.e. all sources and tiles have
             * finished loading for the current viewport, and all tiles are faded in.
             * The event object will not have a `context` set.
             * @event module:ol/render/Event~RenderEvent#rendercomplete
             * @api
             */
            RENDERCOMPLETE: "rendercomplete"
          };
          var State = {
            UNDEFINED: "undefined",
            LOADING: "loading",
            READY: "ready",
            ERROR: "error"
          };
          var events = __webpack_require__("1e8d");
          var Layer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Layer_Layer = (
            /** @class */
            function(_super) {
              Layer_extends(Layer, _super);
              function Layer(options) {
                var _this = this;
                var baseOptions = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options);
                delete baseOptions.source;
                _this = _super.call(this, baseOptions) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.mapPrecomposeKey_ = null;
                _this.mapRenderKey_ = null;
                _this.sourceChangeKey_ = null;
                _this.renderer_ = null;
                if (options.render) {
                  _this.render = options.render;
                }
                if (options.map) {
                  _this.setMap(options.map);
                }
                _this.addChangeListener(Property.SOURCE, _this.handleSourcePropertyChange_);
                var source = options.source ? (
                  /** @type {SourceType} */
                  options.source
                ) : null;
                _this.setSource(source);
                return _this;
              }
              Layer.prototype.getLayersArray = function(opt_array) {
                var array = opt_array ? opt_array : [];
                array.push(this);
                return array;
              };
              Layer.prototype.getLayerStatesArray = function(opt_states) {
                var states = opt_states ? opt_states : [];
                states.push(this.getLayerState());
                return states;
              };
              Layer.prototype.getSource = function() {
                return (
                  /** @type {SourceType} */
                  this.get(Property.SOURCE) || null
                );
              };
              Layer.prototype.getSourceState = function() {
                var source = this.getSource();
                return !source ? State.UNDEFINED : source.getState();
              };
              Layer.prototype.handleSourceChange_ = function() {
                this.changed();
              };
              Layer.prototype.handleSourcePropertyChange_ = function() {
                if (this.sourceChangeKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.sourceChangeKey_);
                  this.sourceChangeKey_ = null;
                }
                var source = this.getSource();
                if (source) {
                  this.sourceChangeKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(source, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleSourceChange_, this);
                }
                this.changed();
              };
              Layer.prototype.getFeatures = function(pixel) {
                if (!this.renderer_) {
                  return new Promise(function(resolve) {
                    return resolve([]);
                  });
                }
                return this.renderer_.getFeatures(pixel);
              };
              Layer.prototype.render = function(frameState, target) {
                var layerRenderer = this.getRenderer();
                if (layerRenderer.prepareFrame(frameState)) {
                  return layerRenderer.renderFrame(frameState, target);
                }
              };
              Layer.prototype.setMap = function(map) {
                if (this.mapPrecomposeKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.mapPrecomposeKey_);
                  this.mapPrecomposeKey_ = null;
                }
                if (!map) {
                  this.changed();
                }
                if (this.mapRenderKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.mapRenderKey_);
                  this.mapRenderKey_ = null;
                }
                if (map) {
                  this.mapPrecomposeKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(map, render_EventType.PRECOMPOSE, function(evt) {
                    var renderEvent = (
                      /** @type {import("../render/Event.js").default} */
                      evt
                    );
                    var layerStatesArray = renderEvent.frameState.layerStatesArray;
                    var layerState = this.getLayerState(false);
                    assert2(!layerStatesArray.some(function(arrayLayerState) {
                      return arrayLayerState.layer === layerState.layer;
                    }), 67);
                    layerStatesArray.push(layerState);
                  }, this);
                  this.mapRenderKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(this, EventType[
                    "a"
                    /* default */
                  ].CHANGE, map.render, map);
                  this.changed();
                }
              };
              Layer.prototype.setSource = function(source) {
                this.set(Property.SOURCE, source);
              };
              Layer.prototype.getRenderer = function() {
                if (!this.renderer_) {
                  this.renderer_ = this.createRenderer();
                }
                return this.renderer_;
              };
              Layer.prototype.hasRenderer = function() {
                return !!this.renderer_;
              };
              Layer.prototype.createRenderer = function() {
                return null;
              };
              Layer.prototype.disposeInternal = function() {
                this.setSource(null);
                _super.prototype.disposeInternal.call(this);
              };
              return Layer;
            }(Base)
          );
          function inView(layerState, viewState) {
            if (!layerState.visible) {
              return false;
            }
            var resolution = viewState.resolution;
            if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
              return false;
            }
            var zoom = viewState.zoom;
            return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
          }
          var layer_Layer = Layer_Layer;
          function padNumber(number, width, opt_precision) {
            var numberString = opt_precision !== void 0 ? number.toFixed(opt_precision) : "" + number;
            var decimal = numberString.indexOf(".");
            decimal = decimal === -1 ? numberString.length : decimal;
            return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
          }
          function compareVersions(v1, v2) {
            var s1 = ("" + v1).split(".");
            var s2 = ("" + v2).split(".");
            for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
              var n1 = parseInt(s1[i] || "0", 10);
              var n2 = parseInt(s2[i] || "0", 10);
              if (n1 > n2) {
                return 1;
              }
              if (n2 > n1) {
                return -1;
              }
            }
            return 0;
          }
          function coordinate_add(coordinate, delta) {
            coordinate[0] += +delta[0];
            coordinate[1] += +delta[1];
            return coordinate;
          }
          function closestOnCircle(coordinate, circle) {
            var r = circle.getRadius();
            var center = circle.getCenter();
            var x0 = center[0];
            var y0 = center[1];
            var x1 = coordinate[0];
            var y1 = coordinate[1];
            var dx = x1 - x0;
            var dy = y1 - y0;
            if (dx === 0 && dy === 0) {
              dx = 1;
            }
            var d = Math.sqrt(dx * dx + dy * dy);
            var x = x0 + r * dx / d;
            var y = y0 + r * dy / d;
            return [x, y];
          }
          function closestOnSegment(coordinate, segment) {
            var x0 = coordinate[0];
            var y0 = coordinate[1];
            var start = segment[0];
            var end = segment[1];
            var x1 = start[0];
            var y1 = start[1];
            var x2 = end[0];
            var y2 = end[1];
            var dx = x2 - x1;
            var dy = y2 - y1;
            var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
            var x, y;
            if (along <= 0) {
              x = x1;
              y = y1;
            } else if (along >= 1) {
              x = x2;
              y = y2;
            } else {
              x = x1 + along * dx;
              y = y1 + along * dy;
            }
            return [x, y];
          }
          function createStringXY(opt_fractionDigits) {
            return (
              /**
               * @param {Coordinate} coordinate Coordinate.
               * @return {string} String XY.
               */
              function(coordinate) {
                return toStringXY(coordinate, opt_fractionDigits);
              }
            );
          }
          function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
            var normalizedDegrees = modulo(degrees + 180, 360) - 180;
            var x = Math.abs(3600 * normalizedDegrees);
            var dflPrecision = opt_fractionDigits || 0;
            var precision = Math.pow(10, dflPrecision);
            var deg = Math.floor(x / 3600);
            var min = Math.floor((x - deg * 3600) / 60);
            var sec = x - deg * 3600 - min * 60;
            sec = Math.ceil(sec * precision) / precision;
            if (sec >= 60) {
              sec = 0;
              min += 1;
            }
            if (min >= 60) {
              min = 0;
              deg += 1;
            }
            return deg + " " + padNumber(min, 2) + " " + padNumber(sec, 2, dflPrecision) + "" + (normalizedDegrees == 0 ? "" : " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
          }
          function coordinate_format(coordinate, template, opt_fractionDigits) {
            if (coordinate) {
              return template.replace("{x}", coordinate[0].toFixed(opt_fractionDigits)).replace("{y}", coordinate[1].toFixed(opt_fractionDigits));
            } else {
              return "";
            }
          }
          function coordinate_equals(coordinate1, coordinate2) {
            var equals2 = true;
            for (var i = coordinate1.length - 1; i >= 0; --i) {
              if (coordinate1[i] != coordinate2[i]) {
                equals2 = false;
                break;
              }
            }
            return equals2;
          }
          function coordinate_rotate(coordinate, angle) {
            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);
            var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
            var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
            coordinate[0] = x;
            coordinate[1] = y;
            return coordinate;
          }
          function coordinate_scale(coordinate, scale) {
            coordinate[0] *= scale;
            coordinate[1] *= scale;
            return coordinate;
          }
          function coordinate_squaredDistance(coord1, coord2) {
            var dx = coord1[0] - coord2[0];
            var dy = coord1[1] - coord2[1];
            return dx * dx + dy * dy;
          }
          function coordinate_distance(coord1, coord2) {
            return Math.sqrt(coordinate_squaredDistance(coord1, coord2));
          }
          function squaredDistanceToSegment(coordinate, segment) {
            return coordinate_squaredDistance(coordinate, closestOnSegment(coordinate, segment));
          }
          function toStringHDMS(coordinate, opt_fractionDigits) {
            if (coordinate) {
              return degreesToStringHDMS("NS", coordinate[1], opt_fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], opt_fractionDigits);
            } else {
              return "";
            }
          }
          function toStringXY(coordinate, opt_fractionDigits) {
            return coordinate_format(coordinate, "{x}, {y}", opt_fractionDigits);
          }
          function coordinate_wrapX(coordinate, projection) {
            if (projection.canWrapX()) {
              var worldWidth = getWidth(projection.getExtent());
              var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
              if (worldsAway) {
                coordinate[0] -= worldsAway * worldWidth;
              }
            }
            return coordinate;
          }
          function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
            var projectionExtent = projection.getExtent();
            var worldsAway = 0;
            if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
              var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
              worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
            }
            return worldsAway;
          }
          var Map_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Map_MapRenderer = (
            /** @class */
            function(_super) {
              Map_extends(MapRenderer, _super);
              function MapRenderer(map) {
                var _this = _super.call(this) || this;
                _this.map_ = map;
                return _this;
              }
              MapRenderer.prototype.dispatchRenderEvent = function(type, frameState) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              MapRenderer.prototype.calculateMatrices2D = function(frameState) {
                var viewState = frameState.viewState;
                var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
                var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
                compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
                makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
              };
              MapRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
                var result;
                var viewState = frameState.viewState;
                function forEachFeatureAtCoordinate(managed, feature, layer2, geometry) {
                  return callback.call(thisArg, feature, managed ? layer2 : null, geometry);
                }
                var projection = viewState.projection;
                var translatedCoordinate = coordinate_wrapX(coordinate.slice(), projection);
                var offsets = [[0, 0]];
                if (projection.canWrapX() && checkWrapped) {
                  var projectionExtent = projection.getExtent();
                  var worldWidth = getWidth(projectionExtent);
                  offsets.push([-worldWidth, 0], [worldWidth, 0]);
                }
                var layerStates = frameState.layerStatesArray;
                var numLayers = layerStates.length;
                var matches = (
                  /** @type {Array<HitMatch<T>>} */
                  []
                );
                var tmpCoord = [];
                for (var i = 0; i < offsets.length; i++) {
                  for (var j = numLayers - 1; j >= 0; --j) {
                    var layerState = layerStates[j];
                    var layer = layerState.layer;
                    if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                      var layerRenderer = layer.getRenderer();
                      var source = layer.getSource();
                      if (layerRenderer && source) {
                        var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                        var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                        tmpCoord[0] = coordinates[0] + offsets[i][0];
                        tmpCoord[1] = coordinates[1] + offsets[i][1];
                        result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
                      }
                      if (result) {
                        return result;
                      }
                    }
                  }
                }
                if (matches.length === 0) {
                  return void 0;
                }
                var order = 1 / matches.length;
                matches.forEach(function(m, i2) {
                  return m.distanceSq += i2 * order;
                });
                matches.sort(function(a, b) {
                  return a.distanceSq - b.distanceSq;
                });
                matches.some(function(m) {
                  return result = m.callback(m.feature, m.layer, m.geometry);
                });
                return result;
              };
              MapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              MapRenderer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
                var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, functions[
                  "b"
                  /* TRUE */
                ], this, layerFilter, thisArg);
                return hasFeature !== void 0;
              };
              MapRenderer.prototype.getMap = function() {
                return this.map_;
              };
              MapRenderer.prototype.renderFrame = function(frameState) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              MapRenderer.prototype.scheduleExpireIconCache = function(frameState) {
                if (shared.canExpireCache()) {
                  frameState.postRenderFunctions.push(expireIconCache);
                }
              };
              return MapRenderer;
            }(Disposable[
              "a"
              /* default */
            ])
          );
          function expireIconCache(map, frameState) {
            shared.expire();
          }
          var renderer_Map = Map_MapRenderer;
          var ObjectEventType = __webpack_require__("7b4f");
          var Event = __webpack_require__("cef7");
          var Event_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var RenderEvent = (
            /** @class */
            function(_super) {
              Event_extends(RenderEvent2, _super);
              function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {
                var _this = _super.call(this, type) || this;
                _this.inversePixelTransform = opt_inversePixelTransform;
                _this.frameState = opt_frameState;
                _this.context = opt_context;
                return _this;
              }
              return RenderEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var render_Event = RenderEvent;
          var CLASS_HIDDEN = "ol-hidden";
          var CLASS_SELECTABLE = "ol-selectable";
          var CLASS_UNSELECTABLE = "ol-unselectable";
          var CLASS_UNSUPPORTED = "ol-unsupported";
          var CLASS_CONTROL = "ol-control";
          var CLASS_COLLAPSED = "ol-collapsed";
          var fontRegEx = new RegExp([
            "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
            "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
            "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
            "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
            "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
            "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
            `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
          ].join(""), "i");
          var fontRegExMatchIndex = [
            "style",
            "variant",
            "weight",
            "size",
            "lineHeight",
            "family"
          ];
          var getFontParameters = function(fontSpec) {
            var match = fontSpec.match(fontRegEx);
            if (!match) {
              return null;
            }
            var style = (
              /** @type {FontParameters} */
              {
                lineHeight: "normal",
                size: "1.2em",
                style: "normal",
                weight: "normal",
                variant: "normal"
              }
            );
            for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
              var value = match[i + 1];
              if (value !== void 0) {
                style[fontRegExMatchIndex[i]] = value;
              }
            }
            style.families = style.family.split(/,\s?/);
            return style;
          };
          var Target = __webpack_require__("0ec0");
          var dom = __webpack_require__("0999");
          var defaultFont = "10px sans-serif";
          var defaultFillStyle = "#000";
          var defaultLineCap = "round";
          var defaultLineDash = [];
          var defaultLineDashOffset = 0;
          var defaultLineJoin = "round";
          var defaultMiterLimit = 10;
          var defaultStrokeStyle = "#000";
          var defaultTextAlign = "center";
          var defaultTextBaseline = "middle";
          var defaultPadding = [0, 0, 0, 0];
          var defaultLineWidth = 1;
          var checkedFonts = new ol_Object[
            "a"
            /* default */
          ]();
          var labelCache = new Target[
            "a"
            /* default */
          ]();
          labelCache.setSize = function() {
            console.warn("labelCache is deprecated.");
          };
          var measureContext = null;
          var measureFont;
          var textHeights = {};
          var registerFont = function() {
            var retries = 100;
            var size = "32px ";
            var referenceFonts = ["monospace", "serif"];
            var len = referenceFonts.length;
            var text = "wmytzilWMYTZIL@#/&?$%10";
            var interval, referenceWidth;
            function isAvailable(fontStyle, fontWeight, fontFamily) {
              var available = true;
              for (var i = 0; i < len; ++i) {
                var referenceFont = referenceFonts[i];
                referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
                if (fontFamily != referenceFont) {
                  var width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
                  available = available && width != referenceWidth;
                }
              }
              if (available) {
                return true;
              }
              return false;
            }
            function check() {
              var done = true;
              var fonts = checkedFonts.getKeys();
              for (var i = 0, ii = fonts.length; i < ii; ++i) {
                var font = fonts[i];
                if (checkedFonts.get(font) < retries) {
                  if (isAvailable.apply(this, font.split("\n"))) {
                    Object(ol_obj[
                      "b"
                      /* clear */
                    ])(textHeights);
                    measureContext = null;
                    measureFont = void 0;
                    checkedFonts.set(font, retries);
                  } else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                  }
                }
              }
              if (done) {
                clearInterval(interval);
                interval = void 0;
              }
            }
            return function(fontSpec) {
              var font = getFontParameters(fontSpec);
              if (!font) {
                return;
              }
              var families = font.families;
              for (var i = 0, ii = families.length; i < ii; ++i) {
                var family = families[i];
                var key = font.style + "\n" + font.weight + "\n" + family;
                if (checkedFonts.get(key) === void 0) {
                  checkedFonts.set(key, retries, true);
                  if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === void 0) {
                      interval = setInterval(check, 32);
                    }
                  }
                }
              }
            };
          }();
          var measureTextHeight = /* @__PURE__ */ function() {
            var measureElement;
            return function(fontSpec) {
              var height = textHeights[fontSpec];
              if (height == void 0) {
                if (has[
                  "g"
                  /* WORKER_OFFSCREEN_CANVAS */
                ]) {
                  var font = getFontParameters(fontSpec);
                  var metrics = measureText(fontSpec, "g");
                  var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                  height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
                } else {
                  if (!measureElement) {
                    measureElement = document.createElement("div");
                    measureElement.innerHTML = "M";
                    measureElement.style.minHeight = "0";
                    measureElement.style.maxHeight = "none";
                    measureElement.style.height = "auto";
                    measureElement.style.padding = "0";
                    measureElement.style.border = "none";
                    measureElement.style.position = "absolute";
                    measureElement.style.display = "block";
                    measureElement.style.left = "-99999px";
                  }
                  measureElement.style.font = fontSpec;
                  document.body.appendChild(measureElement);
                  height = measureElement.offsetHeight;
                  document.body.removeChild(measureElement);
                }
                textHeights[fontSpec] = height;
              }
              return height;
            };
          }();
          function measureText(font, text) {
            if (!measureContext) {
              measureContext = Object(dom[
                "a"
                /* createCanvasContext2D */
              ])(1, 1);
            }
            if (font != measureFont) {
              measureContext.font = font;
              measureFont = measureContext.font;
            }
            return measureContext.measureText(text);
          }
          function measureTextWidth(font, text) {
            return measureText(font, text).width;
          }
          function canvas_measureAndCacheTextWidth(font, text, cache) {
            if (text in cache) {
              return cache[text];
            }
            var width = measureTextWidth(font, text);
            cache[text] = width;
            return width;
          }
          function measureTextWidths(font, lines, widths) {
            var numLines = lines.length;
            var width = 0;
            for (var i = 0; i < numLines; ++i) {
              var currentWidth = measureTextWidth(font, lines[i]);
              width = Math.max(width, currentWidth);
              widths.push(currentWidth);
            }
            return width;
          }
          function rotateAtOffset(context, rotation, offsetX, offsetY) {
            if (rotation !== 0) {
              context.translate(offsetX, offsetY);
              context.rotate(rotation);
              context.translate(-offsetX, -offsetY);
            }
          }
          function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
            context.save();
            if (opacity !== 1) {
              context.globalAlpha *= opacity;
            }
            if (transform2) {
              context.setTransform.apply(context, transform2);
            }
            if (
              /** @type {*} */
              labelOrImage.contextInstructions
            ) {
              context.translate(x, y);
              context.scale(scale[0], scale[1]);
              executeLabelInstructions(
                /** @type {Label} */
                labelOrImage,
                context
              );
            } else if (scale[0] < 0 || scale[1] < 0) {
              context.translate(x, y);
              context.scale(scale[0], scale[1]);
              context.drawImage(
                /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
                labelOrImage,
                originX,
                originY,
                w,
                h,
                0,
                0,
                w,
                h
              );
            } else {
              context.drawImage(
                /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
                labelOrImage,
                originX,
                originY,
                w,
                h,
                x,
                y,
                w * scale[0],
                h * scale[1]
              );
            }
            context.restore();
          }
          function executeLabelInstructions(label, context) {
            var contextInstructions = label.contextInstructions;
            for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
              if (Array.isArray(contextInstructions[i + 1])) {
                context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
              } else {
                context[contextInstructions[i]] = contextInstructions[i + 1];
              }
            }
          }
          var Composite_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Composite_CompositeMapRenderer = (
            /** @class */
            function(_super) {
              Composite_extends(CompositeMapRenderer, _super);
              function CompositeMapRenderer(map) {
                var _this = _super.call(this, map) || this;
                _this.fontChangeListenerKey_ = Object(events[
                  "a"
                  /* listen */
                ])(checkedFonts, ObjectEventType[
                  "a"
                  /* default */
                ].PROPERTYCHANGE, map.redrawText.bind(map));
                _this.element_ = document.createElement("div");
                var style = _this.element_.style;
                style.position = "absolute";
                style.width = "100%";
                style.height = "100%";
                style.zIndex = "0";
                _this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
                var container = map.getViewport();
                container.insertBefore(_this.element_, container.firstChild || null);
                _this.children_ = [];
                _this.renderedVisible_ = true;
                return _this;
              }
              CompositeMapRenderer.prototype.dispatchRenderEvent = function(type, frameState) {
                var map = this.getMap();
                if (map.hasListener(type)) {
                  var event_1 = new render_Event(type, void 0, frameState);
                  map.dispatchEvent(event_1);
                }
              };
              CompositeMapRenderer.prototype.disposeInternal = function() {
                Object(events[
                  "c"
                  /* unlistenByKey */
                ])(this.fontChangeListenerKey_);
                this.element_.parentNode.removeChild(this.element_);
                _super.prototype.disposeInternal.call(this);
              };
              CompositeMapRenderer.prototype.renderFrame = function(frameState) {
                if (!frameState) {
                  if (this.renderedVisible_) {
                    this.element_.style.display = "none";
                    this.renderedVisible_ = false;
                  }
                  return;
                }
                this.calculateMatrices2D(frameState);
                this.dispatchRenderEvent(render_EventType.PRECOMPOSE, frameState);
                var layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
                  return a.zIndex - b.zIndex;
                });
                var viewState = frameState.viewState;
                this.children_.length = 0;
                var declutterLayers = [];
                var previousElement = null;
                for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                  var layerState = layerStatesArray[i];
                  frameState.layerIndex = i;
                  if (!inView(layerState, viewState) || layerState.sourceState != State.READY && layerState.sourceState != State.UNDEFINED) {
                    continue;
                  }
                  var layer = layerState.layer;
                  var element = layer.render(frameState, previousElement);
                  if (!element) {
                    continue;
                  }
                  if (element !== previousElement) {
                    this.children_.push(element);
                    previousElement = element;
                  }
                  if ("getDeclutter" in layer) {
                    declutterLayers.push(
                      /** @type {import("../layer/BaseVector.js").default} */
                      layer
                    );
                  }
                }
                for (var i = declutterLayers.length - 1; i >= 0; --i) {
                  declutterLayers[i].renderDeclutter(frameState);
                }
                Object(dom[
                  "f"
                  /* replaceChildren */
                ])(this.element_, this.children_);
                this.dispatchRenderEvent(render_EventType.POSTCOMPOSE, frameState);
                if (!this.renderedVisible_) {
                  this.element_.style.display = "";
                  this.renderedVisible_ = true;
                }
                this.scheduleExpireIconCache(frameState);
              };
              CompositeMapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
                var viewState = frameState.viewState;
                var layerStates = frameState.layerStatesArray;
                var numLayers = layerStates.length;
                for (var i = numLayers - 1; i >= 0; --i) {
                  var layerState = layerStates[i];
                  var layer = layerState.layer;
                  if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter(layer)) {
                    var layerRenderer = layer.getRenderer();
                    var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                    if (data) {
                      var result = callback(layer, data);
                      if (result) {
                        return result;
                      }
                    }
                  }
                }
                return void 0;
              };
              return CompositeMapRenderer;
            }(renderer_Map)
          );
          var Composite = Composite_CompositeMapRenderer;
          var CollectionEventType = {
            /**
             * Triggered when an item is added to the collection.
             * @event module:ol/Collection.CollectionEvent#add
             * @api
             */
            ADD: "add",
            /**
             * Triggered when an item is removed from the collection.
             * @event module:ol/Collection.CollectionEvent#remove
             * @api
             */
            REMOVE: "remove"
          };
          var Collection_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Collection_Property = {
            LENGTH: "length"
          };
          var CollectionEvent = (
            /** @class */
            function(_super) {
              Collection_extends(CollectionEvent2, _super);
              function CollectionEvent2(type, opt_element, opt_index) {
                var _this = _super.call(this, type) || this;
                _this.element = opt_element;
                _this.index = opt_index;
                return _this;
              }
              return CollectionEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Collection_Collection = (
            /** @class */
            function(_super) {
              Collection_extends(Collection, _super);
              function Collection(opt_array, opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var options = opt_options || {};
                _this.unique_ = !!options.unique;
                _this.array_ = opt_array ? opt_array : [];
                if (_this.unique_) {
                  for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                    _this.assertUnique_(_this.array_[i], i);
                  }
                }
                _this.updateLength_();
                return _this;
              }
              Collection.prototype.clear = function() {
                while (this.getLength() > 0) {
                  this.pop();
                }
              };
              Collection.prototype.extend = function(arr) {
                for (var i = 0, ii = arr.length; i < ii; ++i) {
                  this.push(arr[i]);
                }
                return this;
              };
              Collection.prototype.forEach = function(f) {
                var array = this.array_;
                for (var i = 0, ii = array.length; i < ii; ++i) {
                  f(array[i], i, array);
                }
              };
              Collection.prototype.getArray = function() {
                return this.array_;
              };
              Collection.prototype.item = function(index) {
                return this.array_[index];
              };
              Collection.prototype.getLength = function() {
                return this.get(Collection_Property.LENGTH);
              };
              Collection.prototype.insertAt = function(index, elem) {
                if (this.unique_) {
                  this.assertUnique_(elem);
                }
                this.array_.splice(index, 0, elem);
                this.updateLength_();
                this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
              };
              Collection.prototype.pop = function() {
                return this.removeAt(this.getLength() - 1);
              };
              Collection.prototype.push = function(elem) {
                if (this.unique_) {
                  this.assertUnique_(elem);
                }
                var n = this.getLength();
                this.insertAt(n, elem);
                return this.getLength();
              };
              Collection.prototype.remove = function(elem) {
                var arr = this.array_;
                for (var i = 0, ii = arr.length; i < ii; ++i) {
                  if (arr[i] === elem) {
                    return this.removeAt(i);
                  }
                }
                return void 0;
              };
              Collection.prototype.removeAt = function(index) {
                var prev = this.array_[index];
                this.array_.splice(index, 1);
                this.updateLength_();
                this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
                return prev;
              };
              Collection.prototype.setAt = function(index, elem) {
                var n = this.getLength();
                if (index < n) {
                  if (this.unique_) {
                    this.assertUnique_(elem, index);
                  }
                  var prev = this.array_[index];
                  this.array_[index] = elem;
                  this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
                  this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
                } else {
                  for (var j = n; j < index; ++j) {
                    this.insertAt(j, void 0);
                  }
                  this.insertAt(index, elem);
                }
              };
              Collection.prototype.updateLength_ = function() {
                this.set(Collection_Property.LENGTH, this.array_.length);
              };
              Collection.prototype.assertUnique_ = function(elem, opt_except) {
                for (var i = 0, ii = this.array_.length; i < ii; ++i) {
                  if (this.array_[i] === elem && i !== opt_except) {
                    throw new ol_AssertionError(58);
                  }
                }
              };
              return Collection;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          var ol_Collection = Collection_Collection;
          var Group_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Group_Property = {
            LAYERS: "layers"
          };
          var Group_LayerGroup = (
            /** @class */
            function(_super) {
              Group_extends(LayerGroup, _super);
              function LayerGroup(opt_options) {
                var _this = this;
                var options = opt_options || {};
                var baseOptions = (
                  /** @type {Options} */
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])({}, options)
                );
                delete baseOptions.layers;
                var layers = options.layers;
                _this = _super.call(this, baseOptions) || this;
                _this.layersListenerKeys_ = [];
                _this.listenerKeys_ = {};
                _this.addChangeListener(Group_Property.LAYERS, _this.handleLayersChanged_);
                if (layers) {
                  if (Array.isArray(layers)) {
                    layers = new ol_Collection(layers.slice(), { unique: true });
                  } else {
                    assert2(typeof /** @type {?} */
                    layers.getArray === "function", 43);
                  }
                } else {
                  layers = new ol_Collection(void 0, { unique: true });
                }
                _this.setLayers(layers);
                return _this;
              }
              LayerGroup.prototype.handleLayerChange_ = function() {
                this.changed();
              };
              LayerGroup.prototype.handleLayersChanged_ = function() {
                this.layersListenerKeys_.forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                this.layersListenerKeys_.length = 0;
                var layers = this.getLayers();
                this.layersListenerKeys_.push(Object(events[
                  "a"
                  /* listen */
                ])(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), Object(events[
                  "a"
                  /* listen */
                ])(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
                for (var id in this.listenerKeys_) {
                  this.listenerKeys_[id].forEach(events[
                    "c"
                    /* unlistenByKey */
                  ]);
                }
                Object(ol_obj[
                  "b"
                  /* clear */
                ])(this.listenerKeys_);
                var layersArray = layers.getArray();
                for (var i = 0, ii = layersArray.length; i < ii; i++) {
                  var layer = layersArray[i];
                  this.listenerKeys_[Object(util[
                    "c"
                    /* getUid */
                  ])(layer)] = [
                    Object(events[
                      "a"
                      /* listen */
                    ])(layer, ObjectEventType[
                      "a"
                      /* default */
                    ].PROPERTYCHANGE, this.handleLayerChange_, this),
                    Object(events[
                      "a"
                      /* listen */
                    ])(layer, EventType[
                      "a"
                      /* default */
                    ].CHANGE, this.handleLayerChange_, this)
                  ];
                }
                this.changed();
              };
              LayerGroup.prototype.handleLayersAdd_ = function(collectionEvent) {
                var layer = (
                  /** @type {import("./Base.js").default} */
                  collectionEvent.element
                );
                this.listenerKeys_[Object(util[
                  "c"
                  /* getUid */
                ])(layer)] = [
                  Object(events[
                    "a"
                    /* listen */
                  ])(layer, ObjectEventType[
                    "a"
                    /* default */
                  ].PROPERTYCHANGE, this.handleLayerChange_, this),
                  Object(events[
                    "a"
                    /* listen */
                  ])(layer, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleLayerChange_, this)
                ];
                this.changed();
              };
              LayerGroup.prototype.handleLayersRemove_ = function(collectionEvent) {
                var layer = (
                  /** @type {import("./Base.js").default} */
                  collectionEvent.element
                );
                var key = Object(util[
                  "c"
                  /* getUid */
                ])(layer);
                this.listenerKeys_[key].forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                delete this.listenerKeys_[key];
                this.changed();
              };
              LayerGroup.prototype.getLayers = function() {
                return (
                  /** @type {!import("../Collection.js").default<import("./Base.js").default>} */
                  this.get(Group_Property.LAYERS)
                );
              };
              LayerGroup.prototype.setLayers = function(layers) {
                this.set(Group_Property.LAYERS, layers);
              };
              LayerGroup.prototype.getLayersArray = function(opt_array) {
                var array = opt_array !== void 0 ? opt_array : [];
                this.getLayers().forEach(function(layer) {
                  layer.getLayersArray(array);
                });
                return array;
              };
              LayerGroup.prototype.getLayerStatesArray = function(opt_states) {
                var states = opt_states !== void 0 ? opt_states : [];
                var pos = states.length;
                this.getLayers().forEach(function(layer) {
                  layer.getLayerStatesArray(states);
                });
                var ownLayerState = this.getLayerState();
                var defaultZIndex = ownLayerState.zIndex;
                if (!opt_states && ownLayerState.zIndex === void 0) {
                  defaultZIndex = 0;
                }
                for (var i = pos, ii = states.length; i < ii; i++) {
                  var layerState = states[i];
                  layerState.opacity *= ownLayerState.opacity;
                  layerState.visible = layerState.visible && ownLayerState.visible;
                  layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
                  layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
                  layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
                  layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
                  if (ownLayerState.extent !== void 0) {
                    if (layerState.extent !== void 0) {
                      layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                    } else {
                      layerState.extent = ownLayerState.extent;
                    }
                  }
                  if (layerState.zIndex === void 0) {
                    layerState.zIndex = defaultZIndex;
                  }
                }
                return states;
              };
              LayerGroup.prototype.getSourceState = function() {
                return State.READY;
              };
              return LayerGroup;
            }(Base)
          );
          var Group = Group_LayerGroup;
          var MapEvent_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MapEvent = (
            /** @class */
            function(_super) {
              MapEvent_extends(MapEvent2, _super);
              function MapEvent2(type, map, opt_frameState) {
                var _this = _super.call(this, type) || this;
                _this.map = map;
                _this.frameState = opt_frameState !== void 0 ? opt_frameState : null;
                return _this;
              }
              return MapEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var ol_MapEvent = MapEvent;
          var MapBrowserEvent_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MapBrowserEvent = (
            /** @class */
            function(_super) {
              MapBrowserEvent_extends(MapBrowserEvent2, _super);
              function MapBrowserEvent2(type, map, originalEvent, opt_dragging, opt_frameState) {
                var _this = _super.call(this, type, map, opt_frameState) || this;
                _this.originalEvent = originalEvent;
                _this.pixel_ = null;
                _this.coordinate_ = null;
                _this.dragging = opt_dragging !== void 0 ? opt_dragging : false;
                return _this;
              }
              Object.defineProperty(MapBrowserEvent2.prototype, "pixel", {
                /**
                 * The map pixel relative to the viewport corresponding to the original event.
                 * @type {import("./pixel.js").Pixel}
                 * @api
                 */
                get: function() {
                  if (!this.pixel_) {
                    this.pixel_ = this.map.getEventPixel(this.originalEvent);
                  }
                  return this.pixel_;
                },
                set: function(pixel) {
                  this.pixel_ = pixel;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(MapBrowserEvent2.prototype, "coordinate", {
                /**
                 * The coordinate corresponding to the original browser event.  This will be in the user
                 * projection if one is set.  Otherwise it will be in the view projection.
                 * @type {import("./coordinate.js").Coordinate}
                 * @api
                 */
                get: function() {
                  if (!this.coordinate_) {
                    this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
                  }
                  return this.coordinate_;
                },
                set: function(coordinate) {
                  this.coordinate_ = coordinate;
                },
                enumerable: false,
                configurable: true
              });
              MapBrowserEvent2.prototype.preventDefault = function() {
                _super.prototype.preventDefault.call(this);
                if ("preventDefault" in this.originalEvent) {
                  this.originalEvent.preventDefault();
                }
              };
              MapBrowserEvent2.prototype.stopPropagation = function() {
                _super.prototype.stopPropagation.call(this);
                if ("stopPropagation" in this.originalEvent) {
                  this.originalEvent.stopPropagation();
                }
              };
              return MapBrowserEvent2;
            }(ol_MapEvent)
          );
          var ol_MapBrowserEvent = MapBrowserEvent;
          var MapBrowserEventType = {
            /**
             * A true single click with no dragging and no double click. Note that this
             * event is delayed by 250 ms to ensure that it is not a double click.
             * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
             * @api
             */
            SINGLECLICK: "singleclick",
            /**
             * A click with no dragging. A double click will fire two of this.
             * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
             * @api
             */
            CLICK: EventType[
              "a"
              /* default */
            ].CLICK,
            /**
             * A true double click, with no dragging.
             * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
             * @api
             */
            DBLCLICK: EventType[
              "a"
              /* default */
            ].DBLCLICK,
            /**
             * Triggered when a pointer is dragged.
             * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
             * @api
             */
            POINTERDRAG: "pointerdrag",
            /**
             * Triggered when a pointer is moved. Note that on touch devices this is
             * triggered when the map is panned, so is not the same as mousemove.
             * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
             * @api
             */
            POINTERMOVE: "pointermove",
            POINTERDOWN: "pointerdown",
            POINTERUP: "pointerup",
            POINTEROVER: "pointerover",
            POINTEROUT: "pointerout",
            POINTERENTER: "pointerenter",
            POINTERLEAVE: "pointerleave",
            POINTERCANCEL: "pointercancel"
          };
          var pointer_EventType = {
            POINTERMOVE: "pointermove",
            POINTERDOWN: "pointerdown",
            POINTERUP: "pointerup",
            POINTEROVER: "pointerover",
            POINTEROUT: "pointerout",
            POINTERENTER: "pointerenter",
            POINTERLEAVE: "pointerleave",
            POINTERCANCEL: "pointercancel"
          };
          var MapBrowserEventHandler_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MapBrowserEventHandler_MapBrowserEventHandler = (
            /** @class */
            function(_super) {
              MapBrowserEventHandler_extends(MapBrowserEventHandler, _super);
              function MapBrowserEventHandler(map, moveTolerance) {
                var _this = _super.call(this, map) || this;
                _this.map_ = map;
                _this.clickTimeoutId_;
                _this.emulateClicks_ = false;
                _this.dragging_ = false;
                _this.dragListenerKeys_ = [];
                _this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
                _this.down_ = null;
                var element = _this.map_.getViewport();
                _this.activePointers_ = 0;
                _this.trackedTouches_ = {};
                _this.element_ = element;
                _this.pointerdownListenerKey_ = Object(events[
                  "a"
                  /* listen */
                ])(element, pointer_EventType.POINTERDOWN, _this.handlePointerDown_, _this);
                _this.originalPointerMoveEvent_;
                _this.relayedListenerKey_ = Object(events[
                  "a"
                  /* listen */
                ])(element, pointer_EventType.POINTERMOVE, _this.relayEvent_, _this);
                _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
                _this.element_.addEventListener(EventType[
                  "a"
                  /* default */
                ].TOUCHMOVE, _this.boundHandleTouchMove_, has[
                  "e"
                  /* PASSIVE_EVENT_LISTENERS */
                ] ? { passive: false } : false);
                return _this;
              }
              MapBrowserEventHandler.prototype.emulateClick_ = function(pointerEvent) {
                var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
                if (this.clickTimeoutId_ !== void 0) {
                  clearTimeout(this.clickTimeoutId_);
                  this.clickTimeoutId_ = void 0;
                  newEvent = new ol_MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
                  this.dispatchEvent(newEvent);
                } else {
                  this.clickTimeoutId_ = setTimeout(
                    /** @this {MapBrowserEventHandler} */
                    (function() {
                      this.clickTimeoutId_ = void 0;
                      var newEvent2 = new ol_MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                      this.dispatchEvent(newEvent2);
                    }).bind(this),
                    250
                  );
                }
              };
              MapBrowserEventHandler.prototype.updateActivePointers_ = function(pointerEvent) {
                var event = pointerEvent;
                if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
                  delete this.trackedTouches_[event.pointerId];
                } else if (event.type == MapBrowserEventType.POINTERDOWN) {
                  this.trackedTouches_[event.pointerId] = true;
                }
                this.activePointers_ = Object.keys(this.trackedTouches_).length;
              };
              MapBrowserEventHandler.prototype.handlePointerUp_ = function(pointerEvent) {
                this.updateActivePointers_(pointerEvent);
                var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
                if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
                  this.emulateClick_(this.down_);
                }
                if (this.activePointers_ === 0) {
                  this.dragListenerKeys_.forEach(events[
                    "c"
                    /* unlistenByKey */
                  ]);
                  this.dragListenerKeys_.length = 0;
                  this.dragging_ = false;
                  this.down_ = null;
                }
              };
              MapBrowserEventHandler.prototype.isMouseActionButton_ = function(pointerEvent) {
                return pointerEvent.button === 0;
              };
              MapBrowserEventHandler.prototype.handlePointerDown_ = function(pointerEvent) {
                this.emulateClicks_ = this.activePointers_ === 0;
                this.updateActivePointers_(pointerEvent);
                var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
                this.down_ = /** @type {PointerEvent} */
                {};
                for (var property in pointerEvent) {
                  var value = pointerEvent[property];
                  this.down_[property] = typeof value === "function" ? functions[
                    "c"
                    /* VOID */
                  ] : value;
                }
                if (this.dragListenerKeys_.length === 0) {
                  var doc = this.map_.getOwnerDocument();
                  this.dragListenerKeys_.push(
                    Object(events[
                      "a"
                      /* listen */
                    ])(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this),
                    Object(events[
                      "a"
                      /* listen */
                    ])(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),
                    /* Note that the listener for `pointercancel is set up on
                     * `pointerEventHandler_` and not `documentPointerEventHandler_` like
                     * the `pointerup` and `pointermove` listeners.
                     *
                     * The reason for this is the following: `TouchSource.vacuumTouches_()`
                     * issues `pointercancel` events, when there was no `touchend` for a
                     * `touchstart`. Now, let's say a first `touchstart` is registered on
                     * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
                     * But `documentPointerEventHandler_` doesn't know about the first
                     * `touchstart`. If there is no `touchend` for the `touchstart`, we can
                     * only receive a `touchcancel` from `pointerEventHandler_`, because it is
                     * only registered there.
                     */
                    Object(events[
                      "a"
                      /* listen */
                    ])(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this)
                  );
                  if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
                    this.dragListenerKeys_.push(Object(events[
                      "a"
                      /* listen */
                    ])(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
                  }
                }
              };
              MapBrowserEventHandler.prototype.handlePointerMove_ = function(pointerEvent) {
                if (this.isMoving_(pointerEvent)) {
                  this.dragging_ = true;
                  var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
                  this.dispatchEvent(newEvent);
                }
              };
              MapBrowserEventHandler.prototype.relayEvent_ = function(pointerEvent) {
                this.originalPointerMoveEvent_ = pointerEvent;
                var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
                this.dispatchEvent(new ol_MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
              };
              MapBrowserEventHandler.prototype.handleTouchMove_ = function(event) {
                var originalEvent = this.originalPointerMoveEvent_;
                if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
                  event.preventDefault();
                }
              };
              MapBrowserEventHandler.prototype.isMoving_ = function(pointerEvent) {
                return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
              };
              MapBrowserEventHandler.prototype.disposeInternal = function() {
                if (this.relayedListenerKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.relayedListenerKey_);
                  this.relayedListenerKey_ = null;
                }
                this.element_.removeEventListener(EventType[
                  "a"
                  /* default */
                ].TOUCHMOVE, this.boundHandleTouchMove_);
                if (this.pointerdownListenerKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.pointerdownListenerKey_);
                  this.pointerdownListenerKey_ = null;
                }
                this.dragListenerKeys_.forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                this.dragListenerKeys_.length = 0;
                this.element_ = null;
                _super.prototype.disposeInternal.call(this);
              };
              return MapBrowserEventHandler;
            }(Target[
              "a"
              /* default */
            ])
          );
          var ol_MapBrowserEventHandler = MapBrowserEventHandler_MapBrowserEventHandler;
          var MapEventType = __webpack_require__("592d");
          var MapProperty = {
            LAYERGROUP: "layergroup",
            SIZE: "size",
            TARGET: "target",
            VIEW: "view"
          };
          var DROP = Infinity;
          var PriorityQueue_PriorityQueue = (
            /** @class */
            function() {
              function PriorityQueue(priorityFunction, keyFunction) {
                this.priorityFunction_ = priorityFunction;
                this.keyFunction_ = keyFunction;
                this.elements_ = [];
                this.priorities_ = [];
                this.queuedElements_ = {};
              }
              PriorityQueue.prototype.clear = function() {
                this.elements_.length = 0;
                this.priorities_.length = 0;
                Object(ol_obj[
                  "b"
                  /* clear */
                ])(this.queuedElements_);
              };
              PriorityQueue.prototype.dequeue = function() {
                var elements = this.elements_;
                var priorities = this.priorities_;
                var element = elements[0];
                if (elements.length == 1) {
                  elements.length = 0;
                  priorities.length = 0;
                } else {
                  elements[0] = elements.pop();
                  priorities[0] = priorities.pop();
                  this.siftUp_(0);
                }
                var elementKey = this.keyFunction_(element);
                delete this.queuedElements_[elementKey];
                return element;
              };
              PriorityQueue.prototype.enqueue = function(element) {
                assert2(!(this.keyFunction_(element) in this.queuedElements_), 31);
                var priority = this.priorityFunction_(element);
                if (priority != DROP) {
                  this.elements_.push(element);
                  this.priorities_.push(priority);
                  this.queuedElements_[this.keyFunction_(element)] = true;
                  this.siftDown_(0, this.elements_.length - 1);
                  return true;
                }
                return false;
              };
              PriorityQueue.prototype.getCount = function() {
                return this.elements_.length;
              };
              PriorityQueue.prototype.getLeftChildIndex_ = function(index) {
                return index * 2 + 1;
              };
              PriorityQueue.prototype.getRightChildIndex_ = function(index) {
                return index * 2 + 2;
              };
              PriorityQueue.prototype.getParentIndex_ = function(index) {
                return index - 1 >> 1;
              };
              PriorityQueue.prototype.heapify_ = function() {
                var i;
                for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
                  this.siftUp_(i);
                }
              };
              PriorityQueue.prototype.isEmpty = function() {
                return this.elements_.length === 0;
              };
              PriorityQueue.prototype.isKeyQueued = function(key) {
                return key in this.queuedElements_;
              };
              PriorityQueue.prototype.isQueued = function(element) {
                return this.isKeyQueued(this.keyFunction_(element));
              };
              PriorityQueue.prototype.siftUp_ = function(index) {
                var elements = this.elements_;
                var priorities = this.priorities_;
                var count = elements.length;
                var element = elements[index];
                var priority = priorities[index];
                var startIndex = index;
                while (index < count >> 1) {
                  var lIndex = this.getLeftChildIndex_(index);
                  var rIndex = this.getRightChildIndex_(index);
                  var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
                  elements[index] = elements[smallerChildIndex];
                  priorities[index] = priorities[smallerChildIndex];
                  index = smallerChildIndex;
                }
                elements[index] = element;
                priorities[index] = priority;
                this.siftDown_(startIndex, index);
              };
              PriorityQueue.prototype.siftDown_ = function(startIndex, index) {
                var elements = this.elements_;
                var priorities = this.priorities_;
                var element = elements[index];
                var priority = priorities[index];
                while (index > startIndex) {
                  var parentIndex = this.getParentIndex_(index);
                  if (priorities[parentIndex] > priority) {
                    elements[index] = elements[parentIndex];
                    priorities[index] = priorities[parentIndex];
                    index = parentIndex;
                  } else {
                    break;
                  }
                }
                elements[index] = element;
                priorities[index] = priority;
              };
              PriorityQueue.prototype.reprioritize = function() {
                var priorityFunction = this.priorityFunction_;
                var elements = this.elements_;
                var priorities = this.priorities_;
                var index = 0;
                var n = elements.length;
                var element, i, priority;
                for (i = 0; i < n; ++i) {
                  element = elements[i];
                  priority = priorityFunction(element);
                  if (priority == DROP) {
                    delete this.queuedElements_[this.keyFunction_(element)];
                  } else {
                    priorities[index] = priority;
                    elements[index++] = element;
                  }
                }
                elements.length = index;
                priorities.length = index;
                this.heapify_();
              };
              return PriorityQueue;
            }()
          );
          var structs_PriorityQueue = PriorityQueue_PriorityQueue;
          var TileState = {
            IDLE: 0,
            LOADING: 1,
            LOADED: 2,
            /**
             * Indicates that tile loading failed
             * @type {number}
             */
            ERROR: 3,
            EMPTY: 4
          };
          var TileQueue_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TileQueue_TileQueue = (
            /** @class */
            function(_super) {
              TileQueue_extends(TileQueue, _super);
              function TileQueue(tilePriorityFunction, tileChangeCallback) {
                var _this = _super.call(
                  this,
                  /**
                   * @param {Array} element Element.
                   * @return {number} Priority.
                   */
                  function(element) {
                    return tilePriorityFunction.apply(null, element);
                  },
                  /**
                   * @param {Array} element Element.
                   * @return {string} Key.
                   */
                  function(element) {
                    return (
                      /** @type {import("./Tile.js").default} */
                      element[0].getKey()
                    );
                  }
                ) || this;
                _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
                _this.tileChangeCallback_ = tileChangeCallback;
                _this.tilesLoading_ = 0;
                _this.tilesLoadingKeys_ = {};
                return _this;
              }
              TileQueue.prototype.enqueue = function(element) {
                var added = _super.prototype.enqueue.call(this, element);
                if (added) {
                  var tile = element[0];
                  tile.addEventListener(EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.boundHandleTileChange_);
                }
                return added;
              };
              TileQueue.prototype.getTilesLoading = function() {
                return this.tilesLoading_;
              };
              TileQueue.prototype.handleTileChange = function(event) {
                var tile = (
                  /** @type {import("./Tile.js").default} */
                  event.target
                );
                var state = tile.getState();
                if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
                  tile.removeEventListener(EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.boundHandleTileChange_);
                  var tileKey = tile.getKey();
                  if (tileKey in this.tilesLoadingKeys_) {
                    delete this.tilesLoadingKeys_[tileKey];
                    --this.tilesLoading_;
                  }
                  this.tileChangeCallback_();
                }
              };
              TileQueue.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
                var newLoads = 0;
                var state, tile, tileKey;
                while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
                  tile = /** @type {import("./Tile.js").default} */
                  this.dequeue()[0];
                  tileKey = tile.getKey();
                  state = tile.getState();
                  if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                    this.tilesLoadingKeys_[tileKey] = true;
                    ++this.tilesLoading_;
                    ++newLoads;
                    tile.load();
                  }
                }
              };
              return TileQueue;
            }(structs_PriorityQueue)
          );
          var ol_TileQueue = TileQueue_TileQueue;
          function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
            if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
              return DROP;
            }
            if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
              return DROP;
            }
            var center = frameState.viewState.center;
            var deltaX = tileCenter[0] - center[0];
            var deltaY = tileCenter[1] - center[1];
            return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
          }
          var geom_GeometryType = {
            POINT: "Point",
            LINE_STRING: "LineString",
            LINEAR_RING: "LinearRing",
            POLYGON: "Polygon",
            MULTI_POINT: "MultiPoint",
            MULTI_LINE_STRING: "MultiLineString",
            MULTI_POLYGON: "MultiPolygon",
            GEOMETRY_COLLECTION: "GeometryCollection",
            CIRCLE: "Circle"
          };
          var Units = {
            /**
             * Degrees
             * @api
             */
            DEGREES: "degrees",
            /**
             * Feet
             * @api
             */
            FEET: "ft",
            /**
             * Meters
             * @api
             */
            METERS: "m",
            /**
             * Pixels
             * @api
             */
            PIXELS: "pixels",
            /**
             * Tile Pixels
             * @api
             */
            TILE_PIXELS: "tile-pixels",
            /**
             * US Feet
             * @api
             */
            USFEET: "us-ft"
          };
          var METERS_PER_UNIT = {};
          METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
          METERS_PER_UNIT[Units.FEET] = 0.3048;
          METERS_PER_UNIT[Units.METERS] = 1;
          METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
          var proj_Units = Units;
          var ViewHint = {
            ANIMATING: 0,
            INTERACTING: 1
          };
          var ViewProperty = {
            CENTER: "center",
            RESOLUTION: "resolution",
            ROTATION: "rotation"
          };
          var DEFAULT_MAX_ZOOM = 42;
          var DEFAULT_TILE_SIZE = 256;
          var Projection_Projection = (
            /** @class */
            function() {
              function Projection(options) {
                this.code_ = options.code;
                this.units_ = /** @type {import("./Units.js").default} */
                options.units;
                this.extent_ = options.extent !== void 0 ? options.extent : null;
                this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
                this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
                this.global_ = options.global !== void 0 ? options.global : false;
                this.canWrapX_ = !!(this.global_ && this.extent_);
                this.getPointResolutionFunc_ = options.getPointResolution;
                this.defaultTileGrid_ = null;
                this.metersPerUnit_ = options.metersPerUnit;
              }
              Projection.prototype.canWrapX = function() {
                return this.canWrapX_;
              };
              Projection.prototype.getCode = function() {
                return this.code_;
              };
              Projection.prototype.getExtent = function() {
                return this.extent_;
              };
              Projection.prototype.getUnits = function() {
                return this.units_;
              };
              Projection.prototype.getMetersPerUnit = function() {
                return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
              };
              Projection.prototype.getWorldExtent = function() {
                return this.worldExtent_;
              };
              Projection.prototype.getAxisOrientation = function() {
                return this.axisOrientation_;
              };
              Projection.prototype.isGlobal = function() {
                return this.global_;
              };
              Projection.prototype.setGlobal = function(global) {
                this.global_ = global;
                this.canWrapX_ = !!(global && this.extent_);
              };
              Projection.prototype.getDefaultTileGrid = function() {
                return this.defaultTileGrid_;
              };
              Projection.prototype.setDefaultTileGrid = function(tileGrid) {
                this.defaultTileGrid_ = tileGrid;
              };
              Projection.prototype.setExtent = function(extent) {
                this.extent_ = extent;
                this.canWrapX_ = !!(this.global_ && extent);
              };
              Projection.prototype.setWorldExtent = function(worldExtent) {
                this.worldExtent_ = worldExtent;
              };
              Projection.prototype.setGetPointResolution = function(func) {
                this.getPointResolutionFunc_ = func;
              };
              Projection.prototype.getPointResolutionFunc = function() {
                return this.getPointResolutionFunc_;
              };
              return Projection;
            }()
          );
          var proj_Projection = Projection_Projection;
          var epsg3857_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var RADIUS = 6378137;
          var HALF_SIZE = Math.PI * RADIUS;
          var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
          var WORLD_EXTENT = [-180, -85, 180, 85];
          var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
          var epsg3857_EPSG3857Projection = (
            /** @class */
            function(_super) {
              epsg3857_extends(EPSG3857Projection, _super);
              function EPSG3857Projection(code) {
                return _super.call(this, {
                  code,
                  units: proj_Units.METERS,
                  extent: EXTENT,
                  global: true,
                  worldExtent: WORLD_EXTENT,
                  getPointResolution: function(resolution, point) {
                    return resolution / cosh(point[1] / RADIUS);
                  }
                }) || this;
              }
              return EPSG3857Projection;
            }(proj_Projection)
          );
          var PROJECTIONS = [
            new epsg3857_EPSG3857Projection("EPSG:3857"),
            new epsg3857_EPSG3857Projection("EPSG:102100"),
            new epsg3857_EPSG3857Projection("EPSG:102113"),
            new epsg3857_EPSG3857Projection("EPSG:900913"),
            new epsg3857_EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
          ];
          function fromEPSG4326(input, opt_output, opt_dimension) {
            var length = input.length;
            var dimension = opt_dimension > 1 ? opt_dimension : 2;
            var output = opt_output;
            if (output === void 0) {
              if (dimension > 2) {
                output = input.slice();
              } else {
                output = new Array(length);
              }
            }
            for (var i = 0; i < length; i += dimension) {
              output[i] = HALF_SIZE * input[i] / 180;
              var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
              if (y > MAX_SAFE_Y) {
                y = MAX_SAFE_Y;
              } else if (y < -MAX_SAFE_Y) {
                y = -MAX_SAFE_Y;
              }
              output[i + 1] = y;
            }
            return output;
          }
          function toEPSG4326(input, opt_output, opt_dimension) {
            var length = input.length;
            var dimension = opt_dimension > 1 ? opt_dimension : 2;
            var output = opt_output;
            if (output === void 0) {
              if (dimension > 2) {
                output = input.slice();
              } else {
                output = new Array(length);
              }
            }
            for (var i = 0; i < length; i += dimension) {
              output[i] = 180 * input[i] / HALF_SIZE;
              output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
            }
            return output;
          }
          var epsg4326_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var epsg4326_RADIUS = 6378137;
          var epsg4326_EXTENT = [-180, -90, 180, 90];
          var epsg4326_METERS_PER_UNIT = Math.PI * epsg4326_RADIUS / 180;
          var epsg4326_EPSG4326Projection = (
            /** @class */
            function(_super) {
              epsg4326_extends(EPSG4326Projection, _super);
              function EPSG4326Projection(code, opt_axisOrientation) {
                return _super.call(this, {
                  code,
                  units: proj_Units.DEGREES,
                  extent: epsg4326_EXTENT,
                  axisOrientation: opt_axisOrientation,
                  global: true,
                  metersPerUnit: epsg4326_METERS_PER_UNIT,
                  worldExtent: epsg4326_EXTENT
                }) || this;
              }
              return EPSG4326Projection;
            }(proj_Projection)
          );
          var epsg4326_PROJECTIONS = [
            new epsg4326_EPSG4326Projection("CRS:84"),
            new epsg4326_EPSG4326Projection("EPSG:4326", "neu"),
            new epsg4326_EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
            new epsg4326_EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
            new epsg4326_EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu")
          ];
          var projections_cache = {};
          function clear() {
            projections_cache = {};
          }
          function projections_get(code) {
            return projections_cache[code] || projections_cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
          }
          function projections_add(code, projection) {
            projections_cache[code] = projection;
          }
          var transforms_transforms = {};
          function transforms_clear() {
            transforms_transforms = {};
          }
          function transforms_add(source, destination, transformFn) {
            var sourceCode = source.getCode();
            var destinationCode = destination.getCode();
            if (!(sourceCode in transforms_transforms)) {
              transforms_transforms[sourceCode] = {};
            }
            transforms_transforms[sourceCode][destinationCode] = transformFn;
          }
          function transforms_remove(source, destination) {
            var sourceCode = source.getCode();
            var destinationCode = destination.getCode();
            var transform2 = transforms_transforms[sourceCode][destinationCode];
            delete transforms_transforms[sourceCode][destinationCode];
            if (Object(ol_obj[
              "d"
              /* isEmpty */
            ])(transforms_transforms[sourceCode])) {
              delete transforms_transforms[sourceCode];
            }
            return transform2;
          }
          function transforms_get(sourceCode, destinationCode) {
            var transform2;
            if (sourceCode in transforms_transforms && destinationCode in transforms_transforms[sourceCode]) {
              transform2 = transforms_transforms[sourceCode][destinationCode];
            }
            return transform2;
          }
          var DEFAULT_RADIUS = 63710088e-1;
          function getDistance(c1, c2, opt_radius) {
            var radius = opt_radius || DEFAULT_RADIUS;
            var lat1 = toRadians(c1[1]);
            var lat2 = toRadians(c2[1]);
            var deltaLatBy2 = (lat2 - lat1) / 2;
            var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
            var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
            return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          }
          function getLengthInternal(coordinates, radius) {
            var length = 0;
            for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
              length += getDistance(coordinates[i], coordinates[i + 1], radius);
            }
            return length;
          }
          function getLength(geometry, opt_options) {
            var options = opt_options || {};
            var radius = options.radius || DEFAULT_RADIUS;
            var projection = options.projection || "EPSG:3857";
            var type = geometry.getType();
            if (type !== geom_GeometryType.GEOMETRY_COLLECTION) {
              geometry = geometry.clone().transform(projection, "EPSG:4326");
            }
            var length = 0;
            var coordinates, coords, i, ii, j, jj;
            switch (type) {
              case geom_GeometryType.POINT:
              case geom_GeometryType.MULTI_POINT: {
                break;
              }
              case geom_GeometryType.LINE_STRING:
              case geom_GeometryType.LINEAR_RING: {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */
                geometry.getCoordinates();
                length = getLengthInternal(coordinates, radius);
                break;
              }
              case geom_GeometryType.MULTI_LINE_STRING:
              case geom_GeometryType.POLYGON: {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */
                geometry.getCoordinates();
                for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  length += getLengthInternal(coordinates[i], radius);
                }
                break;
              }
              case geom_GeometryType.MULTI_POLYGON: {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */
                geometry.getCoordinates();
                for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  coords = coordinates[i];
                  for (j = 0, jj = coords.length; j < jj; ++j) {
                    length += getLengthInternal(coords[j], radius);
                  }
                }
                break;
              }
              case geom_GeometryType.GEOMETRY_COLLECTION: {
                var geometries = (
                  /** @type {import("./geom/GeometryCollection.js").default} */
                  geometry.getGeometries()
                );
                for (i = 0, ii = geometries.length; i < ii; ++i) {
                  length += getLength(geometries[i], opt_options);
                }
                break;
              }
              default: {
                throw new Error("Unsupported geometry type: " + type);
              }
            }
            return length;
          }
          function getAreaInternal(coordinates, radius) {
            var area = 0;
            var len = coordinates.length;
            var x1 = coordinates[len - 1][0];
            var y1 = coordinates[len - 1][1];
            for (var i = 0; i < len; i++) {
              var x2 = coordinates[i][0];
              var y2 = coordinates[i][1];
              area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
              x1 = x2;
              y1 = y2;
            }
            return area * radius * radius / 2;
          }
          function sphere_getArea(geometry, opt_options) {
            var options = opt_options || {};
            var radius = options.radius || DEFAULT_RADIUS;
            var projection = options.projection || "EPSG:3857";
            var type = geometry.getType();
            if (type !== geom_GeometryType.GEOMETRY_COLLECTION) {
              geometry = geometry.clone().transform(projection, "EPSG:4326");
            }
            var area = 0;
            var coordinates, coords, i, ii, j, jj;
            switch (type) {
              case geom_GeometryType.POINT:
              case geom_GeometryType.MULTI_POINT:
              case geom_GeometryType.LINE_STRING:
              case geom_GeometryType.MULTI_LINE_STRING:
              case geom_GeometryType.LINEAR_RING: {
                break;
              }
              case geom_GeometryType.POLYGON: {
                coordinates = /** @type {import("./geom/Polygon.js").default} */
                geometry.getCoordinates();
                area = Math.abs(getAreaInternal(coordinates[0], radius));
                for (i = 1, ii = coordinates.length; i < ii; ++i) {
                  area -= Math.abs(getAreaInternal(coordinates[i], radius));
                }
                break;
              }
              case geom_GeometryType.MULTI_POLYGON: {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */
                geometry.getCoordinates();
                for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  coords = coordinates[i];
                  area += Math.abs(getAreaInternal(coords[0], radius));
                  for (j = 1, jj = coords.length; j < jj; ++j) {
                    area -= Math.abs(getAreaInternal(coords[j], radius));
                  }
                }
                break;
              }
              case geom_GeometryType.GEOMETRY_COLLECTION: {
                var geometries = (
                  /** @type {import("./geom/GeometryCollection.js").default} */
                  geometry.getGeometries()
                );
                for (i = 0, ii = geometries.length; i < ii; ++i) {
                  area += sphere_getArea(geometries[i], opt_options);
                }
                break;
              }
              default: {
                throw new Error("Unsupported geometry type: " + type);
              }
            }
            return area;
          }
          function sphere_offset(c1, distance, bearing, opt_radius) {
            var radius = opt_radius || DEFAULT_RADIUS;
            var lat1 = toRadians(c1[1]);
            var lon1 = toRadians(c1[0]);
            var dByR = distance / radius;
            var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
            var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
            return [toDegrees(lon), toDegrees(lat)];
          }
          function cloneTransform(input, opt_output, opt_dimension) {
            var output;
            if (opt_output !== void 0) {
              for (var i = 0, ii = input.length; i < ii; ++i) {
                opt_output[i] = input[i];
              }
              output = opt_output;
            } else {
              output = input.slice();
            }
            return output;
          }
          function identityTransform(input, opt_output, opt_dimension) {
            if (opt_output !== void 0 && input !== opt_output) {
              for (var i = 0, ii = input.length; i < ii; ++i) {
                opt_output[i] = input[i];
              }
              input = opt_output;
            }
            return input;
          }
          function addProjection(projection) {
            projections_add(projection.getCode(), projection);
            transforms_add(projection, projection, cloneTransform);
          }
          function addProjections(projections) {
            projections.forEach(addProjection);
          }
          function proj_get(projectionLike) {
            return typeof projectionLike === "string" ? projections_get(
              /** @type {string} */
              projectionLike
            ) : (
              /** @type {Projection} */
              projectionLike || null
            );
          }
          function getPointResolution(projection, resolution, point, opt_units) {
            projection = proj_get(projection);
            var pointResolution;
            var getter = projection.getPointResolutionFunc();
            if (getter) {
              pointResolution = getter(resolution, point);
              if (opt_units && opt_units !== projection.getUnits()) {
                var metersPerUnit = projection.getMetersPerUnit();
                if (metersPerUnit) {
                  pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[opt_units];
                }
              }
            } else {
              var units = projection.getUnits();
              if (units == proj_Units.DEGREES && !opt_units || opt_units == proj_Units.DEGREES) {
                pointResolution = resolution;
              } else {
                var toEPSG4326_1 = getTransformFromProjections(projection, proj_get("EPSG:4326"));
                if (toEPSG4326_1 === identityTransform && units !== proj_Units.DEGREES) {
                  pointResolution = resolution * projection.getMetersPerUnit();
                } else {
                  var vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2
                  ];
                  vertices = toEPSG4326_1(vertices, vertices, 2);
                  var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
                  var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
                  pointResolution = (width + height) / 2;
                }
                var metersPerUnit = opt_units ? METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
                if (metersPerUnit !== void 0) {
                  pointResolution /= metersPerUnit;
                }
              }
            }
            return pointResolution;
          }
          function addEquivalentProjections(projections) {
            addProjections(projections);
            projections.forEach(function(source) {
              projections.forEach(function(destination) {
                if (source !== destination) {
                  transforms_add(source, destination, cloneTransform);
                }
              });
            });
          }
          function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
            projections1.forEach(function(projection1) {
              projections2.forEach(function(projection2) {
                transforms_add(projection1, projection2, forwardTransform);
                transforms_add(projection2, projection1, inverseTransform);
              });
            });
          }
          function clearAllProjections() {
            clear();
            transforms_clear();
          }
          function createProjection(projection, defaultCode) {
            if (!projection) {
              return proj_get(defaultCode);
            } else if (typeof projection === "string") {
              return proj_get(projection);
            } else {
              return (
                /** @type {Projection} */
                projection
              );
            }
          }
          function createTransformFromCoordinateTransform(coordTransform) {
            return (
              /**
               * @param {Array<number>} input Input.
               * @param {Array<number>} [opt_output] Output.
               * @param {number} [opt_dimension] Dimension.
               * @return {Array<number>} Output.
               */
              function(input, opt_output, opt_dimension) {
                var length = input.length;
                var dimension = opt_dimension !== void 0 ? opt_dimension : 2;
                var output = opt_output !== void 0 ? opt_output : new Array(length);
                for (var i = 0; i < length; i += dimension) {
                  var point = coordTransform([input[i], input[i + 1]]);
                  output[i] = point[0];
                  output[i + 1] = point[1];
                  for (var j = dimension - 1; j >= 2; --j) {
                    output[i + j] = input[i + j];
                  }
                }
                return output;
              }
            );
          }
          function addCoordinateTransforms(source, destination, forward, inverse) {
            var sourceProj = proj_get(source);
            var destProj = proj_get(destination);
            transforms_add(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
            transforms_add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
          }
          function fromLonLat(coordinate, opt_projection) {
            return proj_transform(coordinate, "EPSG:4326", opt_projection !== void 0 ? opt_projection : "EPSG:3857");
          }
          function toLonLat(coordinate, opt_projection) {
            var lonLat = proj_transform(coordinate, opt_projection !== void 0 ? opt_projection : "EPSG:3857", "EPSG:4326");
            var lon = lonLat[0];
            if (lon < -180 || lon > 180) {
              lonLat[0] = modulo(lon + 180, 360) - 180;
            }
            return lonLat;
          }
          function equivalent(projection1, projection2) {
            if (projection1 === projection2) {
              return true;
            }
            var equalUnits = projection1.getUnits() === projection2.getUnits();
            if (projection1.getCode() === projection2.getCode()) {
              return equalUnits;
            } else {
              var transformFunc = getTransformFromProjections(projection1, projection2);
              return transformFunc === cloneTransform && equalUnits;
            }
          }
          function getTransformFromProjections(sourceProjection, destinationProjection) {
            var sourceCode = sourceProjection.getCode();
            var destinationCode = destinationProjection.getCode();
            var transformFunc = transforms_get(sourceCode, destinationCode);
            if (!transformFunc) {
              transformFunc = identityTransform;
            }
            return transformFunc;
          }
          function getTransform(source, destination) {
            var sourceProjection = proj_get(source);
            var destinationProjection = proj_get(destination);
            return getTransformFromProjections(sourceProjection, destinationProjection);
          }
          function proj_transform(coordinate, source, destination) {
            var transformFunc = getTransform(source, destination);
            return transformFunc(coordinate, void 0, coordinate.length);
          }
          function transformExtent(extent, source, destination, opt_stops) {
            var transformFunc = getTransform(source, destination);
            return applyTransform(extent, transformFunc, void 0, opt_stops);
          }
          function transformWithProjections(point, sourceProjection, destinationProjection) {
            var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
            return transformFunc(point);
          }
          var proj_userProjection = null;
          function setUserProjection(projection) {
            proj_userProjection = proj_get(projection);
          }
          function clearUserProjection() {
            proj_userProjection = null;
          }
          function getUserProjection() {
            return proj_userProjection;
          }
          function useGeographic() {
            setUserProjection("EPSG:4326");
          }
          function toUserCoordinate(coordinate, sourceProjection) {
            if (!proj_userProjection) {
              return coordinate;
            }
            return proj_transform(coordinate, sourceProjection, proj_userProjection);
          }
          function fromUserCoordinate(coordinate, destProjection) {
            if (!proj_userProjection) {
              return coordinate;
            }
            return proj_transform(coordinate, proj_userProjection, destProjection);
          }
          function toUserExtent(extent, sourceProjection) {
            if (!proj_userProjection) {
              return extent;
            }
            return transformExtent(extent, sourceProjection, proj_userProjection);
          }
          function fromUserExtent(extent, destProjection) {
            if (!proj_userProjection) {
              return extent;
            }
            return transformExtent(extent, proj_userProjection, destProjection);
          }
          function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
            return function(coord) {
              var sourceX = coord[0];
              var sourceY = coord[1];
              var transformed, worldsAway;
              if (sourceProj.canWrapX()) {
                var sourceExtent = sourceProj.getExtent();
                var sourceExtentWidth = getWidth(sourceExtent);
                worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
                if (worldsAway) {
                  sourceX = sourceX - worldsAway * sourceExtentWidth;
                }
                sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
                sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
                transformed = transform2([sourceX, sourceY]);
              } else {
                transformed = transform2(coord);
              }
              if (worldsAway && destProj.canWrapX()) {
                transformed[0] += worldsAway * getWidth(destProj.getExtent());
              }
              return transformed;
            };
          }
          function addCommon() {
            addEquivalentProjections(PROJECTIONS);
            addEquivalentProjections(epsg4326_PROJECTIONS);
            addEquivalentTransforms(epsg4326_PROJECTIONS, PROJECTIONS, fromEPSG4326, toEPSG4326);
          }
          addCommon();
          function createExtent(extent, onlyCenter, smooth) {
            return (
              /**
               * @param {import("./coordinate.js").Coordinate|undefined} center Center.
               * @param {number} resolution Resolution.
               * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.
               * @return {import("./coordinate.js").Coordinate|undefined} Center.
               */
              function(center, resolution, size, opt_isMoving, opt_centerShift) {
                if (center) {
                  var viewWidth = onlyCenter ? 0 : size[0] * resolution;
                  var viewHeight = onlyCenter ? 0 : size[1] * resolution;
                  var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
                  var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
                  var minX = extent[0] + viewWidth / 2 + shiftX;
                  var maxX = extent[2] - viewWidth / 2 + shiftX;
                  var minY = extent[1] + viewHeight / 2 + shiftY;
                  var maxY = extent[3] - viewHeight / 2 + shiftY;
                  if (minX > maxX) {
                    minX = (maxX + minX) / 2;
                    maxX = minX;
                  }
                  if (minY > maxY) {
                    minY = (maxY + minY) / 2;
                    maxY = minY;
                  }
                  var x = clamp(center[0], minX, maxX);
                  var y = clamp(center[1], minY, maxY);
                  var ratio = 30 * resolution;
                  if (opt_isMoving && smooth) {
                    x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                    y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
                  }
                  return [x, y];
                } else {
                  return void 0;
                }
              }
            );
          }
          function none(center) {
            return center;
          }
          var ol_array = __webpack_require__("9f5e");
          function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
            var xResolution = getWidth(maxExtent) / viewportSize[0];
            var yResolution = getHeight(maxExtent) / viewportSize[1];
            if (showFullExtent) {
              return Math.min(resolution, Math.max(xResolution, yResolution));
            }
            return Math.min(resolution, Math.min(xResolution, yResolution));
          }
          function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
            var result = Math.min(resolution, maxResolution);
            var ratio = 50;
            result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
            if (minResolution) {
              result = Math.max(result, minResolution);
              result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
            }
            return clamp(result, minResolution / 2, maxResolution * 2);
          }
          function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
            return (
              /**
               * @param {number|undefined} resolution Resolution.
               * @param {number} direction Direction.
               * @param {import("./size.js").Size} size Viewport size.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @return {number|undefined} Resolution.
               */
              function(resolution, direction, size, opt_isMoving) {
                if (resolution !== void 0) {
                  var maxResolution = resolutions[0];
                  var minResolution = resolutions[resolutions.length - 1];
                  var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
                  if (opt_isMoving) {
                    var smooth = opt_smooth !== void 0 ? opt_smooth : true;
                    if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                    }
                    return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
                  }
                  var capped = Math.min(cappedMaxRes, resolution);
                  var z = Math.floor(Object(ol_array[
                    "h"
                    /* linearFindNearest */
                  ])(resolutions, capped, direction));
                  if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                    return resolutions[z + 1];
                  }
                  return resolutions[z];
                } else {
                  return void 0;
                }
              }
            );
          }
          function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
            return (
              /**
               * @param {number|undefined} resolution Resolution.
               * @param {number} direction Direction.
               * @param {import("./size.js").Size} size Viewport size.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @return {number|undefined} Resolution.
               */
              function(resolution, direction, size, opt_isMoving) {
                if (resolution !== void 0) {
                  var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
                  var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;
                  if (opt_isMoving) {
                    var smooth = opt_smooth !== void 0 ? opt_smooth : true;
                    if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                    }
                    return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
                  }
                  var tolerance = 1e-9;
                  var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
                  var offset = -direction * (0.5 - tolerance) + 0.5;
                  var capped = Math.min(cappedMaxRes, resolution);
                  var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
                  var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
                  var newResolution = maxResolution / Math.pow(power, zoomLevel);
                  return clamp(newResolution, minResolution, cappedMaxRes);
                } else {
                  return void 0;
                }
              }
            );
          }
          function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
            return (
              /**
               * @param {number|undefined} resolution Resolution.
               * @param {number} direction Direction.
               * @param {import("./size.js").Size} size Viewport size.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @return {number|undefined} Resolution.
               */
              function(resolution, direction, size, opt_isMoving) {
                if (resolution !== void 0) {
                  var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
                  var smooth = opt_smooth !== void 0 ? opt_smooth : true;
                  if (!smooth || !opt_isMoving) {
                    return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
                } else {
                  return void 0;
                }
              }
            );
          }
          function disable(rotation) {
            if (rotation !== void 0) {
              return 0;
            } else {
              return void 0;
            }
          }
          function rotationconstraint_none(rotation) {
            if (rotation !== void 0) {
              return rotation;
            } else {
              return void 0;
            }
          }
          function createSnapToN(n) {
            var theta = 2 * Math.PI / n;
            return (
              /**
               * @param {number|undefined} rotation Rotation.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @return {number|undefined} Rotation.
               */
              function(rotation, opt_isMoving) {
                if (opt_isMoving) {
                  return rotation;
                }
                if (rotation !== void 0) {
                  rotation = Math.floor(rotation / theta + 0.5) * theta;
                  return rotation;
                } else {
                  return void 0;
                }
              }
            );
          }
          function createSnapToZero(opt_tolerance) {
            var tolerance = opt_tolerance || toRadians(5);
            return (
              /**
               * @param {number|undefined} rotation Rotation.
               * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
               * @return {number|undefined} Rotation.
               */
              function(rotation, opt_isMoving) {
                if (opt_isMoving) {
                  return rotation;
                }
                if (rotation !== void 0) {
                  if (Math.abs(rotation) <= tolerance) {
                    return 0;
                  } else {
                    return rotation;
                  }
                } else {
                  return void 0;
                }
              }
            );
          }
          function easeIn(t) {
            return Math.pow(t, 3);
          }
          function easeOut(t) {
            return 1 - easeIn(1 - t);
          }
          function inAndOut(t) {
            return 3 * t * t - 2 * t * t * t;
          }
          function linear(t) {
            return t;
          }
          function upAndDown(t) {
            if (t < 0.5) {
              return inAndOut(2 * t);
            } else {
              return 1 - inAndOut(2 * (t - 0.5));
            }
          }
          var GeometryLayout = {
            XY: "XY",
            XYZ: "XYZ",
            XYM: "XYM",
            XYZM: "XYZM"
          };
          function transform2D(flatCoordinates, offset, end, stride, transform2, opt_dest) {
            var dest = opt_dest ? opt_dest : [];
            var i = 0;
            for (var j = offset; j < end; j += stride) {
              var x = flatCoordinates[j];
              var y = flatCoordinates[j + 1];
              dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
              dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
            }
            if (opt_dest && dest.length != i) {
              dest.length = i;
            }
            return dest;
          }
          function transform_rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
            var dest = opt_dest ? opt_dest : [];
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var anchorX = anchor[0];
            var anchorY = anchor[1];
            var i = 0;
            for (var j = offset; j < end; j += stride) {
              var deltaX = flatCoordinates[j] - anchorX;
              var deltaY = flatCoordinates[j + 1] - anchorY;
              dest[i++] = anchorX + deltaX * cos - deltaY * sin;
              dest[i++] = anchorY + deltaX * sin + deltaY * cos;
              for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
              }
            }
            if (opt_dest && dest.length != i) {
              dest.length = i;
            }
            return dest;
          }
          function flat_transform_scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
            var dest = opt_dest ? opt_dest : [];
            var anchorX = anchor[0];
            var anchorY = anchor[1];
            var i = 0;
            for (var j = offset; j < end; j += stride) {
              var deltaX = flatCoordinates[j] - anchorX;
              var deltaY = flatCoordinates[j + 1] - anchorY;
              dest[i++] = anchorX + sx * deltaX;
              dest[i++] = anchorY + sy * deltaY;
              for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
              }
            }
            if (opt_dest && dest.length != i) {
              dest.length = i;
            }
            return dest;
          }
          function flat_transform_translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
            var dest = opt_dest ? opt_dest : [];
            var i = 0;
            for (var j = offset; j < end; j += stride) {
              dest[i++] = flatCoordinates[j] + deltaX;
              dest[i++] = flatCoordinates[j + 1] + deltaY;
              for (var k = j + 2; k < j + stride; ++k) {
                dest[i++] = flatCoordinates[k];
              }
            }
            if (opt_dest && dest.length != i) {
              dest.length = i;
            }
            return dest;
          }
          var Geometry_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var tmpTransform = create();
          var Geometry_Geometry = (
            /** @class */
            function(_super) {
              Geometry_extends(Geometry, _super);
              function Geometry() {
                var _this = _super.call(this) || this;
                _this.extent_ = createEmpty();
                _this.extentRevision_ = -1;
                _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
                _this.simplifiedGeometryRevision = 0;
                _this.simplifyTransformedInternal = Object(functions[
                  "d"
                  /* memoizeOne */
                ])(function(revision, squaredTolerance, opt_transform) {
                  if (!opt_transform) {
                    return this.getSimplifiedGeometry(squaredTolerance);
                  }
                  var clone2 = this.clone();
                  clone2.applyTransform(opt_transform);
                  return clone2.getSimplifiedGeometry(squaredTolerance);
                });
                return _this;
              }
              Geometry.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
                return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
              };
              Geometry.prototype.clone = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.containsXY = function(x, y) {
                var coord = this.getClosestPoint([x, y]);
                return coord[0] === x && coord[1] === y;
              };
              Geometry.prototype.getClosestPoint = function(point, opt_closestPoint) {
                var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
                this.closestPointXY(point[0], point[1], closestPoint, Infinity);
                return closestPoint;
              };
              Geometry.prototype.intersectsCoordinate = function(coordinate) {
                return this.containsXY(coordinate[0], coordinate[1]);
              };
              Geometry.prototype.computeExtent = function(extent) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.getExtent = function(opt_extent) {
                if (this.extentRevision_ != this.getRevision()) {
                  var extent = this.computeExtent(this.extent_);
                  if (isNaN(extent[0]) || isNaN(extent[1])) {
                    createOrUpdateEmpty(extent);
                  }
                  this.extentRevision_ = this.getRevision();
                }
                return returnOrUpdate(this.extent_, opt_extent);
              };
              Geometry.prototype.rotate = function(angle, anchor) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.simplify = function(tolerance) {
                return this.getSimplifiedGeometry(tolerance * tolerance);
              };
              Geometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.getType = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.applyTransform = function(transformFn) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.intersectsExtent = function(extent) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.translate = function(deltaX, deltaY) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Geometry.prototype.transform = function(source, destination) {
                var sourceProj = proj_get(source);
                var transformFn = sourceProj.getUnits() == proj_Units.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
                  var pixelExtent = sourceProj.getExtent();
                  var projectedExtent = sourceProj.getWorldExtent();
                  var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
                  compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                  transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                  return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
                } : getTransform(sourceProj, destination);
                this.applyTransform(transformFn);
                return this;
              };
              return Geometry;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          var geom_Geometry = Geometry_Geometry;
          var SimpleGeometry_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var SimpleGeometry_SimpleGeometry = (
            /** @class */
            function(_super) {
              SimpleGeometry_extends(SimpleGeometry, _super);
              function SimpleGeometry() {
                var _this = _super.call(this) || this;
                _this.layout = GeometryLayout.XY;
                _this.stride = 2;
                _this.flatCoordinates = null;
                return _this;
              }
              SimpleGeometry.prototype.computeExtent = function(extent) {
                return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
              };
              SimpleGeometry.prototype.getCoordinates = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              SimpleGeometry.prototype.getFirstCoordinate = function() {
                return this.flatCoordinates.slice(0, this.stride);
              };
              SimpleGeometry.prototype.getFlatCoordinates = function() {
                return this.flatCoordinates;
              };
              SimpleGeometry.prototype.getLastCoordinate = function() {
                return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
              };
              SimpleGeometry.prototype.getLayout = function() {
                return this.layout;
              };
              SimpleGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
                if (this.simplifiedGeometryRevision !== this.getRevision()) {
                  this.simplifiedGeometryMaxMinSquaredTolerance = 0;
                  this.simplifiedGeometryRevision = this.getRevision();
                }
                if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
                  return this;
                }
                var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
                var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
                if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
                  return simplifiedGeometry;
                } else {
                  this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
                  return this;
                }
              };
              SimpleGeometry.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                return this;
              };
              SimpleGeometry.prototype.getStride = function() {
                return this.stride;
              };
              SimpleGeometry.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
                this.stride = getStrideForLayout(layout);
                this.layout = layout;
                this.flatCoordinates = flatCoordinates;
              };
              SimpleGeometry.prototype.setCoordinates = function(coordinates, opt_layout) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              SimpleGeometry.prototype.setLayout = function(layout, coordinates, nesting) {
                var stride;
                if (layout) {
                  stride = getStrideForLayout(layout);
                } else {
                  for (var i = 0; i < nesting; ++i) {
                    if (coordinates.length === 0) {
                      this.layout = GeometryLayout.XY;
                      this.stride = 2;
                      return;
                    } else {
                      coordinates = /** @type {Array} */
                      coordinates[0];
                    }
                  }
                  stride = coordinates.length;
                  layout = getLayoutForStride(stride);
                }
                this.layout = layout;
                this.stride = stride;
              };
              SimpleGeometry.prototype.applyTransform = function(transformFn) {
                if (this.flatCoordinates) {
                  transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
                  this.changed();
                }
              };
              SimpleGeometry.prototype.rotate = function(angle, anchor) {
                var flatCoordinates = this.getFlatCoordinates();
                if (flatCoordinates) {
                  var stride = this.getStride();
                  transform_rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
                  this.changed();
                }
              };
              SimpleGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
                var sy = opt_sy;
                if (sy === void 0) {
                  sy = sx;
                }
                var anchor = opt_anchor;
                if (!anchor) {
                  anchor = extent_getCenter(this.getExtent());
                }
                var flatCoordinates = this.getFlatCoordinates();
                if (flatCoordinates) {
                  var stride = this.getStride();
                  flat_transform_scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
                  this.changed();
                }
              };
              SimpleGeometry.prototype.translate = function(deltaX, deltaY) {
                var flatCoordinates = this.getFlatCoordinates();
                if (flatCoordinates) {
                  var stride = this.getStride();
                  flat_transform_translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
                  this.changed();
                }
              };
              return SimpleGeometry;
            }(geom_Geometry)
          );
          function getLayoutForStride(stride) {
            var layout;
            if (stride == 2) {
              layout = GeometryLayout.XY;
            } else if (stride == 3) {
              layout = GeometryLayout.XYZ;
            } else if (stride == 4) {
              layout = GeometryLayout.XYZM;
            }
            return (
              /** @type {import("./GeometryLayout.js").default} */
              layout
            );
          }
          function getStrideForLayout(layout) {
            var stride;
            if (layout == GeometryLayout.XY) {
              stride = 2;
            } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
              stride = 3;
            } else if (layout == GeometryLayout.XYZM) {
              stride = 4;
            }
            return (
              /** @type {number} */
              stride
            );
          }
          function transformGeom2D(simpleGeometry, transform2, opt_dest) {
            var flatCoordinates = simpleGeometry.getFlatCoordinates();
            if (!flatCoordinates) {
              return null;
            } else {
              var stride = simpleGeometry.getStride();
              return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, opt_dest);
            }
          }
          var geom_SimpleGeometry = SimpleGeometry_SimpleGeometry;
          function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
            var x1 = flatCoordinates[offset1];
            var y1 = flatCoordinates[offset1 + 1];
            var dx = flatCoordinates[offset2] - x1;
            var dy = flatCoordinates[offset2 + 1] - y1;
            var offset;
            if (dx === 0 && dy === 0) {
              offset = offset1;
            } else {
              var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
              if (t > 1) {
                offset = offset2;
              } else if (t > 0) {
                for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
                }
                closestPoint.length = stride;
                return;
              } else {
                offset = offset1;
              }
            }
            for (var i = 0; i < stride; ++i) {
              closestPoint[i] = flatCoordinates[offset + i];
            }
            closestPoint.length = stride;
          }
          function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
            var x1 = flatCoordinates[offset];
            var y1 = flatCoordinates[offset + 1];
            for (offset += stride; offset < end; offset += stride) {
              var x2 = flatCoordinates[offset];
              var y2 = flatCoordinates[offset + 1];
              var squaredDelta = math_squaredDistance(x1, y1, x2, y2);
              if (squaredDelta > max) {
                max = squaredDelta;
              }
              x1 = x2;
              y1 = y2;
            }
            return max;
          }
          function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
              offset = end;
            }
            return max;
          }
          function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
              offset = ends[ends.length - 1];
            }
            return max;
          }
          function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
            if (offset == end) {
              return minSquaredDistance;
            }
            var i, squaredDistance;
            if (maxDelta === 0) {
              squaredDistance = math_squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
              if (squaredDistance < minSquaredDistance) {
                for (i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[offset + i];
                }
                closestPoint.length = stride;
                return squaredDistance;
              } else {
                return minSquaredDistance;
              }
            }
            var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
            var index = offset + stride;
            while (index < end) {
              assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
              squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
              if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
                }
                closestPoint.length = stride;
                index += stride;
              } else {
                index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
              }
            }
            if (isRing) {
              assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
              squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
              if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
                }
                closestPoint.length = stride;
              }
            }
            return minSquaredDistance;
          }
          function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
            var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
              offset = end;
            }
            return minSquaredDistance;
          }
          function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
            var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
              offset = ends[ends.length - 1];
            }
            return minSquaredDistance;
          }
          function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
            for (var i = 0, ii = coordinate.length; i < ii; ++i) {
              flatCoordinates[offset++] = coordinate[i];
            }
            return offset;
          }
          function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              var coordinate = coordinates[i];
              for (var j = 0; j < stride; ++j) {
                flatCoordinates[offset++] = coordinate[j];
              }
            }
            return offset;
          }
          function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
            var ends = opt_ends ? opt_ends : [];
            var i = 0;
            for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
              var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
              ends[i++] = end;
              offset = end;
            }
            ends.length = i;
            return ends;
          }
          function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
            var endss = opt_endss ? opt_endss : [];
            var i = 0;
            for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
              var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
              endss[i++] = ends;
              offset = ends[ends.length - 1];
            }
            endss.length = i;
            return endss;
          }
          function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
            var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== void 0 ? opt_simplifiedFlatCoordinates : [];
            if (!highQuality) {
              end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
              flatCoordinates = simplifiedFlatCoordinates;
              offset = 0;
              stride = 2;
            }
            simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            return simplifiedFlatCoordinates;
          }
          function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
            var n = (end - offset) / stride;
            if (n < 3) {
              for (; offset < end; offset += stride) {
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
              }
              return simplifiedOffset;
            }
            var markers = new Array(n);
            markers[0] = 1;
            markers[n - 1] = 1;
            var stack2 = [offset, end - stride];
            var index = 0;
            while (stack2.length > 0) {
              var last = stack2.pop();
              var first = stack2.pop();
              var maxSquaredDistance = 0;
              var x1 = flatCoordinates[first];
              var y1 = flatCoordinates[first + 1];
              var x2 = flatCoordinates[last];
              var y2 = flatCoordinates[last + 1];
              for (var i = first + stride; i < last; i += stride) {
                var x = flatCoordinates[i];
                var y = flatCoordinates[i + 1];
                var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
                if (squaredDistance_1 > maxSquaredDistance) {
                  index = i;
                  maxSquaredDistance = squaredDistance_1;
                }
              }
              if (maxSquaredDistance > squaredTolerance) {
                markers[(index - offset) / stride] = 1;
                if (first + stride < index) {
                  stack2.push(first, index);
                }
                if (index + stride < last) {
                  stack2.push(index, last);
                }
              }
            }
            for (var i = 0; i < n; ++i) {
              if (markers[i]) {
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
              }
            }
            return simplifiedOffset;
          }
          function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
              simplifiedEnds.push(simplifiedOffset);
              offset = end;
            }
            return simplifiedOffset;
          }
          function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              var simplifiedEnds = [];
              simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
              simplifiedEndss.push(simplifiedEnds);
              offset = ends[ends.length - 1];
            }
            return simplifiedOffset;
          }
          function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
            if (end <= offset + stride) {
              for (; offset < end; offset += stride) {
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
                simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
              }
              return simplifiedOffset;
            }
            var x1 = flatCoordinates[offset];
            var y1 = flatCoordinates[offset + 1];
            simplifiedFlatCoordinates[simplifiedOffset++] = x1;
            simplifiedFlatCoordinates[simplifiedOffset++] = y1;
            var x2 = x1;
            var y2 = y1;
            for (offset += stride; offset < end; offset += stride) {
              x2 = flatCoordinates[offset];
              y2 = flatCoordinates[offset + 1];
              if (math_squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
                simplifiedFlatCoordinates[simplifiedOffset++] = x2;
                simplifiedFlatCoordinates[simplifiedOffset++] = y2;
                x1 = x2;
                y1 = y2;
              }
            }
            if (x2 != x1 || y2 != y1) {
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            }
            return simplifiedOffset;
          }
          function simplify_snap(value, tolerance) {
            return tolerance * Math.round(value / tolerance);
          }
          function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
            if (offset == end) {
              return simplifiedOffset;
            }
            var x1 = simplify_snap(flatCoordinates[offset], tolerance);
            var y1 = simplify_snap(flatCoordinates[offset + 1], tolerance);
            offset += stride;
            simplifiedFlatCoordinates[simplifiedOffset++] = x1;
            simplifiedFlatCoordinates[simplifiedOffset++] = y1;
            var x2, y2;
            do {
              x2 = simplify_snap(flatCoordinates[offset], tolerance);
              y2 = simplify_snap(flatCoordinates[offset + 1], tolerance);
              offset += stride;
              if (offset == end) {
                simplifiedFlatCoordinates[simplifiedOffset++] = x2;
                simplifiedFlatCoordinates[simplifiedOffset++] = y2;
                return simplifiedOffset;
              }
            } while (x2 == x1 && y2 == y1);
            while (offset < end) {
              var x3 = simplify_snap(flatCoordinates[offset], tolerance);
              var y3 = simplify_snap(flatCoordinates[offset + 1], tolerance);
              offset += stride;
              if (x3 == x2 && y3 == y2) {
                continue;
              }
              var dx1 = x2 - x1;
              var dy1 = y2 - y1;
              var dx2 = x3 - x1;
              var dy2 = y3 - y1;
              if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
                x2 = x3;
                y2 = y3;
                continue;
              }
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              x1 = x2;
              y1 = y2;
              x2 = x3;
              y2 = y3;
            }
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
          }
          function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
              simplifiedEnds.push(simplifiedOffset);
              offset = end;
            }
            return simplifiedOffset;
          }
          function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              var simplifiedEnds = [];
              simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
              simplifiedEndss.push(simplifiedEnds);
              offset = ends[ends.length - 1];
            }
            return simplifiedOffset;
          }
          function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
            var coordinates = opt_coordinates !== void 0 ? opt_coordinates : [];
            var i = 0;
            for (var j = offset; j < end; j += stride) {
              coordinates[i++] = flatCoordinates.slice(j, j + stride);
            }
            coordinates.length = i;
            return coordinates;
          }
          function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
            var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];
            var i = 0;
            for (var j = 0, jj = ends.length; j < jj; ++j) {
              var end = ends[j];
              coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
              offset = end;
            }
            coordinatess.length = i;
            return coordinatess;
          }
          function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
            var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];
            var i = 0;
            for (var j = 0, jj = endss.length; j < jj; ++j) {
              var ends = endss[j];
              coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
              offset = ends[ends.length - 1];
            }
            coordinatesss.length = i;
            return coordinatesss;
          }
          function area_linearRing(flatCoordinates, offset, end, stride) {
            var twiceArea = 0;
            var x1 = flatCoordinates[end - stride];
            var y1 = flatCoordinates[end - stride + 1];
            for (; offset < end; offset += stride) {
              var x2 = flatCoordinates[offset];
              var y2 = flatCoordinates[offset + 1];
              twiceArea += y1 * x2 - x1 * y2;
              x1 = x2;
              y1 = y2;
            }
            return twiceArea / 2;
          }
          function area_linearRings(flatCoordinates, offset, ends, stride) {
            var area = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              area += area_linearRing(flatCoordinates, offset, end, stride);
              offset = end;
            }
            return area;
          }
          function linearRingss(flatCoordinates, offset, endss, stride) {
            var area = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              area += area_linearRings(flatCoordinates, offset, ends, stride);
              offset = ends[ends.length - 1];
            }
            return area;
          }
          var LinearRing_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LinearRing_LinearRing = (
            /** @class */
            function(_super) {
              LinearRing_extends(LinearRing, _super);
              function LinearRing(coordinates, opt_layout) {
                var _this = _super.call(this) || this;
                _this.maxDelta_ = -1;
                _this.maxDeltaRevision_ = -1;
                if (opt_layout !== void 0 && !Array.isArray(coordinates[0])) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                } else {
                  _this.setCoordinates(
                    /** @type {Array<import("../coordinate.js").Coordinate>} */
                    coordinates,
                    opt_layout
                  );
                }
                return _this;
              }
              LinearRing.prototype.clone = function() {
                return new LinearRing(this.flatCoordinates.slice(), this.layout);
              };
              LinearRing.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                if (this.maxDeltaRevision_ != this.getRevision()) {
                  this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
                  this.maxDeltaRevision_ = this.getRevision();
                }
                return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
              };
              LinearRing.prototype.getArea = function() {
                return area_linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
              };
              LinearRing.prototype.getCoordinates = function() {
                return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
              };
              LinearRing.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                var simplifiedFlatCoordinates = [];
                simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
                return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
              };
              LinearRing.prototype.getType = function() {
                return geom_GeometryType.LINEAR_RING;
              };
              LinearRing.prototype.intersectsExtent = function(extent) {
                return false;
              };
              LinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 1);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
                this.changed();
              };
              return LinearRing;
            }(geom_SimpleGeometry)
          );
          var geom_LinearRing = LinearRing_LinearRing;
          var Point_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Point_Point = (
            /** @class */
            function(_super) {
              Point_extends(Point, _super);
              function Point(coordinates, opt_layout) {
                var _this = _super.call(this) || this;
                _this.setCoordinates(coordinates, opt_layout);
                return _this;
              }
              Point.prototype.clone = function() {
                var point = new Point(this.flatCoordinates.slice(), this.layout);
                point.applyProperties(this);
                return point;
              };
              Point.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                var flatCoordinates = this.flatCoordinates;
                var squaredDistance = math_squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
                if (squaredDistance < minSquaredDistance) {
                  var stride = this.stride;
                  for (var i = 0; i < stride; ++i) {
                    closestPoint[i] = flatCoordinates[i];
                  }
                  closestPoint.length = stride;
                  return squaredDistance;
                } else {
                  return minSquaredDistance;
                }
              };
              Point.prototype.getCoordinates = function() {
                return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
              };
              Point.prototype.computeExtent = function(extent) {
                return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
              };
              Point.prototype.getType = function() {
                return geom_GeometryType.POINT;
              };
              Point.prototype.intersectsExtent = function(extent) {
                return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
              };
              Point.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 0);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
                this.changed();
              };
              return Point;
            }(geom_SimpleGeometry)
          );
          var geom_Point = Point_Point;
          function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
            var outside = forEachCorner(
              extent,
              /**
               * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
               * @return {boolean} Contains (x, y).
               */
              function(coordinate) {
                return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
              }
            );
            return !outside;
          }
          function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
            var wn = 0;
            var x1 = flatCoordinates[end - stride];
            var y1 = flatCoordinates[end - stride + 1];
            for (; offset < end; offset += stride) {
              var x2 = flatCoordinates[offset];
              var y2 = flatCoordinates[offset + 1];
              if (y1 <= y) {
                if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                  wn++;
                }
              } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
                wn--;
              }
              x1 = x2;
              y1 = y2;
            }
            return wn !== 0;
          }
          function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
            if (ends.length === 0) {
              return false;
            }
            if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
              return false;
            }
            for (var i = 1, ii = ends.length; i < ii; ++i) {
              if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
                return false;
              }
            }
            return true;
          }
          function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
            if (endss.length === 0) {
              return false;
            }
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                return true;
              }
              offset = ends[ends.length - 1];
            }
            return false;
          }
          function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
            var i, ii, x, x1, x2, y1, y2;
            var y = flatCenters[flatCentersOffset + 1];
            var intersections = [];
            for (var r = 0, rr = ends.length; r < rr; ++r) {
              var end = ends[r];
              x1 = flatCoordinates[end - stride];
              y1 = flatCoordinates[end - stride + 1];
              for (i = offset; i < end; i += stride) {
                x2 = flatCoordinates[i];
                y2 = flatCoordinates[i + 1];
                if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                  x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                  intersections.push(x);
                }
                x1 = x2;
                y1 = y2;
              }
            }
            var pointX = NaN;
            var maxSegmentLength = -Infinity;
            intersections.sort(ol_array[
              "i"
              /* numberSafeCompareFunction */
            ]);
            x1 = intersections[0];
            for (i = 1, ii = intersections.length; i < ii; ++i) {
              x2 = intersections[i];
              var segmentLength = Math.abs(x2 - x1);
              if (segmentLength > maxSegmentLength) {
                x = (x1 + x2) / 2;
                if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                  pointX = x;
                  maxSegmentLength = segmentLength;
                }
              }
              x1 = x2;
            }
            if (isNaN(pointX)) {
              pointX = flatCenters[flatCentersOffset];
            }
            if (opt_dest) {
              opt_dest.push(pointX, y, maxSegmentLength);
              return opt_dest;
            } else {
              return [pointX, y, maxSegmentLength];
            }
          }
          function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
            var interiorPoints = [];
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
              offset = ends[ends.length - 1];
            }
            return interiorPoints;
          }
          function forEach(flatCoordinates, offset, end, stride, callback) {
            var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
            var point2 = [];
            var ret;
            for (; offset + stride < end; offset += stride) {
              point2[0] = flatCoordinates[offset + stride];
              point2[1] = flatCoordinates[offset + stride + 1];
              ret = callback(point1, point2);
              if (ret) {
                return ret;
              }
              point1[0] = point2[0];
              point1[1] = point2[1];
            }
            return false;
          }
          function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
            var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
            if (!extent_intersects(extent, coordinatesExtent)) {
              return false;
            }
            if (containsExtent(extent, coordinatesExtent)) {
              return true;
            }
            if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
              return true;
            }
            if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
              return true;
            }
            return forEach(
              flatCoordinates,
              offset,
              end,
              stride,
              /**
               * @param {import("../../coordinate.js").Coordinate} point1 Start point.
               * @param {import("../../coordinate.js").Coordinate} point2 End point.
               * @return {boolean} `true` if the segment and the extent intersect,
               *     `false` otherwise.
               */
              function(point1, point2) {
                return intersectsSegment(extent, point1, point2);
              }
            );
          }
          function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
                return true;
              }
              offset = ends[i];
            }
            return false;
          }
          function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
            if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
              return true;
            }
            if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
              return true;
            }
            if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
              return true;
            }
            if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
              return true;
            }
            if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
              return true;
            }
            return false;
          }
          function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
            if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
              return false;
            }
            if (ends.length === 1) {
              return true;
            }
            for (var i = 1, ii = ends.length; i < ii; ++i) {
              if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                  return false;
                }
              }
            }
            return true;
          }
          function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
                return true;
              }
              offset = ends[ends.length - 1];
            }
            return false;
          }
          function reverse_coordinates(flatCoordinates, offset, end, stride) {
            while (offset < end - stride) {
              for (var i = 0; i < stride; ++i) {
                var tmp = flatCoordinates[offset + i];
                flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
                flatCoordinates[end - stride + i] = tmp;
              }
              offset += stride;
              end -= stride;
            }
          }
          function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
            var edge = 0;
            var x1 = flatCoordinates[end - stride];
            var y1 = flatCoordinates[end - stride + 1];
            for (; offset < end; offset += stride) {
              var x2 = flatCoordinates[offset];
              var y2 = flatCoordinates[offset + 1];
              edge += (x2 - x1) * (y2 + y1);
              x1 = x2;
              y1 = y2;
            }
            return edge === 0 ? void 0 : edge > 0;
          }
          function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
            var right = opt_right !== void 0 ? opt_right : false;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
              if (i === 0) {
                if (right && isClockwise || !right && !isClockwise) {
                  return false;
                }
              } else {
                if (right && !isClockwise || !right && isClockwise) {
                  return false;
                }
              }
              offset = end;
            }
            return true;
          }
          function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
                return false;
              }
              if (ends.length) {
                offset = ends[ends.length - 1];
              }
            }
            return true;
          }
          function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
            var right = opt_right !== void 0 ? opt_right : false;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
              var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
              if (reverse) {
                reverse_coordinates(flatCoordinates, offset, end, stride);
              }
              offset = end;
            }
            return offset;
          }
          function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
            }
            return offset;
          }
          var Polygon_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Polygon_Polygon = (
            /** @class */
            function(_super) {
              Polygon_extends(Polygon, _super);
              function Polygon(coordinates, opt_layout, opt_ends) {
                var _this = _super.call(this) || this;
                _this.ends_ = [];
                _this.flatInteriorPointRevision_ = -1;
                _this.flatInteriorPoint_ = null;
                _this.maxDelta_ = -1;
                _this.maxDeltaRevision_ = -1;
                _this.orientedRevision_ = -1;
                _this.orientedFlatCoordinates_ = null;
                if (opt_layout !== void 0 && opt_ends) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                  _this.ends_ = opt_ends;
                } else {
                  _this.setCoordinates(
                    /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
                    coordinates,
                    opt_layout
                  );
                }
                return _this;
              }
              Polygon.prototype.appendLinearRing = function(linearRing) {
                if (!this.flatCoordinates) {
                  this.flatCoordinates = linearRing.getFlatCoordinates().slice();
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(this.flatCoordinates, linearRing.getFlatCoordinates());
                }
                this.ends_.push(this.flatCoordinates.length);
                this.changed();
              };
              Polygon.prototype.clone = function() {
                var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
                polygon.applyProperties(this);
                return polygon;
              };
              Polygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                if (this.maxDeltaRevision_ != this.getRevision()) {
                  this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
                  this.maxDeltaRevision_ = this.getRevision();
                }
                return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
              };
              Polygon.prototype.containsXY = function(x, y) {
                return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
              };
              Polygon.prototype.getArea = function() {
                return area_linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
              };
              Polygon.prototype.getCoordinates = function(opt_right) {
                var flatCoordinates;
                if (opt_right !== void 0) {
                  flatCoordinates = this.getOrientedFlatCoordinates().slice();
                  orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
                } else {
                  flatCoordinates = this.flatCoordinates;
                }
                return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
              };
              Polygon.prototype.getEnds = function() {
                return this.ends_;
              };
              Polygon.prototype.getFlatInteriorPoint = function() {
                if (this.flatInteriorPointRevision_ != this.getRevision()) {
                  var flatCenter = extent_getCenter(this.getExtent());
                  this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
                  this.flatInteriorPointRevision_ = this.getRevision();
                }
                return this.flatInteriorPoint_;
              };
              Polygon.prototype.getInteriorPoint = function() {
                return new geom_Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
              };
              Polygon.prototype.getLinearRingCount = function() {
                return this.ends_.length;
              };
              Polygon.prototype.getLinearRing = function(index) {
                if (index < 0 || this.ends_.length <= index) {
                  return null;
                }
                return new geom_LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
              };
              Polygon.prototype.getLinearRings = function() {
                var layout = this.layout;
                var flatCoordinates = this.flatCoordinates;
                var ends = this.ends_;
                var linearRings = [];
                var offset = 0;
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  var end = ends[i];
                  var linearRing = new geom_LinearRing(flatCoordinates.slice(offset, end), layout);
                  linearRings.push(linearRing);
                  offset = end;
                }
                return linearRings;
              };
              Polygon.prototype.getOrientedFlatCoordinates = function() {
                if (this.orientedRevision_ != this.getRevision()) {
                  var flatCoordinates = this.flatCoordinates;
                  if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                    this.orientedFlatCoordinates_ = flatCoordinates;
                  } else {
                    this.orientedFlatCoordinates_ = flatCoordinates.slice();
                    this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
                  }
                  this.orientedRevision_ = this.getRevision();
                }
                return this.orientedFlatCoordinates_;
              };
              Polygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                var simplifiedFlatCoordinates = [];
                var simplifiedEnds = [];
                simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
                return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
              };
              Polygon.prototype.getType = function() {
                return geom_GeometryType.POLYGON;
              };
              Polygon.prototype.intersectsExtent = function(extent) {
                return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
              };
              Polygon.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 2);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
                this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
                this.changed();
              };
              return Polygon;
            }(geom_SimpleGeometry)
          );
          var geom_Polygon = Polygon_Polygon;
          function circular(center, radius, opt_n, opt_sphereRadius) {
            var n = opt_n ? opt_n : 32;
            var flatCoordinates = [];
            for (var i = 0; i < n; ++i) {
              Object(ol_array[
                "c"
                /* extend */
              ])(flatCoordinates, sphere_offset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
            }
            flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
            return new Polygon_Polygon(flatCoordinates, GeometryLayout.XY, [
              flatCoordinates.length
            ]);
          }
          function fromExtent(extent) {
            var minX = extent[0];
            var minY = extent[1];
            var maxX = extent[2];
            var maxY = extent[3];
            var flatCoordinates = [
              minX,
              minY,
              minX,
              maxY,
              maxX,
              maxY,
              maxX,
              minY,
              minX,
              minY
            ];
            return new Polygon_Polygon(flatCoordinates, GeometryLayout.XY, [
              flatCoordinates.length
            ]);
          }
          function fromCircle(circle, opt_sides, opt_angle) {
            var sides = opt_sides ? opt_sides : 32;
            var stride = circle.getStride();
            var layout = circle.getLayout();
            var center = circle.getCenter();
            var arrayLength = stride * (sides + 1);
            var flatCoordinates = new Array(arrayLength);
            for (var i = 0; i < arrayLength; i += stride) {
              flatCoordinates[i] = 0;
              flatCoordinates[i + 1] = 0;
              for (var j = 2; j < stride; j++) {
                flatCoordinates[i + j] = center[j];
              }
            }
            var ends = [flatCoordinates.length];
            var polygon = new Polygon_Polygon(flatCoordinates, layout, ends);
            makeRegular(polygon, center, circle.getRadius(), opt_angle);
            return polygon;
          }
          function makeRegular(polygon, center, radius, opt_angle) {
            var flatCoordinates = polygon.getFlatCoordinates();
            var stride = polygon.getStride();
            var sides = flatCoordinates.length / stride - 1;
            var startAngle = opt_angle ? opt_angle : 0;
            for (var i = 0; i <= sides; ++i) {
              var offset = i * stride;
              var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;
              flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
              flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
            }
            polygon.changed();
          }
          var View_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DEFAULT_MIN_ZOOM = 0;
          var View_View = (
            /** @class */
            function(_super) {
              View_extends(View, _super);
              function View(opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var options = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, opt_options);
                _this.hints_ = [0, 0];
                _this.animations_ = [];
                _this.updateAnimationKey_;
                _this.projection_ = createProjection(options.projection, "EPSG:3857");
                _this.viewportSize_ = [100, 100];
                _this.targetCenter_ = null;
                _this.targetResolution_;
                _this.targetRotation_;
                _this.cancelAnchor_ = void 0;
                if (options.center) {
                  options.center = fromUserCoordinate(options.center, _this.projection_);
                }
                if (options.extent) {
                  options.extent = fromUserExtent(options.extent, _this.projection_);
                }
                _this.applyOptions_(options);
                return _this;
              }
              View.prototype.applyOptions_ = function(options) {
                var properties = {};
                var resolutionConstraintInfo = createResolutionConstraint(options);
                this.maxResolution_ = resolutionConstraintInfo.maxResolution;
                this.minResolution_ = resolutionConstraintInfo.minResolution;
                this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
                this.resolutions_ = options.resolutions;
                this.padding_ = options.padding;
                this.minZoom_ = resolutionConstraintInfo.minZoom;
                var centerConstraint = createCenterConstraint(options);
                var resolutionConstraint = resolutionConstraintInfo.constraint;
                var rotationConstraint = createRotationConstraint(options);
                this.constraints_ = {
                  center: centerConstraint,
                  resolution: resolutionConstraint,
                  rotation: rotationConstraint
                };
                this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
                this.setCenterInternal(options.center !== void 0 ? options.center : null);
                if (options.resolution !== void 0) {
                  this.setResolution(options.resolution);
                } else if (options.zoom !== void 0) {
                  this.setZoom(options.zoom);
                }
                this.setProperties(properties);
                this.options_ = options;
              };
              Object.defineProperty(View.prototype, "padding", {
                /**
                 * Padding (in css pixels).
                 * If the map viewport is partially covered with other content (overlays) along
                 * its edges, this setting allows to shift the center of the viewport away from that
                 * content. The order of the values in the array is top, right, bottom, left.
                 * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
                 * @type {Array<number>|undefined}
                 * @api
                 */
                get: function() {
                  return this.padding_;
                },
                set: function(padding) {
                  var oldPadding = this.padding_;
                  this.padding_ = padding;
                  var center = this.getCenter();
                  if (center) {
                    var newPadding = padding || [0, 0, 0, 0];
                    oldPadding = oldPadding || [0, 0, 0, 0];
                    var resolution = this.getResolution();
                    var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
                    var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
                    this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
                  }
                },
                enumerable: false,
                configurable: true
              });
              View.prototype.getUpdatedOptions_ = function(newOptions) {
                var options = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, this.options_);
                if (options.resolution !== void 0) {
                  options.resolution = this.getResolution();
                } else {
                  options.zoom = this.getZoom();
                }
                options.center = this.getCenterInternal();
                options.rotation = this.getRotation();
                return Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options, newOptions);
              };
              View.prototype.animate = function(var_args) {
                if (this.isDef() && !this.getAnimating()) {
                  this.resolveConstraints(0);
                }
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; ++i) {
                  var options = arguments[i];
                  if (options.center) {
                    options = Object(ol_obj[
                      "a"
                      /* assign */
                    ])({}, options);
                    options.center = fromUserCoordinate(options.center, this.getProjection());
                  }
                  if (options.anchor) {
                    options = Object(ol_obj[
                      "a"
                      /* assign */
                    ])({}, options);
                    options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
                  }
                  args[i] = options;
                }
                this.animateInternal.apply(this, args);
              };
              View.prototype.animateInternal = function(var_args) {
                var animationCount = arguments.length;
                var callback;
                if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
                  callback = arguments[animationCount - 1];
                  --animationCount;
                }
                if (!this.isDef()) {
                  var state = arguments[animationCount - 1];
                  if (state.center) {
                    this.setCenterInternal(state.center);
                  }
                  if (state.zoom !== void 0) {
                    this.setZoom(state.zoom);
                  }
                  if (state.rotation !== void 0) {
                    this.setRotation(state.rotation);
                  }
                  if (callback) {
                    animationCallback(callback, true);
                  }
                  return;
                }
                var start = Date.now();
                var center = this.targetCenter_.slice();
                var resolution = this.targetResolution_;
                var rotation = this.targetRotation_;
                var series = [];
                for (var i = 0; i < animationCount; ++i) {
                  var options = (
                    /** @type {AnimationOptions} */
                    arguments[i]
                  );
                  var animation = {
                    start,
                    complete: false,
                    anchor: options.anchor,
                    duration: options.duration !== void 0 ? options.duration : 1e3,
                    easing: options.easing || inAndOut,
                    callback
                  };
                  if (options.center) {
                    animation.sourceCenter = center;
                    animation.targetCenter = options.center.slice();
                    center = animation.targetCenter;
                  }
                  if (options.zoom !== void 0) {
                    animation.sourceResolution = resolution;
                    animation.targetResolution = this.getResolutionForZoom(options.zoom);
                    resolution = animation.targetResolution;
                  } else if (options.resolution) {
                    animation.sourceResolution = resolution;
                    animation.targetResolution = options.resolution;
                    resolution = animation.targetResolution;
                  }
                  if (options.rotation !== void 0) {
                    animation.sourceRotation = rotation;
                    var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                    animation.targetRotation = rotation + delta;
                    rotation = animation.targetRotation;
                  }
                  if (isNoopAnimation(animation)) {
                    animation.complete = true;
                  } else {
                    start += animation.duration;
                  }
                  series.push(animation);
                }
                this.animations_.push(series);
                this.setHint(ViewHint.ANIMATING, 1);
                this.updateAnimations_();
              };
              View.prototype.getAnimating = function() {
                return this.hints_[ViewHint.ANIMATING] > 0;
              };
              View.prototype.getInteracting = function() {
                return this.hints_[ViewHint.INTERACTING] > 0;
              };
              View.prototype.cancelAnimations = function() {
                this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
                var anchor;
                for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
                  var series = this.animations_[i];
                  if (series[0].callback) {
                    animationCallback(series[0].callback, false);
                  }
                  if (!anchor) {
                    for (var j = 0, jj = series.length; j < jj; ++j) {
                      var animation = series[j];
                      if (!animation.complete) {
                        anchor = animation.anchor;
                        break;
                      }
                    }
                  }
                }
                this.animations_.length = 0;
                this.cancelAnchor_ = anchor;
              };
              View.prototype.updateAnimations_ = function() {
                if (this.updateAnimationKey_ !== void 0) {
                  cancelAnimationFrame(this.updateAnimationKey_);
                  this.updateAnimationKey_ = void 0;
                }
                if (!this.getAnimating()) {
                  return;
                }
                var now = Date.now();
                var more = false;
                for (var i = this.animations_.length - 1; i >= 0; --i) {
                  var series = this.animations_[i];
                  var seriesComplete = true;
                  for (var j = 0, jj = series.length; j < jj; ++j) {
                    var animation = series[j];
                    if (animation.complete) {
                      continue;
                    }
                    var elapsed = now - animation.start;
                    var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                    if (fraction >= 1) {
                      animation.complete = true;
                      fraction = 1;
                    } else {
                      seriesComplete = false;
                    }
                    var progress = animation.easing(fraction);
                    if (animation.sourceCenter) {
                      var x0 = animation.sourceCenter[0];
                      var y0 = animation.sourceCenter[1];
                      var x1 = animation.targetCenter[0];
                      var y1 = animation.targetCenter[1];
                      var x = x0 + progress * (x1 - x0);
                      var y = y0 + progress * (y1 - y0);
                      this.targetCenter_ = [x, y];
                    }
                    if (animation.sourceResolution && animation.targetResolution) {
                      var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                      if (animation.anchor) {
                        var size = this.getViewportSize_(this.getRotation());
                        var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                      }
                      this.targetResolution_ = resolution;
                      this.applyTargetState_(true);
                    }
                    if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
                      var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                      if (animation.anchor) {
                        var constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                      }
                      this.targetRotation_ = rotation;
                    }
                    this.applyTargetState_(true);
                    more = true;
                    if (!animation.complete) {
                      break;
                    }
                  }
                  if (seriesComplete) {
                    this.animations_[i] = null;
                    this.setHint(ViewHint.ANIMATING, -1);
                    var callback = series[0].callback;
                    if (callback) {
                      animationCallback(callback, true);
                    }
                  }
                }
                this.animations_ = this.animations_.filter(Boolean);
                if (more && this.updateAnimationKey_ === void 0) {
                  this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
                }
              };
              View.prototype.calculateCenterRotate = function(rotation, anchor) {
                var center;
                var currentCenter = this.getCenterInternal();
                if (currentCenter !== void 0) {
                  center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
                  coordinate_rotate(center, rotation - this.getRotation());
                  coordinate_add(center, anchor);
                }
                return center;
              };
              View.prototype.calculateCenterZoom = function(resolution, anchor) {
                var center;
                var currentCenter = this.getCenterInternal();
                var currentResolution = this.getResolution();
                if (currentCenter !== void 0 && currentResolution !== void 0) {
                  var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
                  var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
                  center = [x, y];
                }
                return center;
              };
              View.prototype.getViewportSize_ = function(opt_rotation) {
                var size = this.viewportSize_;
                if (opt_rotation) {
                  var w = size[0];
                  var h = size[1];
                  return [
                    Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)),
                    Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))
                  ];
                } else {
                  return size;
                }
              };
              View.prototype.setViewportSize = function(opt_size) {
                this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
                if (!this.getAnimating()) {
                  this.resolveConstraints(0);
                }
              };
              View.prototype.getCenter = function() {
                var center = this.getCenterInternal();
                if (!center) {
                  return center;
                }
                return toUserCoordinate(center, this.getProjection());
              };
              View.prototype.getCenterInternal = function() {
                return (
                  /** @type {import("./coordinate.js").Coordinate|undefined} */
                  this.get(ViewProperty.CENTER)
                );
              };
              View.prototype.getConstraints = function() {
                return this.constraints_;
              };
              View.prototype.getConstrainResolution = function() {
                return this.options_.constrainResolution;
              };
              View.prototype.getHints = function(opt_hints) {
                if (opt_hints !== void 0) {
                  opt_hints[0] = this.hints_[0];
                  opt_hints[1] = this.hints_[1];
                  return opt_hints;
                } else {
                  return this.hints_.slice();
                }
              };
              View.prototype.calculateExtent = function(opt_size) {
                var extent = this.calculateExtentInternal(opt_size);
                return toUserExtent(extent, this.getProjection());
              };
              View.prototype.calculateExtentInternal = function(opt_size) {
                var size = opt_size || this.getViewportSizeMinusPadding_();
                var center = (
                  /** @type {!import("./coordinate.js").Coordinate} */
                  this.getCenterInternal()
                );
                assert2(center, 1);
                var resolution = (
                  /** @type {!number} */
                  this.getResolution()
                );
                assert2(resolution !== void 0, 2);
                var rotation = (
                  /** @type {!number} */
                  this.getRotation()
                );
                assert2(rotation !== void 0, 3);
                return getForViewAndSize(center, resolution, rotation, size);
              };
              View.prototype.getMaxResolution = function() {
                return this.maxResolution_;
              };
              View.prototype.getMinResolution = function() {
                return this.minResolution_;
              };
              View.prototype.getMaxZoom = function() {
                return (
                  /** @type {number} */
                  this.getZoomForResolution(this.minResolution_)
                );
              };
              View.prototype.setMaxZoom = function(zoom) {
                this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
              };
              View.prototype.getMinZoom = function() {
                return (
                  /** @type {number} */
                  this.getZoomForResolution(this.maxResolution_)
                );
              };
              View.prototype.setMinZoom = function(zoom) {
                this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
              };
              View.prototype.setConstrainResolution = function(enabled) {
                this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
              };
              View.prototype.getProjection = function() {
                return this.projection_;
              };
              View.prototype.getResolution = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(ViewProperty.RESOLUTION)
                );
              };
              View.prototype.getResolutions = function() {
                return this.resolutions_;
              };
              View.prototype.getResolutionForExtent = function(extent, opt_size) {
                return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
              };
              View.prototype.getResolutionForExtentInternal = function(extent, opt_size) {
                var size = opt_size || this.getViewportSizeMinusPadding_();
                var xResolution = getWidth(extent) / size[0];
                var yResolution = getHeight(extent) / size[1];
                return Math.max(xResolution, yResolution);
              };
              View.prototype.getResolutionForValueFunction = function(opt_power) {
                var power = opt_power || 2;
                var maxResolution = this.getConstrainedResolution(this.maxResolution_);
                var minResolution = this.minResolution_;
                var max = Math.log(maxResolution / minResolution) / Math.log(power);
                return (
                  /**
                   * @param {number} value Value.
                   * @return {number} Resolution.
                   */
                  function(value) {
                    var resolution = maxResolution / Math.pow(power, value * max);
                    return resolution;
                  }
                );
              };
              View.prototype.getRotation = function() {
                return (
                  /** @type {number} */
                  this.get(ViewProperty.ROTATION)
                );
              };
              View.prototype.getValueForResolutionFunction = function(opt_power) {
                var logPower = Math.log(opt_power || 2);
                var maxResolution = this.getConstrainedResolution(this.maxResolution_);
                var minResolution = this.minResolution_;
                var max = Math.log(maxResolution / minResolution) / logPower;
                return (
                  /**
                   * @param {number} resolution Resolution.
                   * @return {number} Value.
                   */
                  function(resolution) {
                    var value = Math.log(maxResolution / resolution) / logPower / max;
                    return value;
                  }
                );
              };
              View.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
                var size = this.getViewportSize_(opt_rotation);
                var padding = this.padding_;
                if (padding) {
                  size = [
                    size[0] - padding[1] - padding[3],
                    size[1] - padding[0] - padding[2]
                  ];
                }
                return size;
              };
              View.prototype.getState = function() {
                var projection = this.getProjection();
                var resolution = (
                  /** @type {number} */
                  this.getResolution()
                );
                var rotation = this.getRotation();
                var center = (
                  /** @type {import("./coordinate.js").Coordinate} */
                  this.getCenterInternal()
                );
                var padding = this.padding_;
                if (padding) {
                  var reducedSize = this.getViewportSizeMinusPadding_();
                  center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
                }
                return {
                  center: center.slice(0),
                  projection: projection !== void 0 ? projection : null,
                  resolution,
                  rotation,
                  zoom: this.getZoom()
                };
              };
              View.prototype.getZoom = function() {
                var zoom;
                var resolution = this.getResolution();
                if (resolution !== void 0) {
                  zoom = this.getZoomForResolution(resolution);
                }
                return zoom;
              };
              View.prototype.getZoomForResolution = function(resolution) {
                var offset = this.minZoom_ || 0;
                var max, zoomFactor;
                if (this.resolutions_) {
                  var nearest = Object(ol_array[
                    "h"
                    /* linearFindNearest */
                  ])(this.resolutions_, resolution, 1);
                  offset = nearest;
                  max = this.resolutions_[nearest];
                  if (nearest == this.resolutions_.length - 1) {
                    zoomFactor = 2;
                  } else {
                    zoomFactor = max / this.resolutions_[nearest + 1];
                  }
                } else {
                  max = this.maxResolution_;
                  zoomFactor = this.zoomFactor_;
                }
                return offset + Math.log(max / resolution) / Math.log(zoomFactor);
              };
              View.prototype.getResolutionForZoom = function(zoom) {
                if (this.resolutions_) {
                  if (this.resolutions_.length <= 1) {
                    return 0;
                  }
                  var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
                  var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
                  return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
                } else {
                  return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
                }
              };
              View.prototype.fit = function(geometryOrExtent, opt_options) {
                var geometry;
                assert2(Array.isArray(geometryOrExtent) || typeof /** @type {?} */
                geometryOrExtent.getSimplifiedGeometry === "function", 24);
                if (Array.isArray(geometryOrExtent)) {
                  assert2(!extent_isEmpty(geometryOrExtent), 25);
                  var extent = fromUserExtent(geometryOrExtent, this.getProjection());
                  geometry = fromExtent(extent);
                } else if (geometryOrExtent.getType() === geom_GeometryType.CIRCLE) {
                  var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
                  geometry = fromExtent(extent);
                  geometry.rotate(this.getRotation(), extent_getCenter(extent));
                } else {
                  var userProjection = getUserProjection();
                  if (userProjection) {
                    geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
                    geometryOrExtent.clone().transform(userProjection, this.getProjection());
                  } else {
                    geometry = geometryOrExtent;
                  }
                }
                this.fitInternal(geometry, opt_options);
              };
              View.prototype.rotatedExtentForGeometry = function(geometry) {
                var rotation = this.getRotation();
                var cosAngle = Math.cos(rotation);
                var sinAngle = Math.sin(-rotation);
                var coords = geometry.getFlatCoordinates();
                var stride = geometry.getStride();
                var minRotX = Infinity;
                var minRotY = Infinity;
                var maxRotX = -Infinity;
                var maxRotY = -Infinity;
                for (var i = 0, ii = coords.length; i < ii; i += stride) {
                  var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
                  var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
                  minRotX = Math.min(minRotX, rotX);
                  minRotY = Math.min(minRotY, rotY);
                  maxRotX = Math.max(maxRotX, rotX);
                  maxRotY = Math.max(maxRotY, rotY);
                }
                return [minRotX, minRotY, maxRotX, maxRotY];
              };
              View.prototype.fitInternal = function(geometry, opt_options) {
                var options = opt_options || {};
                var size = options.size;
                if (!size) {
                  size = this.getViewportSizeMinusPadding_();
                }
                var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
                var nearest = options.nearest !== void 0 ? options.nearest : false;
                var minResolution;
                if (options.minResolution !== void 0) {
                  minResolution = options.minResolution;
                } else if (options.maxZoom !== void 0) {
                  minResolution = this.getResolutionForZoom(options.maxZoom);
                } else {
                  minResolution = 0;
                }
                var rotatedExtent = this.rotatedExtentForGeometry(geometry);
                var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
                  size[0] - padding[1] - padding[3],
                  size[1] - padding[0] - padding[2]
                ]);
                resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
                resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
                var rotation = this.getRotation();
                var sinAngle = Math.sin(rotation);
                var cosAngle = Math.cos(rotation);
                var centerRot = extent_getCenter(rotatedExtent);
                centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
                centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
                var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
                var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
                var center = this.getConstrainedCenter([centerX, centerY], resolution);
                var callback = options.callback ? options.callback : functions[
                  "c"
                  /* VOID */
                ];
                if (options.duration !== void 0) {
                  this.animateInternal({
                    resolution,
                    center,
                    duration: options.duration,
                    easing: options.easing
                  }, callback);
                } else {
                  this.targetResolution_ = resolution;
                  this.targetCenter_ = center;
                  this.applyTargetState_(false, true);
                  animationCallback(callback, true);
                }
              };
              View.prototype.centerOn = function(coordinate, size, position) {
                this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
              };
              View.prototype.centerOnInternal = function(coordinate, size, position) {
                this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
              };
              View.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
                var centerShift;
                var padding = this.padding_;
                if (padding && center) {
                  var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
                  var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
                  centerShift = [
                    center[0] - shiftedCenter[0],
                    center[1] - shiftedCenter[1]
                  ];
                }
                return centerShift;
              };
              View.prototype.isDef = function() {
                return !!this.getCenterInternal() && this.getResolution() !== void 0;
              };
              View.prototype.adjustCenter = function(deltaCoordinates) {
                var center = toUserCoordinate(this.targetCenter_, this.getProjection());
                this.setCenter([
                  center[0] + deltaCoordinates[0],
                  center[1] + deltaCoordinates[1]
                ]);
              };
              View.prototype.adjustCenterInternal = function(deltaCoordinates) {
                var center = this.targetCenter_;
                this.setCenterInternal([
                  center[0] + deltaCoordinates[0],
                  center[1] + deltaCoordinates[1]
                ]);
              };
              View.prototype.adjustResolution = function(ratio, opt_anchor) {
                var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
                this.adjustResolutionInternal(ratio, anchor);
              };
              View.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
                var isMoving = this.getAnimating() || this.getInteracting();
                var size = this.getViewportSize_(this.getRotation());
                var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
                if (opt_anchor) {
                  this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
                }
                this.targetResolution_ *= ratio;
                this.applyTargetState_();
              };
              View.prototype.adjustZoom = function(delta, opt_anchor) {
                this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
              };
              View.prototype.adjustRotation = function(delta, opt_anchor) {
                if (opt_anchor) {
                  opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
                }
                this.adjustRotationInternal(delta, opt_anchor);
              };
              View.prototype.adjustRotationInternal = function(delta, opt_anchor) {
                var isMoving = this.getAnimating() || this.getInteracting();
                var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
                if (opt_anchor) {
                  this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
                }
                this.targetRotation_ += delta;
                this.applyTargetState_();
              };
              View.prototype.setCenter = function(center) {
                this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
              };
              View.prototype.setCenterInternal = function(center) {
                this.targetCenter_ = center;
                this.applyTargetState_();
              };
              View.prototype.setHint = function(hint, delta) {
                this.hints_[hint] += delta;
                this.changed();
                return this.hints_[hint];
              };
              View.prototype.setResolution = function(resolution) {
                this.targetResolution_ = resolution;
                this.applyTargetState_();
              };
              View.prototype.setRotation = function(rotation) {
                this.targetRotation_ = rotation;
                this.applyTargetState_();
              };
              View.prototype.setZoom = function(zoom) {
                this.setResolution(this.getResolutionForZoom(zoom));
              };
              View.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
                var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
                var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
                var size = this.getViewportSize_(newRotation);
                var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
                var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
                if (this.get(ViewProperty.ROTATION) !== newRotation) {
                  this.set(ViewProperty.ROTATION, newRotation);
                }
                if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
                  this.set(ViewProperty.RESOLUTION, newResolution);
                }
                if (!this.get(ViewProperty.CENTER) || !coordinate_equals(this.get(ViewProperty.CENTER), newCenter)) {
                  this.set(ViewProperty.CENTER, newCenter);
                }
                if (this.getAnimating() && !opt_doNotCancelAnims) {
                  this.cancelAnimations();
                }
                this.cancelAnchor_ = void 0;
              };
              View.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
                var duration = opt_duration !== void 0 ? opt_duration : 200;
                var direction = opt_resolutionDirection || 0;
                var newRotation = this.constraints_.rotation(this.targetRotation_);
                var size = this.getViewportSize_(newRotation);
                var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
                var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
                if (duration === 0 && !this.cancelAnchor_) {
                  this.targetResolution_ = newResolution;
                  this.targetRotation_ = newRotation;
                  this.targetCenter_ = newCenter;
                  this.applyTargetState_();
                  return;
                }
                var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
                this.cancelAnchor_ = void 0;
                if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !coordinate_equals(this.getCenterInternal(), newCenter)) {
                  if (this.getAnimating()) {
                    this.cancelAnimations();
                  }
                  this.animateInternal({
                    rotation: newRotation,
                    center: newCenter,
                    resolution: newResolution,
                    duration,
                    easing: easeOut,
                    anchor
                  });
                }
              };
              View.prototype.beginInteraction = function() {
                this.resolveConstraints(0);
                this.setHint(ViewHint.INTERACTING, 1);
              };
              View.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
                var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
                this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
              };
              View.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
                this.setHint(ViewHint.INTERACTING, -1);
                this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
              };
              View.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
                var size = this.getViewportSize_(this.getRotation());
                return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
              };
              View.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
                var targetRes = this.getResolutionForZoom(targetZoom);
                return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
              };
              View.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
                var direction = opt_direction || 0;
                var size = this.getViewportSize_(this.getRotation());
                return this.constraints_.resolution(targetResolution, direction, size);
              };
              return View;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          function animationCallback(callback, returnValue) {
            setTimeout(function() {
              callback(returnValue);
            }, 0);
          }
          function createCenterConstraint(options) {
            if (options.extent !== void 0) {
              var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
              return createExtent(options.extent, options.constrainOnlyCenter, smooth);
            }
            var projection = createProjection(options.projection, "EPSG:3857");
            if (options.multiWorld !== true && projection.isGlobal()) {
              var extent = projection.getExtent().slice();
              extent[0] = -Infinity;
              extent[2] = Infinity;
              return createExtent(extent, false, false);
            }
            return none;
          }
          function createResolutionConstraint(options) {
            var resolutionConstraint;
            var maxResolution;
            var minResolution;
            var defaultMaxZoom = 28;
            var defaultZoomFactor = 2;
            var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
            var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
            var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
            var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
            var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
            var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
            var projection = createProjection(options.projection, "EPSG:3857");
            var projExtent = projection.getExtent();
            var constrainOnlyCenter = options.constrainOnlyCenter;
            var extent = options.extent;
            if (!multiWorld && !extent && projection.isGlobal()) {
              constrainOnlyCenter = false;
              extent = projExtent;
            }
            if (options.resolutions !== void 0) {
              var resolutions = options.resolutions;
              maxResolution = resolutions[minZoom];
              minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
              if (options.constrainResolution) {
                resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
              } else {
                resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
              }
            } else {
              var size = !projExtent ? (
                // use an extent that can fit the whole world if need be
                360 * METERS_PER_UNIT[proj_Units.DEGREES] / projection.getMetersPerUnit()
              ) : Math.max(getWidth(projExtent), getHeight(projExtent));
              var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
              var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
              maxResolution = options.maxResolution;
              if (maxResolution !== void 0) {
                minZoom = 0;
              } else {
                maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
              }
              minResolution = options.minResolution;
              if (minResolution === void 0) {
                if (options.maxZoom !== void 0) {
                  if (options.maxResolution !== void 0) {
                    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                  } else {
                    minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                  }
                } else {
                  minResolution = defaultMinResolution;
                }
              }
              maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
              minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
              if (options.constrainResolution) {
                resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
              } else {
                resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
              }
            }
            return {
              constraint: resolutionConstraint,
              maxResolution,
              minResolution,
              minZoom,
              zoomFactor
            };
          }
          function createRotationConstraint(options) {
            var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
            if (enableRotation) {
              var constrainRotation = options.constrainRotation;
              if (constrainRotation === void 0 || constrainRotation === true) {
                return createSnapToZero();
              } else if (constrainRotation === false) {
                return rotationconstraint_none;
              } else if (typeof constrainRotation === "number") {
                return createSnapToN(constrainRotation);
              } else {
                return rotationconstraint_none;
              }
            } else {
              return disable;
            }
          }
          function isNoopAnimation(animation) {
            if (animation.sourceCenter && animation.targetCenter) {
              if (!coordinate_equals(animation.sourceCenter, animation.targetCenter)) {
                return false;
              }
            }
            if (animation.sourceResolution !== animation.targetResolution) {
              return false;
            }
            if (animation.sourceRotation !== animation.targetRotation) {
              return false;
            }
            return true;
          }
          function calculateCenterOn(coordinate, size, position, resolution, rotation) {
            var cosAngle = Math.cos(-rotation);
            var sinAngle = Math.sin(-rotation);
            var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
            var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
            rotX += (size[0] / 2 - position[0]) * resolution;
            rotY += (position[1] - size[1] / 2) * resolution;
            sinAngle = -sinAngle;
            var centerX = rotX * cosAngle - rotY * sinAngle;
            var centerY = rotY * cosAngle + rotX * sinAngle;
            return [centerX, centerY];
          }
          var ol_View = View_View;
          function size_buffer(size, num, opt_size) {
            if (opt_size === void 0) {
              opt_size = [0, 0];
            }
            opt_size[0] = size[0] + 2 * num;
            opt_size[1] = size[1] + 2 * num;
            return opt_size;
          }
          function hasArea(size) {
            return size[0] > 0 && size[1] > 0;
          }
          function size_scale(size, ratio, opt_size) {
            if (opt_size === void 0) {
              opt_size = [0, 0];
            }
            opt_size[0] = size[0] * ratio + 0.5 | 0;
            opt_size[1] = size[1] * ratio + 0.5 | 0;
            return opt_size;
          }
          function toSize(size, opt_size) {
            if (Array.isArray(size)) {
              return size;
            } else {
              if (opt_size === void 0) {
                opt_size = [size, size];
              } else {
                opt_size[0] = size;
                opt_size[1] = size;
              }
              return opt_size;
            }
          }
          var PluggableMap_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var PluggableMap_PluggableMap = (
            /** @class */
            function(_super) {
              PluggableMap_extends(PluggableMap, _super);
              function PluggableMap(options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var optionsInternal = createOptionsInternal(options);
                _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
                _this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
                _this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : has[
                  "a"
                  /* DEVICE_PIXEL_RATIO */
                ];
                _this.postRenderTimeoutHandle_;
                _this.animationDelayKey_;
                _this.animationDelay_ = /** @this {PluggableMap} */
                (function() {
                  this.animationDelayKey_ = void 0;
                  this.renderFrame_(Date.now());
                }).bind(_this);
                _this.coordinateToPixelTransform_ = create();
                _this.pixelToCoordinateTransform_ = create();
                _this.frameIndex_ = 0;
                _this.frameState_ = null;
                _this.previousExtent_ = null;
                _this.viewPropertyListenerKey_ = null;
                _this.viewChangeListenerKey_ = null;
                _this.layerGroupPropertyListenerKeys_ = null;
                _this.viewport_ = document.createElement("div");
                _this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
                _this.viewport_.style.position = "relative";
                _this.viewport_.style.overflow = "hidden";
                _this.viewport_.style.width = "100%";
                _this.viewport_.style.height = "100%";
                _this.overlayContainer_ = document.createElement("div");
                _this.overlayContainer_.style.position = "absolute";
                _this.overlayContainer_.style.zIndex = "0";
                _this.overlayContainer_.style.width = "100%";
                _this.overlayContainer_.style.height = "100%";
                _this.overlayContainer_.style.pointerEvents = "none";
                _this.overlayContainer_.className = "ol-overlaycontainer";
                _this.viewport_.appendChild(_this.overlayContainer_);
                _this.overlayContainerStopEvent_ = document.createElement("div");
                _this.overlayContainerStopEvent_.style.position = "absolute";
                _this.overlayContainerStopEvent_.style.zIndex = "0";
                _this.overlayContainerStopEvent_.style.width = "100%";
                _this.overlayContainerStopEvent_.style.height = "100%";
                _this.overlayContainerStopEvent_.style.pointerEvents = "none";
                _this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
                _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
                _this.mapBrowserEventHandler_ = null;
                _this.moveTolerance_ = options.moveTolerance;
                _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
                _this.keyHandlerKeys_ = null;
                _this.controls = optionsInternal.controls || new ol_Collection();
                _this.interactions = optionsInternal.interactions || new ol_Collection();
                _this.overlays_ = optionsInternal.overlays;
                _this.overlayIdIndex_ = {};
                _this.renderer_ = null;
                _this.handleResize_;
                _this.postRenderFunctions_ = [];
                _this.tileQueue_ = new ol_TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
                _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);
                _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);
                _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);
                _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);
                _this.setProperties(optionsInternal.values);
                _this.controls.forEach(
                  /**
                   * @param {import("./control/Control.js").default} control Control.
                   * @this {PluggableMap}
                   */
                  (function(control) {
                    control.setMap(this);
                  }).bind(_this)
                );
                _this.controls.addEventListener(
                  CollectionEventType.ADD,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    event.element.setMap(this);
                  }).bind(_this)
                );
                _this.controls.addEventListener(
                  CollectionEventType.REMOVE,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    event.element.setMap(null);
                  }).bind(_this)
                );
                _this.interactions.forEach(
                  /**
                   * @param {import("./interaction/Interaction.js").default} interaction Interaction.
                   * @this {PluggableMap}
                   */
                  (function(interaction) {
                    interaction.setMap(this);
                  }).bind(_this)
                );
                _this.interactions.addEventListener(
                  CollectionEventType.ADD,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    event.element.setMap(this);
                  }).bind(_this)
                );
                _this.interactions.addEventListener(
                  CollectionEventType.REMOVE,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    event.element.setMap(null);
                  }).bind(_this)
                );
                _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
                _this.overlays_.addEventListener(
                  CollectionEventType.ADD,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    this.addOverlayInternal_(
                      /** @type {import("./Overlay.js").default} */
                      event.element
                    );
                  }).bind(_this)
                );
                _this.overlays_.addEventListener(
                  CollectionEventType.REMOVE,
                  /**
                   * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
                   */
                  (function(event) {
                    var overlay = (
                      /** @type {import("./Overlay.js").default} */
                      event.element
                    );
                    var id = overlay.getId();
                    if (id !== void 0) {
                      delete this.overlayIdIndex_[id.toString()];
                    }
                    event.element.setMap(null);
                  }).bind(_this)
                );
                return _this;
              }
              PluggableMap.prototype.createRenderer = function() {
                throw new Error("Use a map type that has a createRenderer method");
              };
              PluggableMap.prototype.addControl = function(control) {
                this.getControls().push(control);
              };
              PluggableMap.prototype.addInteraction = function(interaction) {
                this.getInteractions().push(interaction);
              };
              PluggableMap.prototype.addLayer = function(layer) {
                var layers = this.getLayerGroup().getLayers();
                layers.push(layer);
              };
              PluggableMap.prototype.addOverlay = function(overlay) {
                this.getOverlays().push(overlay);
              };
              PluggableMap.prototype.addOverlayInternal_ = function(overlay) {
                var id = overlay.getId();
                if (id !== void 0) {
                  this.overlayIdIndex_[id.toString()] = overlay;
                }
                overlay.setMap(this);
              };
              PluggableMap.prototype.disposeInternal = function() {
                this.setTarget(null);
                _super.prototype.disposeInternal.call(this);
              };
              PluggableMap.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
                if (!this.frameState_) {
                  return;
                }
                var coordinate = this.getCoordinateFromPixelInternal(pixel);
                opt_options = opt_options !== void 0 ? opt_options : {};
                var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
                var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : functions[
                  "b"
                  /* TRUE */
                ];
                var checkWrapped = opt_options.checkWrapped !== false;
                return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
              };
              PluggableMap.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
                var features = [];
                this.forEachFeatureAtPixel(pixel, function(feature) {
                  features.push(feature);
                }, opt_options);
                return features;
              };
              PluggableMap.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {
                if (!this.frameState_) {
                  return;
                }
                var options = opt_options || {};
                var hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
                var layerFilter = options.layerFilter || functions[
                  "b"
                  /* TRUE */
                ];
                return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
              };
              PluggableMap.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
                if (!this.frameState_) {
                  return false;
                }
                var coordinate = this.getCoordinateFromPixelInternal(pixel);
                opt_options = opt_options !== void 0 ? opt_options : {};
                var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : functions[
                  "b"
                  /* TRUE */
                ];
                var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
                var checkWrapped = opt_options.checkWrapped !== false;
                return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
              };
              PluggableMap.prototype.getEventCoordinate = function(event) {
                return this.getCoordinateFromPixel(this.getEventPixel(event));
              };
              PluggableMap.prototype.getEventCoordinateInternal = function(event) {
                return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
              };
              PluggableMap.prototype.getEventPixel = function(event) {
                var viewportPosition = this.viewport_.getBoundingClientRect();
                var eventPosition = (
                  //FIXME Are we really calling this with a TouchEvent anywhere?
                  "changedTouches" in event ? (
                    /** @type {TouchEvent} */
                    event.changedTouches[0]
                  ) : (
                    /** @type {MouseEvent} */
                    event
                  )
                );
                return [
                  eventPosition.clientX - viewportPosition.left,
                  eventPosition.clientY - viewportPosition.top
                ];
              };
              PluggableMap.prototype.getTarget = function() {
                return (
                  /** @type {HTMLElement|string|undefined} */
                  this.get(MapProperty.TARGET)
                );
              };
              PluggableMap.prototype.getTargetElement = function() {
                var target = this.getTarget();
                if (target !== void 0) {
                  return typeof target === "string" ? document.getElementById(target) : target;
                } else {
                  return null;
                }
              };
              PluggableMap.prototype.getCoordinateFromPixel = function(pixel) {
                return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
              };
              PluggableMap.prototype.getCoordinateFromPixelInternal = function(pixel) {
                var frameState = this.frameState_;
                if (!frameState) {
                  return null;
                } else {
                  return apply(frameState.pixelToCoordinateTransform, pixel.slice());
                }
              };
              PluggableMap.prototype.getControls = function() {
                return this.controls;
              };
              PluggableMap.prototype.getOverlays = function() {
                return this.overlays_;
              };
              PluggableMap.prototype.getOverlayById = function(id) {
                var overlay = this.overlayIdIndex_[id.toString()];
                return overlay !== void 0 ? overlay : null;
              };
              PluggableMap.prototype.getInteractions = function() {
                return this.interactions;
              };
              PluggableMap.prototype.getLayerGroup = function() {
                return (
                  /** @type {LayerGroup} */
                  this.get(MapProperty.LAYERGROUP)
                );
              };
              PluggableMap.prototype.getLayers = function() {
                var layers = this.getLayerGroup().getLayers();
                return layers;
              };
              PluggableMap.prototype.getLoading = function() {
                var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
                for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                  var layer = layerStatesArray[i].layer;
                  var source = (
                    /** @type {import("./layer/Layer.js").default} */
                    layer.getSource()
                  );
                  if (source && source.loading) {
                    return true;
                  }
                }
                return false;
              };
              PluggableMap.prototype.getPixelFromCoordinate = function(coordinate) {
                var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
                return this.getPixelFromCoordinateInternal(viewCoordinate);
              };
              PluggableMap.prototype.getPixelFromCoordinateInternal = function(coordinate) {
                var frameState = this.frameState_;
                if (!frameState) {
                  return null;
                } else {
                  return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
                }
              };
              PluggableMap.prototype.getRenderer = function() {
                return this.renderer_;
              };
              PluggableMap.prototype.getSize = function() {
                return (
                  /** @type {import("./size.js").Size|undefined} */
                  this.get(MapProperty.SIZE)
                );
              };
              PluggableMap.prototype.getView = function() {
                return (
                  /** @type {View} */
                  this.get(MapProperty.VIEW)
                );
              };
              PluggableMap.prototype.getViewport = function() {
                return this.viewport_;
              };
              PluggableMap.prototype.getOverlayContainer = function() {
                return this.overlayContainer_;
              };
              PluggableMap.prototype.getOverlayContainerStopEvent = function() {
                return this.overlayContainerStopEvent_;
              };
              PluggableMap.prototype.getOwnerDocument = function() {
                var targetElement = this.getTargetElement();
                return targetElement ? targetElement.ownerDocument : document;
              };
              PluggableMap.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {
                return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
              };
              PluggableMap.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
                var type = opt_type || browserEvent.type;
                var mapBrowserEvent = new ol_MapBrowserEvent(type, this, browserEvent);
                this.handleMapBrowserEvent(mapBrowserEvent);
              };
              PluggableMap.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
                if (!this.frameState_) {
                  return;
                }
                var originalEvent = (
                  /** @type {PointerEvent} */
                  mapBrowserEvent.originalEvent
                );
                var eventType = originalEvent.type;
                if (eventType === pointer_EventType.POINTERDOWN || eventType === EventType[
                  "a"
                  /* default */
                ].WHEEL || eventType === EventType[
                  "a"
                  /* default */
                ].KEYDOWN) {
                  var doc = this.getOwnerDocument();
                  var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
                  var target = (
                    /** @type {Node} */
                    originalEvent.target
                  );
                  if (
                    // Abort if the target is a child of the container for elements whose events are not meant
                    // to be handled by map interactions.
                    this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
                    // It's possible for the target to no longer be in the page if it has been removed in an
                    // event listener, this might happen in a Control that recreates it's content based on
                    // user interaction either manually or via a render in something like https://reactjs.org/
                    !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
                  ) {
                    return;
                  }
                }
                mapBrowserEvent.frameState = this.frameState_;
                if (this.dispatchEvent(mapBrowserEvent) !== false) {
                  var interactionsArray = this.getInteractions().getArray().slice();
                  for (var i = interactionsArray.length - 1; i >= 0; i--) {
                    var interaction = interactionsArray[i];
                    if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
                      continue;
                    }
                    var cont = interaction.handleEvent(mapBrowserEvent);
                    if (!cont || mapBrowserEvent.propagationStopped) {
                      break;
                    }
                  }
                }
              };
              PluggableMap.prototype.handlePostRender = function() {
                var frameState = this.frameState_;
                var tileQueue = this.tileQueue_;
                if (!tileQueue.isEmpty()) {
                  var maxTotalLoading = this.maxTilesLoading_;
                  var maxNewLoads = maxTotalLoading;
                  if (frameState) {
                    var hints = frameState.viewHints;
                    if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                      var lowOnFrameBudget = Date.now() - frameState.time > 8;
                      maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                      maxNewLoads = lowOnFrameBudget ? 0 : 2;
                    }
                  }
                  if (tileQueue.getTilesLoading() < maxTotalLoading) {
                    tileQueue.reprioritize();
                    tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
                  }
                }
                if (frameState && this.hasListener(render_EventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {
                  this.renderer_.dispatchRenderEvent(render_EventType.RENDERCOMPLETE, frameState);
                }
                var postRenderFunctions = this.postRenderFunctions_;
                for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
                  postRenderFunctions[i](this, frameState);
                }
                postRenderFunctions.length = 0;
              };
              PluggableMap.prototype.handleSizeChanged_ = function() {
                if (this.getView() && !this.getView().getAnimating()) {
                  this.getView().resolveConstraints(0);
                }
                this.render();
              };
              PluggableMap.prototype.handleTargetChanged_ = function() {
                var targetElement;
                if (this.getTarget()) {
                  targetElement = this.getTargetElement();
                }
                if (this.mapBrowserEventHandler_) {
                  for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
                    Object(events[
                      "c"
                      /* unlistenByKey */
                    ])(this.keyHandlerKeys_[i]);
                  }
                  this.keyHandlerKeys_ = null;
                  this.viewport_.removeEventListener(EventType[
                    "a"
                    /* default */
                  ].CONTEXTMENU, this.boundHandleBrowserEvent_);
                  this.viewport_.removeEventListener(EventType[
                    "a"
                    /* default */
                  ].WHEEL, this.boundHandleBrowserEvent_);
                  if (this.handleResize_ !== void 0) {
                    removeEventListener(EventType[
                      "a"
                      /* default */
                    ].RESIZE, this.handleResize_, false);
                    this.handleResize_ = void 0;
                  }
                  this.mapBrowserEventHandler_.dispose();
                  this.mapBrowserEventHandler_ = null;
                  Object(dom[
                    "e"
                    /* removeNode */
                  ])(this.viewport_);
                }
                if (!targetElement) {
                  if (this.renderer_) {
                    clearTimeout(this.postRenderTimeoutHandle_);
                    this.postRenderTimeoutHandle_ = void 0;
                    this.postRenderFunctions_.length = 0;
                    this.renderer_.dispose();
                    this.renderer_ = null;
                  }
                  if (this.animationDelayKey_) {
                    cancelAnimationFrame(this.animationDelayKey_);
                    this.animationDelayKey_ = void 0;
                  }
                } else {
                  targetElement.appendChild(this.viewport_);
                  if (!this.renderer_) {
                    this.renderer_ = this.createRenderer();
                  }
                  this.mapBrowserEventHandler_ = new ol_MapBrowserEventHandler(this, this.moveTolerance_);
                  for (var key in MapBrowserEventType) {
                    this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
                  }
                  this.viewport_.addEventListener(EventType[
                    "a"
                    /* default */
                  ].CONTEXTMENU, this.boundHandleBrowserEvent_, false);
                  this.viewport_.addEventListener(EventType[
                    "a"
                    /* default */
                  ].WHEEL, this.boundHandleBrowserEvent_, has[
                    "e"
                    /* PASSIVE_EVENT_LISTENERS */
                  ] ? { passive: false } : false);
                  var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
                  this.keyHandlerKeys_ = [
                    Object(events[
                      "a"
                      /* listen */
                    ])(keyboardEventTarget, EventType[
                      "a"
                      /* default */
                    ].KEYDOWN, this.handleBrowserEvent, this),
                    Object(events[
                      "a"
                      /* listen */
                    ])(keyboardEventTarget, EventType[
                      "a"
                      /* default */
                    ].KEYPRESS, this.handleBrowserEvent, this)
                  ];
                  if (!this.handleResize_) {
                    this.handleResize_ = this.updateSize.bind(this);
                    window.addEventListener(EventType[
                      "a"
                      /* default */
                    ].RESIZE, this.handleResize_, false);
                  }
                }
                this.updateSize();
              };
              PluggableMap.prototype.handleTileChange_ = function() {
                this.render();
              };
              PluggableMap.prototype.handleViewPropertyChanged_ = function() {
                this.render();
              };
              PluggableMap.prototype.handleViewChanged_ = function() {
                if (this.viewPropertyListenerKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.viewPropertyListenerKey_);
                  this.viewPropertyListenerKey_ = null;
                }
                if (this.viewChangeListenerKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.viewChangeListenerKey_);
                  this.viewChangeListenerKey_ = null;
                }
                var view = this.getView();
                if (view) {
                  this.updateViewportSize_();
                  this.viewPropertyListenerKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(view, ObjectEventType[
                    "a"
                    /* default */
                  ].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
                  this.viewChangeListenerKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(view, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleViewPropertyChanged_, this);
                  view.resolveConstraints(0);
                }
                this.render();
              };
              PluggableMap.prototype.handleLayerGroupChanged_ = function() {
                if (this.layerGroupPropertyListenerKeys_) {
                  this.layerGroupPropertyListenerKeys_.forEach(events[
                    "c"
                    /* unlistenByKey */
                  ]);
                  this.layerGroupPropertyListenerKeys_ = null;
                }
                var layerGroup = this.getLayerGroup();
                if (layerGroup) {
                  this.layerGroupPropertyListenerKeys_ = [
                    Object(events[
                      "a"
                      /* listen */
                    ])(layerGroup, ObjectEventType[
                      "a"
                      /* default */
                    ].PROPERTYCHANGE, this.render, this),
                    Object(events[
                      "a"
                      /* listen */
                    ])(layerGroup, EventType[
                      "a"
                      /* default */
                    ].CHANGE, this.render, this)
                  ];
                }
                this.render();
              };
              PluggableMap.prototype.isRendered = function() {
                return !!this.frameState_;
              };
              PluggableMap.prototype.renderSync = function() {
                if (this.animationDelayKey_) {
                  cancelAnimationFrame(this.animationDelayKey_);
                }
                this.animationDelay_();
              };
              PluggableMap.prototype.redrawText = function() {
                var layerStates = this.getLayerGroup().getLayerStatesArray();
                for (var i = 0, ii = layerStates.length; i < ii; ++i) {
                  var layer = layerStates[i].layer;
                  if (layer.hasRenderer()) {
                    layer.getRenderer().handleFontsChanged();
                  }
                }
              };
              PluggableMap.prototype.render = function() {
                if (this.renderer_ && this.animationDelayKey_ === void 0) {
                  this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
                }
              };
              PluggableMap.prototype.removeControl = function(control) {
                return this.getControls().remove(control);
              };
              PluggableMap.prototype.removeInteraction = function(interaction) {
                return this.getInteractions().remove(interaction);
              };
              PluggableMap.prototype.removeLayer = function(layer) {
                var layers = this.getLayerGroup().getLayers();
                return layers.remove(layer);
              };
              PluggableMap.prototype.removeOverlay = function(overlay) {
                return this.getOverlays().remove(overlay);
              };
              PluggableMap.prototype.renderFrame_ = function(time) {
                var _this = this;
                var size = this.getSize();
                var view = this.getView();
                var previousFrameState = this.frameState_;
                var frameState = null;
                if (size !== void 0 && hasArea(size) && view && view.isDef()) {
                  var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);
                  var viewState = view.getState();
                  frameState = {
                    animate: false,
                    coordinateToPixelTransform: this.coordinateToPixelTransform_,
                    declutterTree: null,
                    extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                    index: this.frameIndex_++,
                    layerIndex: 0,
                    layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                    pixelRatio: this.pixelRatio_,
                    pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                    postRenderFunctions: [],
                    size,
                    tileQueue: this.tileQueue_,
                    time,
                    usedTiles: {},
                    viewState,
                    viewHints,
                    wantedTiles: {}
                  };
                }
                this.frameState_ = frameState;
                this.renderer_.renderFrame(frameState);
                if (frameState) {
                  if (frameState.animate) {
                    this.render();
                  }
                  Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
                  if (previousFrameState) {
                    var moveStart = !this.previousExtent_ || !extent_isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);
                    if (moveStart) {
                      this.dispatchEvent(new ol_MapEvent(MapEventType[
                        "a"
                        /* default */
                      ].MOVESTART, this, previousFrameState));
                      this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                    }
                  }
                  var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);
                  if (idle) {
                    this.dispatchEvent(new ol_MapEvent(MapEventType[
                      "a"
                      /* default */
                    ].MOVEEND, this, frameState));
                    clone(frameState.extent, this.previousExtent_);
                  }
                }
                this.dispatchEvent(new ol_MapEvent(MapEventType[
                  "a"
                  /* default */
                ].POSTRENDER, this, frameState));
                if (!this.postRenderTimeoutHandle_) {
                  this.postRenderTimeoutHandle_ = setTimeout(function() {
                    _this.postRenderTimeoutHandle_ = void 0;
                    _this.handlePostRender();
                  }, 0);
                }
              };
              PluggableMap.prototype.setLayerGroup = function(layerGroup) {
                this.set(MapProperty.LAYERGROUP, layerGroup);
              };
              PluggableMap.prototype.setSize = function(size) {
                this.set(MapProperty.SIZE, size);
              };
              PluggableMap.prototype.setTarget = function(target) {
                this.set(MapProperty.TARGET, target);
              };
              PluggableMap.prototype.setView = function(view) {
                this.set(MapProperty.VIEW, view);
              };
              PluggableMap.prototype.updateSize = function() {
                var targetElement = this.getTargetElement();
                var size = void 0;
                if (targetElement) {
                  var computedStyle = getComputedStyle(targetElement);
                  var width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
                  var height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
                  if (!isNaN(width) && !isNaN(height)) {
                    size = [width, height];
                    if (!hasArea(size)) {
                      console.warn("No map visible because the map container's width or height are 0.");
                    }
                  }
                }
                this.setSize(size);
                this.updateViewportSize_();
              };
              PluggableMap.prototype.updateViewportSize_ = function() {
                var view = this.getView();
                if (view) {
                  var size = void 0;
                  var computedStyle = getComputedStyle(this.viewport_);
                  if (computedStyle.width && computedStyle.height) {
                    size = [
                      parseInt(computedStyle.width, 10),
                      parseInt(computedStyle.height, 10)
                    ];
                  }
                  view.setViewportSize(size);
                }
              };
              return PluggableMap;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          function createOptionsInternal(options) {
            var keyboardEventTarget = null;
            if (options.keyboardEventTarget !== void 0) {
              keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
            }
            var values = {};
            var layerGroup = options.layers && typeof /** @type {?} */
            options.layers.getLayers === "function" ? (
              /** @type {LayerGroup} */
              options.layers
            ) : new Group({ layers: (
              /** @type {Collection} */
              options.layers
            ) });
            values[MapProperty.LAYERGROUP] = layerGroup;
            values[MapProperty.TARGET] = options.target;
            values[MapProperty.VIEW] = options.view !== void 0 ? options.view : new ol_View();
            var controls;
            if (options.controls !== void 0) {
              if (Array.isArray(options.controls)) {
                controls = new ol_Collection(options.controls.slice());
              } else {
                assert2(typeof /** @type {?} */
                options.controls.getArray === "function", 47);
                controls = /** @type {Collection} */
                options.controls;
              }
            }
            var interactions;
            if (options.interactions !== void 0) {
              if (Array.isArray(options.interactions)) {
                interactions = new ol_Collection(options.interactions.slice());
              } else {
                assert2(typeof /** @type {?} */
                options.interactions.getArray === "function", 48);
                interactions = /** @type {Collection} */
                options.interactions;
              }
            }
            var overlays;
            if (options.overlays !== void 0) {
              if (Array.isArray(options.overlays)) {
                overlays = new ol_Collection(options.overlays.slice());
              } else {
                assert2(typeof /** @type {?} */
                options.overlays.getArray === "function", 49);
                overlays = options.overlays;
              }
            } else {
              overlays = new ol_Collection();
            }
            return {
              controls,
              interactions,
              keyboardEventTarget,
              overlays,
              values
            };
          }
          var ol_PluggableMap = PluggableMap_PluggableMap;
          var Control = __webpack_require__("3900");
          var Attribution_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Attribution_Attribution = (
            /** @class */
            function(_super) {
              Attribution_extends(Attribution, _super);
              function Attribution(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  render: options.render,
                  target: options.target
                }) || this;
                _this.ulElement_ = document.createElement("ul");
                _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
                _this.userCollapsed_ = _this.collapsed_;
                _this.overrideCollapsible_ = options.collapsible !== void 0;
                _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
                if (!_this.collapsible_) {
                  _this.collapsed_ = false;
                }
                var className = options.className !== void 0 ? options.className : "ol-attribution";
                var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
                var expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
                var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "";
                var collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collpase";
                if (typeof collapseLabel === "string") {
                  _this.collapseLabel_ = document.createElement("span");
                  _this.collapseLabel_.textContent = collapseLabel;
                  _this.collapseLabel_.className = collapseClassName;
                } else {
                  _this.collapseLabel_ = collapseLabel;
                }
                var label = options.label !== void 0 ? options.label : "i";
                if (typeof label === "string") {
                  _this.label_ = document.createElement("span");
                  _this.label_.textContent = label;
                  _this.label_.className = expandClassName;
                } else {
                  _this.label_ = label;
                }
                var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
                _this.toggleButton_ = document.createElement("button");
                _this.toggleButton_.setAttribute("type", "button");
                _this.toggleButton_.setAttribute("aria-expanded", String(!_this.collapsed_));
                _this.toggleButton_.title = tipLabel;
                _this.toggleButton_.appendChild(activeLabel);
                _this.toggleButton_.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this), false);
                var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(_this.toggleButton_);
                element.appendChild(_this.ulElement_);
                _this.renderedAttributions_ = [];
                _this.renderedVisible_ = true;
                return _this;
              }
              Attribution.prototype.collectSourceAttributions_ = function(frameState) {
                var lookup = {};
                var visibleAttributions = [];
                var collapsible = true;
                var layerStatesArray = frameState.layerStatesArray;
                for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
                  var layerState = layerStatesArray[i];
                  if (!inView(layerState, frameState.viewState)) {
                    continue;
                  }
                  var source = (
                    /** @type {import("../layer/Layer.js").default} */
                    layerState.layer.getSource()
                  );
                  if (!source) {
                    continue;
                  }
                  var attributionGetter = source.getAttributions();
                  if (!attributionGetter) {
                    continue;
                  }
                  var attributions = attributionGetter(frameState);
                  if (!attributions) {
                    continue;
                  }
                  collapsible = collapsible && source.getAttributionsCollapsible() !== false;
                  if (Array.isArray(attributions)) {
                    for (var j = 0, jj = attributions.length; j < jj; ++j) {
                      if (!(attributions[j] in lookup)) {
                        visibleAttributions.push(attributions[j]);
                        lookup[attributions[j]] = true;
                      }
                    }
                  } else {
                    if (!(attributions in lookup)) {
                      visibleAttributions.push(attributions);
                      lookup[attributions] = true;
                    }
                  }
                }
                if (!this.overrideCollapsible_) {
                  this.setCollapsible(collapsible);
                }
                return visibleAttributions;
              };
              Attribution.prototype.updateElement_ = function(frameState) {
                if (!frameState) {
                  if (this.renderedVisible_) {
                    this.element.style.display = "none";
                    this.renderedVisible_ = false;
                  }
                  return;
                }
                var attributions = this.collectSourceAttributions_(frameState);
                var visible = attributions.length > 0;
                if (this.renderedVisible_ != visible) {
                  this.element.style.display = visible ? "" : "none";
                  this.renderedVisible_ = visible;
                }
                if (Object(ol_array[
                  "b"
                  /* equals */
                ])(attributions, this.renderedAttributions_)) {
                  return;
                }
                Object(dom[
                  "d"
                  /* removeChildren */
                ])(this.ulElement_);
                for (var i = 0, ii = attributions.length; i < ii; ++i) {
                  var element = document.createElement("li");
                  element.innerHTML = attributions[i];
                  this.ulElement_.appendChild(element);
                }
                this.renderedAttributions_ = attributions;
              };
              Attribution.prototype.handleClick_ = function(event) {
                event.preventDefault();
                this.handleToggle_();
                this.userCollapsed_ = this.collapsed_;
              };
              Attribution.prototype.handleToggle_ = function() {
                this.element.classList.toggle(CLASS_COLLAPSED);
                if (this.collapsed_) {
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.collapseLabel_, this.label_);
                } else {
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.label_, this.collapseLabel_);
                }
                this.collapsed_ = !this.collapsed_;
                this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
              };
              Attribution.prototype.getCollapsible = function() {
                return this.collapsible_;
              };
              Attribution.prototype.setCollapsible = function(collapsible) {
                if (this.collapsible_ === collapsible) {
                  return;
                }
                this.collapsible_ = collapsible;
                this.element.classList.toggle("ol-uncollapsible");
                if (this.userCollapsed_) {
                  this.handleToggle_();
                }
              };
              Attribution.prototype.setCollapsed = function(collapsed) {
                this.userCollapsed_ = collapsed;
                if (!this.collapsible_ || this.collapsed_ === collapsed) {
                  return;
                }
                this.handleToggle_();
              };
              Attribution.prototype.getCollapsed = function() {
                return this.collapsed_;
              };
              Attribution.prototype.render = function(mapEvent) {
                this.updateElement_(mapEvent.frameState);
              };
              return Attribution;
            }(Control["default"])
          );
          var control_Attribution = Attribution_Attribution;
          var Rotate_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Rotate_Rotate = (
            /** @class */
            function(_super) {
              Rotate_extends(Rotate, _super);
              function Rotate(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  render: options.render,
                  target: options.target
                }) || this;
                var className = options.className !== void 0 ? options.className : "ol-rotate";
                var label = options.label !== void 0 ? options.label : "";
                var compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
                _this.label_ = null;
                if (typeof label === "string") {
                  _this.label_ = document.createElement("span");
                  _this.label_.className = compassClassName;
                  _this.label_.textContent = label;
                } else {
                  _this.label_ = label;
                  _this.label_.classList.add(compassClassName);
                }
                var tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
                var button = document.createElement("button");
                button.className = className + "-reset";
                button.setAttribute("type", "button");
                button.title = tipLabel;
                button.appendChild(_this.label_);
                button.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this), false);
                var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(button);
                _this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                _this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
                _this.rotation_ = void 0;
                if (_this.autoHide_) {
                  _this.element.classList.add(CLASS_HIDDEN);
                }
                return _this;
              }
              Rotate.prototype.handleClick_ = function(event) {
                event.preventDefault();
                if (this.callResetNorth_ !== void 0) {
                  this.callResetNorth_();
                } else {
                  this.resetNorth_();
                }
              };
              Rotate.prototype.resetNorth_ = function() {
                var map = this.getMap();
                var view = map.getView();
                if (!view) {
                  return;
                }
                var rotation = view.getRotation();
                if (rotation !== void 0) {
                  if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                    view.animate({
                      rotation: 0,
                      duration: this.duration_,
                      easing: easeOut
                    });
                  } else {
                    view.setRotation(0);
                  }
                }
              };
              Rotate.prototype.render = function(mapEvent) {
                var frameState = mapEvent.frameState;
                if (!frameState) {
                  return;
                }
                var rotation = frameState.viewState.rotation;
                if (rotation != this.rotation_) {
                  var transform2 = "rotate(" + rotation + "rad)";
                  if (this.autoHide_) {
                    var contains = this.element.classList.contains(CLASS_HIDDEN);
                    if (!contains && rotation === 0) {
                      this.element.classList.add(CLASS_HIDDEN);
                    } else if (contains && rotation !== 0) {
                      this.element.classList.remove(CLASS_HIDDEN);
                    }
                  }
                  this.label_.style.transform = transform2;
                }
                this.rotation_ = rotation;
              };
              return Rotate;
            }(Control["default"])
          );
          var control_Rotate = Rotate_Rotate;
          var Zoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Zoom_Zoom = (
            /** @class */
            function(_super) {
              Zoom_extends(Zoom, _super);
              function Zoom(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  target: options.target
                }) || this;
                var className = options.className !== void 0 ? options.className : "ol-zoom";
                var delta = options.delta !== void 0 ? options.delta : 1;
                var zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
                var zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
                var zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
                var zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "";
                var zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
                var zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
                var inElement = document.createElement("button");
                inElement.className = zoomInClassName;
                inElement.setAttribute("type", "button");
                inElement.title = zoomInTipLabel;
                inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
                inElement.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this, delta), false);
                var outElement = document.createElement("button");
                outElement.className = zoomOutClassName;
                outElement.setAttribute("type", "button");
                outElement.title = zoomOutTipLabel;
                outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
                outElement.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this, -delta), false);
                var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(inElement);
                element.appendChild(outElement);
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                return _this;
              }
              Zoom.prototype.handleClick_ = function(delta, event) {
                event.preventDefault();
                this.zoomByDelta_(delta);
              };
              Zoom.prototype.zoomByDelta_ = function(delta) {
                var map = this.getMap();
                var view = map.getView();
                if (!view) {
                  return;
                }
                var currentZoom = view.getZoom();
                if (currentZoom !== void 0) {
                  var newZoom = view.getConstrainedZoom(currentZoom + delta);
                  if (this.duration_ > 0) {
                    if (view.getAnimating()) {
                      view.cancelAnimations();
                    }
                    view.animate({
                      zoom: newZoom,
                      duration: this.duration_,
                      easing: easeOut
                    });
                  } else {
                    view.setZoom(newZoom);
                  }
                }
              };
              return Zoom;
            }(Control["default"])
          );
          var control_Zoom = Zoom_Zoom;
          function defaults(opt_options) {
            var options = opt_options ? opt_options : {};
            var controls = new ol_Collection();
            var zoomControl = options.zoom !== void 0 ? options.zoom : true;
            if (zoomControl) {
              controls.push(new control_Zoom(options.zoomOptions));
            }
            var rotateControl = options.rotate !== void 0 ? options.rotate : true;
            if (rotateControl) {
              controls.push(new control_Rotate(options.rotateOptions));
            }
            var attributionControl = options.attribution !== void 0 ? options.attribution : true;
            if (attributionControl) {
              controls.push(new control_Attribution(options.attributionOptions));
            }
            return controls;
          }
          var interaction_Property = {
            ACTIVE: "active"
          };
          var Interaction_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Interaction_Interaction = (
            /** @class */
            function(_super) {
              Interaction_extends(Interaction, _super);
              function Interaction(opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                if (opt_options && opt_options.handleEvent) {
                  _this.handleEvent = opt_options.handleEvent;
                }
                _this.map_ = null;
                _this.setActive(true);
                return _this;
              }
              Interaction.prototype.getActive = function() {
                return (
                  /** @type {boolean} */
                  this.get(interaction_Property.ACTIVE)
                );
              };
              Interaction.prototype.getMap = function() {
                return this.map_;
              };
              Interaction.prototype.handleEvent = function(mapBrowserEvent) {
                return true;
              };
              Interaction.prototype.setActive = function(active) {
                this.set(interaction_Property.ACTIVE, active);
              };
              Interaction.prototype.setMap = function(map) {
                this.map_ = map;
              };
              return Interaction;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          function pan(view, delta, opt_duration) {
            var currentCenter = view.getCenterInternal();
            if (currentCenter) {
              var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
              view.animateInternal({
                duration: opt_duration !== void 0 ? opt_duration : 250,
                easing: linear,
                center: view.getConstrainedCenter(center)
              });
            }
          }
          function zoomByDelta(view, delta, opt_anchor, opt_duration) {
            var currentZoom = view.getZoom();
            if (currentZoom === void 0) {
              return;
            }
            var newZoom = view.getConstrainedZoom(currentZoom + delta);
            var newResolution = view.getResolutionForZoom(newZoom);
            if (view.getAnimating()) {
              view.cancelAnimations();
            }
            view.animate({
              resolution: newResolution,
              anchor: opt_anchor,
              duration: opt_duration !== void 0 ? opt_duration : 250,
              easing: easeOut
            });
          }
          var interaction_Interaction = Interaction_Interaction;
          var DoubleClickZoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DoubleClickZoom_DoubleClickZoom = (
            /** @class */
            function(_super) {
              DoubleClickZoom_extends(DoubleClickZoom, _super);
              function DoubleClickZoom(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.delta_ = options.delta ? options.delta : 1;
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                return _this;
              }
              DoubleClickZoom.prototype.handleEvent = function(mapBrowserEvent) {
                var stopEvent = false;
                if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
                  var browserEvent = (
                    /** @type {MouseEvent} */
                    mapBrowserEvent.originalEvent
                  );
                  var map = mapBrowserEvent.map;
                  var anchor = mapBrowserEvent.coordinate;
                  var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
                  var view = map.getView();
                  zoomByDelta(view, delta, anchor, this.duration_);
                  browserEvent.preventDefault();
                  stopEvent = true;
                }
                return !stopEvent;
              };
              return DoubleClickZoom;
            }(interaction_Interaction)
          );
          var interaction_DoubleClickZoom = DoubleClickZoom_DoubleClickZoom;
          var Pointer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Pointer_PointerInteraction = (
            /** @class */
            function(_super) {
              Pointer_extends(PointerInteraction, _super);
              function PointerInteraction(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(
                  this,
                  /** @type {import("./Interaction.js").InteractionOptions} */
                  options
                ) || this;
                if (options.handleDownEvent) {
                  _this.handleDownEvent = options.handleDownEvent;
                }
                if (options.handleDragEvent) {
                  _this.handleDragEvent = options.handleDragEvent;
                }
                if (options.handleMoveEvent) {
                  _this.handleMoveEvent = options.handleMoveEvent;
                }
                if (options.handleUpEvent) {
                  _this.handleUpEvent = options.handleUpEvent;
                }
                if (options.stopDown) {
                  _this.stopDown = options.stopDown;
                }
                _this.handlingDownUpSequence = false;
                _this.trackedPointers_ = {};
                _this.targetPointers = [];
                return _this;
              }
              PointerInteraction.prototype.getPointerCount = function() {
                return this.targetPointers.length;
              };
              PointerInteraction.prototype.handleDownEvent = function(mapBrowserEvent) {
                return false;
              };
              PointerInteraction.prototype.handleDragEvent = function(mapBrowserEvent) {
              };
              PointerInteraction.prototype.handleEvent = function(mapBrowserEvent) {
                if (!mapBrowserEvent.originalEvent) {
                  return true;
                }
                var stopEvent = false;
                this.updateTrackedPointers_(mapBrowserEvent);
                if (this.handlingDownUpSequence) {
                  if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                    this.handleDragEvent(mapBrowserEvent);
                    mapBrowserEvent.originalEvent.preventDefault();
                  } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                    var handledUp = this.handleUpEvent(mapBrowserEvent);
                    this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
                  }
                } else {
                  if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                    var handled = this.handleDownEvent(mapBrowserEvent);
                    this.handlingDownUpSequence = handled;
                    stopEvent = this.stopDown(handled);
                  } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                    this.handleMoveEvent(mapBrowserEvent);
                  }
                }
                return !stopEvent;
              };
              PointerInteraction.prototype.handleMoveEvent = function(mapBrowserEvent) {
              };
              PointerInteraction.prototype.handleUpEvent = function(mapBrowserEvent) {
                return false;
              };
              PointerInteraction.prototype.stopDown = function(handled) {
                return handled;
              };
              PointerInteraction.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {
                if (isPointerDraggingEvent(mapBrowserEvent)) {
                  var event_1 = mapBrowserEvent.originalEvent;
                  var id = event_1.pointerId.toString();
                  if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                    delete this.trackedPointers_[id];
                  } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                    this.trackedPointers_[id] = event_1;
                  } else if (id in this.trackedPointers_) {
                    this.trackedPointers_[id] = event_1;
                  }
                  this.targetPointers = Object(ol_obj[
                    "c"
                    /* getValues */
                  ])(this.trackedPointers_);
                }
              };
              return PointerInteraction;
            }(interaction_Interaction)
          );
          function Pointer_centroid(pointerEvents) {
            var length = pointerEvents.length;
            var clientX = 0;
            var clientY = 0;
            for (var i = 0; i < length; i++) {
              clientX += pointerEvents[i].clientX;
              clientY += pointerEvents[i].clientY;
            }
            return [clientX / length, clientY / length];
          }
          function isPointerDraggingEvent(mapBrowserEvent) {
            var type = mapBrowserEvent.type;
            return type === MapBrowserEventType.POINTERDOWN || type === MapBrowserEventType.POINTERDRAG || type === MapBrowserEventType.POINTERUP;
          }
          var Pointer = Pointer_PointerInteraction;
          function condition_all(var_args) {
            var conditions = arguments;
            return function(event) {
              var pass = true;
              for (var i = 0, ii = conditions.length; i < ii; ++i) {
                pass = pass && conditions[i](event);
                if (!pass) {
                  break;
                }
              }
              return pass;
            };
          }
          var altKeyOnly = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
          };
          var altShiftKeysOnly = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
          };
          var condition_focus = function(event) {
            return event.target.getTargetElement().contains(document.activeElement);
          };
          var focusWithTabindex = function(event) {
            return event.map.getTargetElement().hasAttribute("tabindex") ? condition_focus(event) : true;
          };
          var always = functions[
            "b"
            /* TRUE */
          ];
          var click = function(mapBrowserEvent) {
            return mapBrowserEvent.type == MapBrowserEventType.CLICK;
          };
          var mouseActionButton = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {MouseEvent} */
              mapBrowserEvent.originalEvent
            );
            return originalEvent.button == 0 && !(has[
              "f"
              /* WEBKIT */
            ] && has[
              "d"
              /* MAC */
            ] && originalEvent.ctrlKey);
          };
          var never = functions[
            "a"
            /* FALSE */
          ];
          var pointerMove = function(mapBrowserEvent) {
            return mapBrowserEvent.type == "pointermove";
          };
          var singleClick = function(mapBrowserEvent) {
            return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
          };
          var doubleClick = function(mapBrowserEvent) {
            return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;
          };
          var noModifierKeys = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
          };
          var platformModifierKeyOnly = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            return !originalEvent.altKey && (has[
              "d"
              /* MAC */
            ] ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
          };
          var shiftKeyOnly = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
          };
          var targetNotEditable = function(mapBrowserEvent) {
            var originalEvent = (
              /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
              mapBrowserEvent.originalEvent
            );
            var tagName = (
              /** @type {Element} */
              originalEvent.target.tagName
            );
            return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA";
          };
          var mouseOnly = function(mapBrowserEvent) {
            var pointerEvent = (
              /** @type {import("../MapBrowserEvent").default} */
              mapBrowserEvent.originalEvent
            );
            assert2(pointerEvent !== void 0, 56);
            return pointerEvent.pointerType == "mouse";
          };
          var touchOnly = function(mapBrowserEvent) {
            var pointerEvt = (
              /** @type {import("../MapBrowserEvent").default} */
              mapBrowserEvent.originalEvent
            );
            assert2(pointerEvt !== void 0, 56);
            return pointerEvt.pointerType === "touch";
          };
          var penOnly = function(mapBrowserEvent) {
            var pointerEvt = (
              /** @type {import("../MapBrowserEvent").default} */
              mapBrowserEvent.originalEvent
            );
            assert2(pointerEvt !== void 0, 56);
            return pointerEvt.pointerType === "pen";
          };
          var primaryAction = function(mapBrowserEvent) {
            var pointerEvent = (
              /** @type {import("../MapBrowserEvent").default} */
              mapBrowserEvent.originalEvent
            );
            assert2(pointerEvent !== void 0, 56);
            return pointerEvent.isPrimary && pointerEvent.button === 0;
          };
          var DragPan_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DragPan_DragPan = (
            /** @class */
            function(_super) {
              DragPan_extends(DragPan, _super);
              function DragPan(opt_options) {
                var _this = _super.call(this, {
                  stopDown: functions[
                    "a"
                    /* FALSE */
                  ]
                }) || this;
                var options = opt_options ? opt_options : {};
                _this.kinetic_ = options.kinetic;
                _this.lastCentroid = null;
                _this.lastPointersCount_;
                _this.panning_ = false;
                var condition = options.condition ? options.condition : condition_all(noModifierKeys, primaryAction);
                _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
                _this.noKinetic_ = false;
                return _this;
              }
              DragPan.prototype.handleDragEvent = function(mapBrowserEvent) {
                if (!this.panning_) {
                  this.panning_ = true;
                  this.getMap().getView().beginInteraction();
                }
                var targetPointers = this.targetPointers;
                var centroid = Pointer_centroid(targetPointers);
                if (targetPointers.length == this.lastPointersCount_) {
                  if (this.kinetic_) {
                    this.kinetic_.update(centroid[0], centroid[1]);
                  }
                  if (this.lastCentroid) {
                    var delta = [
                      this.lastCentroid[0] - centroid[0],
                      centroid[1] - this.lastCentroid[1]
                    ];
                    var map = mapBrowserEvent.map;
                    var view = map.getView();
                    coordinate_scale(delta, view.getResolution());
                    coordinate_rotate(delta, view.getRotation());
                    view.adjustCenterInternal(delta);
                  }
                } else if (this.kinetic_) {
                  this.kinetic_.begin();
                }
                this.lastCentroid = centroid;
                this.lastPointersCount_ = targetPointers.length;
                mapBrowserEvent.originalEvent.preventDefault();
              };
              DragPan.prototype.handleUpEvent = function(mapBrowserEvent) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                if (this.targetPointers.length === 0) {
                  if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                    var distance = this.kinetic_.getDistance();
                    var angle = this.kinetic_.getAngle();
                    var center = view.getCenterInternal();
                    var centerpx = map.getPixelFromCoordinateInternal(center);
                    var dest = map.getCoordinateFromPixelInternal([
                      centerpx[0] - distance * Math.cos(angle),
                      centerpx[1] - distance * Math.sin(angle)
                    ]);
                    view.animateInternal({
                      center: view.getConstrainedCenter(dest),
                      duration: 500,
                      easing: easeOut
                    });
                  }
                  if (this.panning_) {
                    this.panning_ = false;
                    view.endInteraction();
                  }
                  return false;
                } else {
                  if (this.kinetic_) {
                    this.kinetic_.begin();
                  }
                  this.lastCentroid = null;
                  return true;
                }
              };
              DragPan.prototype.handleDownEvent = function(mapBrowserEvent) {
                if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  this.lastCentroid = null;
                  if (view.getAnimating()) {
                    view.cancelAnimations();
                  }
                  if (this.kinetic_) {
                    this.kinetic_.begin();
                  }
                  this.noKinetic_ = this.targetPointers.length > 1;
                  return true;
                } else {
                  return false;
                }
              };
              return DragPan;
            }(Pointer)
          );
          var interaction_DragPan = DragPan_DragPan;
          var DragRotate_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DragRotate_DragRotate = (
            /** @class */
            function(_super) {
              DragRotate_extends(DragRotate, _super);
              function DragRotate(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  stopDown: functions[
                    "a"
                    /* FALSE */
                  ]
                }) || this;
                _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
                _this.lastAngle_ = void 0;
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                return _this;
              }
              DragRotate.prototype.handleDragEvent = function(mapBrowserEvent) {
                if (!mouseOnly(mapBrowserEvent)) {
                  return;
                }
                var map = mapBrowserEvent.map;
                var view = map.getView();
                if (view.getConstraints().rotation === disable) {
                  return;
                }
                var size = map.getSize();
                var offset = mapBrowserEvent.pixel;
                var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
                if (this.lastAngle_ !== void 0) {
                  var delta = theta - this.lastAngle_;
                  view.adjustRotationInternal(-delta);
                }
                this.lastAngle_ = theta;
              };
              DragRotate.prototype.handleUpEvent = function(mapBrowserEvent) {
                if (!mouseOnly(mapBrowserEvent)) {
                  return true;
                }
                var map = mapBrowserEvent.map;
                var view = map.getView();
                view.endInteraction(this.duration_);
                return false;
              };
              DragRotate.prototype.handleDownEvent = function(mapBrowserEvent) {
                if (!mouseOnly(mapBrowserEvent)) {
                  return false;
                }
                if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
                  var map = mapBrowserEvent.map;
                  map.getView().beginInteraction();
                  this.lastAngle_ = void 0;
                  return true;
                } else {
                  return false;
                }
              };
              return DragRotate;
            }(Pointer)
          );
          var interaction_DragRotate = DragRotate_DragRotate;
          var Box_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Box_RenderBox = (
            /** @class */
            function(_super) {
              Box_extends(RenderBox, _super);
              function RenderBox(className) {
                var _this = _super.call(this) || this;
                _this.geometry_ = null;
                _this.element_ = document.createElement("div");
                _this.element_.style.position = "absolute";
                _this.element_.style.pointerEvents = "auto";
                _this.element_.className = "ol-box " + className;
                _this.map_ = null;
                _this.startPixel_ = null;
                _this.endPixel_ = null;
                return _this;
              }
              RenderBox.prototype.disposeInternal = function() {
                this.setMap(null);
              };
              RenderBox.prototype.render_ = function() {
                var startPixel = this.startPixel_;
                var endPixel = this.endPixel_;
                var px = "px";
                var style = this.element_.style;
                style.left = Math.min(startPixel[0], endPixel[0]) + px;
                style.top = Math.min(startPixel[1], endPixel[1]) + px;
                style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
                style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
              };
              RenderBox.prototype.setMap = function(map) {
                if (this.map_) {
                  this.map_.getOverlayContainer().removeChild(this.element_);
                  var style = this.element_.style;
                  style.left = "inherit";
                  style.top = "inherit";
                  style.width = "inherit";
                  style.height = "inherit";
                }
                this.map_ = map;
                if (this.map_) {
                  this.map_.getOverlayContainer().appendChild(this.element_);
                }
              };
              RenderBox.prototype.setPixels = function(startPixel, endPixel) {
                this.startPixel_ = startPixel;
                this.endPixel_ = endPixel;
                this.createOrUpdateGeometry();
                this.render_();
              };
              RenderBox.prototype.createOrUpdateGeometry = function() {
                var startPixel = this.startPixel_;
                var endPixel = this.endPixel_;
                var pixels = [
                  startPixel,
                  [startPixel[0], endPixel[1]],
                  endPixel,
                  [endPixel[0], startPixel[1]]
                ];
                var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
                coordinates[4] = coordinates[0].slice();
                if (!this.geometry_) {
                  this.geometry_ = new geom_Polygon([coordinates]);
                } else {
                  this.geometry_.setCoordinates([coordinates]);
                }
              };
              RenderBox.prototype.getGeometry = function() {
                return this.geometry_;
              };
              return RenderBox;
            }(Disposable[
              "a"
              /* default */
            ])
          );
          var Box = Box_RenderBox;
          var DragBox_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DragBoxEventType = {
            /**
             * Triggered upon drag box start.
             * @event DragBoxEvent#boxstart
             * @api
             */
            BOXSTART: "boxstart",
            /**
             * Triggered on drag when box is active.
             * @event DragBoxEvent#boxdrag
             * @api
             */
            BOXDRAG: "boxdrag",
            /**
             * Triggered upon drag box end.
             * @event DragBoxEvent#boxend
             * @api
             */
            BOXEND: "boxend",
            /**
             * Triggered upon drag box canceled.
             * @event DragBoxEvent#boxcancel
             * @api
             */
            BOXCANCEL: "boxcancel"
          };
          var DragBoxEvent = (
            /** @class */
            function(_super) {
              DragBox_extends(DragBoxEvent2, _super);
              function DragBoxEvent2(type, coordinate, mapBrowserEvent) {
                var _this = _super.call(this, type) || this;
                _this.coordinate = coordinate;
                _this.mapBrowserEvent = mapBrowserEvent;
                return _this;
              }
              return DragBoxEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var DragBox_DragBox = (
            /** @class */
            function(_super) {
              DragBox_extends(DragBox, _super);
              function DragBox(opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var options = opt_options ? opt_options : {};
                _this.box_ = new Box(options.className || "ol-dragbox");
                _this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
                if (options.onBoxEnd) {
                  _this.onBoxEnd = options.onBoxEnd;
                }
                _this.startPixel_ = null;
                _this.condition_ = options.condition ? options.condition : mouseActionButton;
                _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
                return _this;
              }
              DragBox.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
                var width = endPixel[0] - startPixel[0];
                var height = endPixel[1] - startPixel[1];
                return width * width + height * height >= this.minArea_;
              };
              DragBox.prototype.getGeometry = function() {
                return this.box_.getGeometry();
              };
              DragBox.prototype.handleDragEvent = function(mapBrowserEvent) {
                this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
                this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
              };
              DragBox.prototype.handleUpEvent = function(mapBrowserEvent) {
                this.box_.setMap(null);
                var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
                if (completeBox) {
                  this.onBoxEnd(mapBrowserEvent);
                }
                this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
                return false;
              };
              DragBox.prototype.handleDownEvent = function(mapBrowserEvent) {
                if (this.condition_(mapBrowserEvent)) {
                  this.startPixel_ = mapBrowserEvent.pixel;
                  this.box_.setMap(mapBrowserEvent.map);
                  this.box_.setPixels(this.startPixel_, this.startPixel_);
                  this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
                  return true;
                } else {
                  return false;
                }
              };
              DragBox.prototype.onBoxEnd = function(event) {
              };
              return DragBox;
            }(Pointer)
          );
          var interaction_DragBox = DragBox_DragBox;
          var DragZoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DragZoom_DragZoom = (
            /** @class */
            function(_super) {
              DragZoom_extends(DragZoom, _super);
              function DragZoom(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var condition = options.condition ? options.condition : shiftKeyOnly;
                _this = _super.call(this, {
                  condition,
                  className: options.className || "ol-dragzoom",
                  minArea: options.minArea
                }) || this;
                _this.duration_ = options.duration !== void 0 ? options.duration : 200;
                _this.out_ = options.out !== void 0 ? options.out : false;
                return _this;
              }
              DragZoom.prototype.onBoxEnd = function(event) {
                var map = this.getMap();
                var view = (
                  /** @type {!import("../View.js").default} */
                  map.getView()
                );
                var geometry = this.getGeometry();
                if (this.out_) {
                  var rotatedExtent = view.rotatedExtentForGeometry(geometry);
                  var resolution = view.getResolutionForExtentInternal(rotatedExtent);
                  var factor = view.getResolution() / resolution;
                  geometry = geometry.clone();
                  geometry.scale(factor * factor);
                }
                view.fitInternal(geometry, {
                  duration: this.duration_,
                  easing: easeOut
                });
              };
              return DragZoom;
            }(interaction_DragBox)
          );
          var interaction_DragZoom = DragZoom_DragZoom;
          var KeyCode = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
          };
          var KeyboardPan_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var KeyboardPan_KeyboardPan = (
            /** @class */
            function(_super) {
              KeyboardPan_extends(KeyboardPan, _super);
              function KeyboardPan(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options || {};
                _this.defaultCondition_ = function(mapBrowserEvent) {
                  return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
                };
                _this.condition_ = options.condition !== void 0 ? options.condition : _this.defaultCondition_;
                _this.duration_ = options.duration !== void 0 ? options.duration : 100;
                _this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
                return _this;
              }
              KeyboardPan.prototype.handleEvent = function(mapBrowserEvent) {
                var stopEvent = false;
                if (mapBrowserEvent.type == EventType[
                  "a"
                  /* default */
                ].KEYDOWN) {
                  var keyEvent = (
                    /** @type {KeyboardEvent} */
                    mapBrowserEvent.originalEvent
                  );
                  var keyCode = keyEvent.keyCode;
                  if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
                    var map = mapBrowserEvent.map;
                    var view = map.getView();
                    var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                    var deltaX = 0, deltaY = 0;
                    if (keyCode == KeyCode.DOWN) {
                      deltaY = -mapUnitsDelta;
                    } else if (keyCode == KeyCode.LEFT) {
                      deltaX = -mapUnitsDelta;
                    } else if (keyCode == KeyCode.RIGHT) {
                      deltaX = mapUnitsDelta;
                    } else {
                      deltaY = mapUnitsDelta;
                    }
                    var delta = [deltaX, deltaY];
                    coordinate_rotate(delta, view.getRotation());
                    pan(view, delta, this.duration_);
                    keyEvent.preventDefault();
                    stopEvent = true;
                  }
                }
                return !stopEvent;
              };
              return KeyboardPan;
            }(interaction_Interaction)
          );
          var interaction_KeyboardPan = KeyboardPan_KeyboardPan;
          var KeyboardZoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var KeyboardZoom_KeyboardZoom = (
            /** @class */
            function(_super) {
              KeyboardZoom_extends(KeyboardZoom, _super);
              function KeyboardZoom(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.condition_ = options.condition ? options.condition : targetNotEditable;
                _this.delta_ = options.delta ? options.delta : 1;
                _this.duration_ = options.duration !== void 0 ? options.duration : 100;
                return _this;
              }
              KeyboardZoom.prototype.handleEvent = function(mapBrowserEvent) {
                var stopEvent = false;
                if (mapBrowserEvent.type == EventType[
                  "a"
                  /* default */
                ].KEYDOWN || mapBrowserEvent.type == EventType[
                  "a"
                  /* default */
                ].KEYPRESS) {
                  var keyEvent = (
                    /** @type {KeyboardEvent} */
                    mapBrowserEvent.originalEvent
                  );
                  var charCode = keyEvent.charCode;
                  if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
                    var map = mapBrowserEvent.map;
                    var delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
                    var view = map.getView();
                    zoomByDelta(view, delta, void 0, this.duration_);
                    keyEvent.preventDefault();
                    stopEvent = true;
                  }
                }
                return !stopEvent;
              };
              return KeyboardZoom;
            }(interaction_Interaction)
          );
          var interaction_KeyboardZoom = KeyboardZoom_KeyboardZoom;
          var Kinetic = (
            /** @class */
            function() {
              function Kinetic2(decay, minVelocity, delay) {
                this.decay_ = decay;
                this.minVelocity_ = minVelocity;
                this.delay_ = delay;
                this.points_ = [];
                this.angle_ = 0;
                this.initialVelocity_ = 0;
              }
              Kinetic2.prototype.begin = function() {
                this.points_.length = 0;
                this.angle_ = 0;
                this.initialVelocity_ = 0;
              };
              Kinetic2.prototype.update = function(x, y) {
                this.points_.push(x, y, Date.now());
              };
              Kinetic2.prototype.end = function() {
                if (this.points_.length < 6) {
                  return false;
                }
                var delay = Date.now() - this.delay_;
                var lastIndex = this.points_.length - 3;
                if (this.points_[lastIndex + 2] < delay) {
                  return false;
                }
                var firstIndex = lastIndex - 3;
                while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
                  firstIndex -= 3;
                }
                var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
                if (duration < 1e3 / 60) {
                  return false;
                }
                var dx = this.points_[lastIndex] - this.points_[firstIndex];
                var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
                this.angle_ = Math.atan2(dy, dx);
                this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
                return this.initialVelocity_ > this.minVelocity_;
              };
              Kinetic2.prototype.getDistance = function() {
                return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
              };
              Kinetic2.prototype.getAngle = function() {
                return this.angle_;
              };
              return Kinetic2;
            }()
          );
          var ol_Kinetic = Kinetic;
          var MouseWheelZoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Mode = {
            TRACKPAD: "trackpad",
            WHEEL: "wheel"
          };
          var MouseWheelZoom_MouseWheelZoom = (
            /** @class */
            function(_super) {
              MouseWheelZoom_extends(MouseWheelZoom, _super);
              function MouseWheelZoom(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(
                  this,
                  /** @type {import("./Interaction.js").InteractionOptions} */
                  options
                ) || this;
                _this.totalDelta_ = 0;
                _this.lastDelta_ = 0;
                _this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                _this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
                _this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
                _this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
                var condition = options.condition ? options.condition : always;
                _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
                _this.lastAnchor_ = null;
                _this.startTime_ = void 0;
                _this.timeoutId_;
                _this.mode_ = void 0;
                _this.trackpadEventGap_ = 400;
                _this.trackpadTimeoutId_;
                _this.deltaPerZoom_ = 300;
                return _this;
              }
              MouseWheelZoom.prototype.endInteraction_ = function() {
                this.trackpadTimeoutId_ = void 0;
                var view = this.getMap().getView();
                view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
              };
              MouseWheelZoom.prototype.handleEvent = function(mapBrowserEvent) {
                if (!this.condition_(mapBrowserEvent)) {
                  return true;
                }
                var type = mapBrowserEvent.type;
                if (type !== EventType[
                  "a"
                  /* default */
                ].WHEEL) {
                  return true;
                }
                var map = mapBrowserEvent.map;
                var wheelEvent = (
                  /** @type {WheelEvent} */
                  mapBrowserEvent.originalEvent
                );
                wheelEvent.preventDefault();
                if (this.useAnchor_) {
                  this.lastAnchor_ = mapBrowserEvent.coordinate;
                }
                var delta;
                if (mapBrowserEvent.type == EventType[
                  "a"
                  /* default */
                ].WHEEL) {
                  delta = wheelEvent.deltaY;
                  if (has[
                    "b"
                    /* FIREFOX */
                  ] && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                    delta /= has[
                      "a"
                      /* DEVICE_PIXEL_RATIO */
                    ];
                  }
                  if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                    delta *= 40;
                  }
                }
                if (delta === 0) {
                  return false;
                } else {
                  this.lastDelta_ = delta;
                }
                var now = Date.now();
                if (this.startTime_ === void 0) {
                  this.startTime_ = now;
                }
                if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
                  this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
                }
                var view = map.getView();
                if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
                  if (this.trackpadTimeoutId_) {
                    clearTimeout(this.trackpadTimeoutId_);
                  } else {
                    if (view.getAnimating()) {
                      view.cancelAnimations();
                    }
                    view.beginInteraction();
                  }
                  this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
                  view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
                  this.startTime_ = now;
                  return false;
                }
                this.totalDelta_ += delta;
                var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
                clearTimeout(this.timeoutId_);
                this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
                return false;
              };
              MouseWheelZoom.prototype.handleWheelZoom_ = function(map) {
                var view = map.getView();
                if (view.getAnimating()) {
                  view.cancelAnimations();
                }
                var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
                if (view.getConstrainResolution() || this.constrainResolution_) {
                  delta = delta ? delta > 0 ? 1 : -1 : 0;
                }
                zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
                this.mode_ = void 0;
                this.totalDelta_ = 0;
                this.lastAnchor_ = null;
                this.startTime_ = void 0;
                this.timeoutId_ = void 0;
              };
              MouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {
                this.useAnchor_ = useAnchor;
                if (!useAnchor) {
                  this.lastAnchor_ = null;
                }
              };
              return MouseWheelZoom;
            }(interaction_Interaction)
          );
          var interaction_MouseWheelZoom = MouseWheelZoom_MouseWheelZoom;
          var PinchRotate_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var PinchRotate_PinchRotate = (
            /** @class */
            function(_super) {
              PinchRotate_extends(PinchRotate, _super);
              function PinchRotate(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var pointerOptions = (
                  /** @type {import("./Pointer.js").Options} */
                  options
                );
                if (!pointerOptions.stopDown) {
                  pointerOptions.stopDown = functions[
                    "a"
                    /* FALSE */
                  ];
                }
                _this = _super.call(this, pointerOptions) || this;
                _this.anchor_ = null;
                _this.lastAngle_ = void 0;
                _this.rotating_ = false;
                _this.rotationDelta_ = 0;
                _this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
                _this.duration_ = options.duration !== void 0 ? options.duration : 250;
                return _this;
              }
              PinchRotate.prototype.handleDragEvent = function(mapBrowserEvent) {
                var rotationDelta = 0;
                var touch0 = this.targetPointers[0];
                var touch1 = this.targetPointers[1];
                var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
                if (this.lastAngle_ !== void 0) {
                  var delta = angle - this.lastAngle_;
                  this.rotationDelta_ += delta;
                  if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                    this.rotating_ = true;
                  }
                  rotationDelta = delta;
                }
                this.lastAngle_ = angle;
                var map = mapBrowserEvent.map;
                var view = map.getView();
                if (view.getConstraints().rotation === disable) {
                  return;
                }
                var viewportPosition = map.getViewport().getBoundingClientRect();
                var centroid = Pointer_centroid(this.targetPointers);
                centroid[0] -= viewportPosition.left;
                centroid[1] -= viewportPosition.top;
                this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
                if (this.rotating_) {
                  map.render();
                  view.adjustRotationInternal(rotationDelta, this.anchor_);
                }
              };
              PinchRotate.prototype.handleUpEvent = function(mapBrowserEvent) {
                if (this.targetPointers.length < 2) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  view.endInteraction(this.duration_);
                  return false;
                } else {
                  return true;
                }
              };
              PinchRotate.prototype.handleDownEvent = function(mapBrowserEvent) {
                if (this.targetPointers.length >= 2) {
                  var map = mapBrowserEvent.map;
                  this.anchor_ = null;
                  this.lastAngle_ = void 0;
                  this.rotating_ = false;
                  this.rotationDelta_ = 0;
                  if (!this.handlingDownUpSequence) {
                    map.getView().beginInteraction();
                  }
                  return true;
                } else {
                  return false;
                }
              };
              return PinchRotate;
            }(Pointer)
          );
          var interaction_PinchRotate = PinchRotate_PinchRotate;
          var PinchZoom_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var PinchZoom_PinchZoom = (
            /** @class */
            function(_super) {
              PinchZoom_extends(PinchZoom, _super);
              function PinchZoom(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var pointerOptions = (
                  /** @type {import("./Pointer.js").Options} */
                  options
                );
                if (!pointerOptions.stopDown) {
                  pointerOptions.stopDown = functions[
                    "a"
                    /* FALSE */
                  ];
                }
                _this = _super.call(this, pointerOptions) || this;
                _this.anchor_ = null;
                _this.duration_ = options.duration !== void 0 ? options.duration : 400;
                _this.lastDistance_ = void 0;
                _this.lastScaleDelta_ = 1;
                return _this;
              }
              PinchZoom.prototype.handleDragEvent = function(mapBrowserEvent) {
                var scaleDelta = 1;
                var touch0 = this.targetPointers[0];
                var touch1 = this.targetPointers[1];
                var dx = touch0.clientX - touch1.clientX;
                var dy = touch0.clientY - touch1.clientY;
                var distance = Math.sqrt(dx * dx + dy * dy);
                if (this.lastDistance_ !== void 0) {
                  scaleDelta = this.lastDistance_ / distance;
                }
                this.lastDistance_ = distance;
                var map = mapBrowserEvent.map;
                var view = map.getView();
                if (scaleDelta != 1) {
                  this.lastScaleDelta_ = scaleDelta;
                }
                var viewportPosition = map.getViewport().getBoundingClientRect();
                var centroid = Pointer_centroid(this.targetPointers);
                centroid[0] -= viewportPosition.left;
                centroid[1] -= viewportPosition.top;
                this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
                map.render();
                view.adjustResolutionInternal(scaleDelta, this.anchor_);
              };
              PinchZoom.prototype.handleUpEvent = function(mapBrowserEvent) {
                if (this.targetPointers.length < 2) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
                  view.endInteraction(this.duration_, direction);
                  return false;
                } else {
                  return true;
                }
              };
              PinchZoom.prototype.handleDownEvent = function(mapBrowserEvent) {
                if (this.targetPointers.length >= 2) {
                  var map = mapBrowserEvent.map;
                  this.anchor_ = null;
                  this.lastDistance_ = void 0;
                  this.lastScaleDelta_ = 1;
                  if (!this.handlingDownUpSequence) {
                    map.getView().beginInteraction();
                  }
                  return true;
                } else {
                  return false;
                }
              };
              return PinchZoom;
            }(Pointer)
          );
          var interaction_PinchZoom = PinchZoom_PinchZoom;
          function interaction_defaults(opt_options) {
            var options = opt_options ? opt_options : {};
            var interactions = new ol_Collection();
            var kinetic = new ol_Kinetic(-5e-3, 0.05, 100);
            var altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
            if (altShiftDragRotate) {
              interactions.push(new interaction_DragRotate());
            }
            var doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
            if (doubleClickZoom) {
              interactions.push(new interaction_DoubleClickZoom({
                delta: options.zoomDelta,
                duration: options.zoomDuration
              }));
            }
            var dragPan = options.dragPan !== void 0 ? options.dragPan : true;
            if (dragPan) {
              interactions.push(new interaction_DragPan({
                onFocusOnly: options.onFocusOnly,
                kinetic
              }));
            }
            var pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
            if (pinchRotate) {
              interactions.push(new interaction_PinchRotate());
            }
            var pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
            if (pinchZoom) {
              interactions.push(new interaction_PinchZoom({
                duration: options.zoomDuration
              }));
            }
            var keyboard = options.keyboard !== void 0 ? options.keyboard : true;
            if (keyboard) {
              interactions.push(new interaction_KeyboardPan());
              interactions.push(new interaction_KeyboardZoom({
                delta: options.zoomDelta,
                duration: options.zoomDuration
              }));
            }
            var mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
            if (mouseWheelZoom) {
              interactions.push(new interaction_MouseWheelZoom({
                onFocusOnly: options.onFocusOnly,
                duration: options.zoomDuration
              }));
            }
            var shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
            if (shiftDragZoom) {
              interactions.push(new interaction_DragZoom({
                duration: options.zoomDuration
              }));
            }
            return interactions;
          }
          var ol_Map_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Map_Map = (
            /** @class */
            function(_super) {
              ol_Map_extends(Map2, _super);
              function Map2(options) {
                var _this = this;
                options = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options);
                if (!options.controls) {
                  options.controls = defaults();
                }
                if (!options.interactions) {
                  options.interactions = interaction_defaults({
                    onFocusOnly: true
                  });
                }
                _this = _super.call(this, options) || this;
                return _this;
              }
              Map2.prototype.createRenderer = function() {
                return new Composite(this);
              };
              return Map2;
            }(ol_PluggableMap)
          );
          var ol_Map = Map_Map;
          var es_object_keys = __webpack_require__("b64b");
          var es_symbol = __webpack_require__("a4d3");
          var es_array_filter = __webpack_require__("4de4");
          var es_object_get_own_property_descriptor = __webpack_require__("e439");
          var web_dom_collections_for_each = __webpack_require__("159b");
          var es_object_get_own_property_descriptors = __webpack_require__("dbb4");
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly) {
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              }
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread2(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          var es_array_includes = __webpack_require__("caad");
          var es_string_includes = __webpack_require__("2532");
          function usePropsAsObjectProperties(props) {
            var ignoredKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var options = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
            Object.keys(options).forEach(function(key) {
              options[key] = options[key].value;
            });
            var properties = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])(_objectSpread2({}, options));
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(props, function() {
              options = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
              Object.keys(options).forEach(function(key) {
                if (properties[key] != options[key].value && !ignoredKeys.includes(key)) {
                  properties[key] = options[key].value;
                }
              });
            });
            return {
              properties
            };
          }
          var Mapvue_type_script_lang_js = {
            name: "ol-map",
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var mapRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
              var map = new ol_Map(properties);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                map.setProperties(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.setTarget(mapRef.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.setTarget(null);
                map = null;
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("map", map);
              var focus = function focus2() {
                return map.focus();
              };
              var forEachFeatureAtPixel = function forEachFeatureAtPixel2(pixel, callback) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                return map.forEachFeatureAtPixel(pixel, callback, options);
              };
              var forEachLayerAtPixel = function forEachLayerAtPixel2(pixel, callback, layerFilter) {
                return map.forEachLayerAtPixel(pixel, callback, layerFilter);
              };
              var getCoordinateFromPixel = function getCoordinateFromPixel2(pixel) {
                return map.getCoordinateFromPixel(pixel);
              };
              var refresh = function refresh2() {
                return map.refresh();
              };
              var render = function render2() {
                return map.render();
              };
              var updateSize = function updateSize2() {
                return map.updateSize();
              };
              map.on("click", function(event) {
                return emit("click", event);
              });
              map.on("dblclick", function(event) {
                return emit("dblclick", event);
              });
              map.on("singleclick", function(event) {
                return emit("singleclick", event);
              });
              map.on("pointerdrag", function(event) {
                return emit("pointerdrag", event);
              });
              map.on("pointermove", function(event) {
                return emit("pointermove", event);
              });
              map.on("movestart", function(event) {
                return emit("movestart", event);
              });
              map.on("moveend", function(event) {
                return emit("moveend", event);
              });
              map.on("postrender", function(event) {
                return emit("postrender", event);
              });
              map.on("precompose", function(event) {
                return emit("precompose", event);
              });
              map.on("postcompose", function(event) {
                return emit("postcompose", event);
              });
              return {
                map,
                mapRef,
                focus,
                forEachFeatureAtPixel,
                forEachLayerAtPixel,
                getCoordinateFromPixel,
                refresh,
                render,
                updateSize
              };
            },
            props: {
              loadTilesWhileAnimating: {
                type: Boolean,
                default: false
              },
              loadTilesWhileInteracting: {
                type: Boolean,
                default: false
              },
              moveTolerance: {
                type: Number,
                default: 1
              },
              pixelRatio: {
                type: Number,
                default: 1
              },
              controls: {
                type: Array,
                default: function _default() {
                  return [];
                }
              }
            }
          };
          Mapvue_type_script_lang_js.render = Mapvue_type_template_id_39e43851_lang_true_render;
          var map_Map = Mapvue_type_script_lang_js;
          var _hoisted_1 = {
            key: 0
          };
          function Viewvue_type_template_id_1a31c3c4_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          function useView(props, emit) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createProp = function createProp2() {
              return _objectSpread2(_objectSpread2({}, properties), {}, {
                projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection))
              });
            };
            var view = new ol_View(createProp());
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.setView(view);
            });
            view.on("change:center", function() {
              emit("centerChanged", getCenter());
              emit("zoomChanged", getZoom());
            });
            view.on("change:resolution", function() {
              return emit("resolutionChanged", getResolution());
            });
            view.on("change:rotation", function() {
              return emit("rotationChanged", getRotation());
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              var pr = createProp();
              view.setProperties(pr);
              view.applyOptions_(pr);
            });
            var adjustCenter = function adjustCenter2(deltaCoordinates) {
              return view.adjustCenter(deltaCoordinates);
            };
            var adjustResolution = function adjustResolution2(ratio, opt_anchor) {
              return view.adjustResolution(ratio, opt_anchor);
            };
            var adjustRotation = function adjustRotation2(delta, opt_anchor) {
              return view.adjustRotation(delta, opt_anchor);
            };
            var adjustZoom = function adjustZoom2(delta, opt_anchor) {
              return view.adjustZoom(delta, opt_anchor);
            };
            var animate = function animate2(var_args) {
              return view.animate(var_args);
            };
            var beginInteraction = function beginInteraction2() {
              return view.beginInteraction();
            };
            var calculateExtent = function calculateExtent2(opt_size) {
              return view.calculateExtent(opt_size);
            };
            var cancelAnimations = function cancelAnimations2() {
              return view.cancelAnimations();
            };
            var centerOn = function centerOn2(coordinate, size, position) {
              return view.centerOn(coordinate, size, position);
            };
            var changed = function changed2() {
              return view.changed();
            };
            var dispatchEvent = function dispatchEvent2(event) {
              return view.dispatchEvent(event);
            };
            var endInteraction = function endInteraction2(opt_duration, opt_resolutionDirection, opt_anchor) {
              return view.endInteraction(opt_duration, opt_resolutionDirection, opt_anchor);
            };
            var fit = function fit2(geometryOrExtent, opt_options) {
              return view.fit(geometryOrExtent, opt_options);
            };
            var get = function get2(key) {
              return view.get(key);
            };
            var getAnimating = function getAnimating2() {
              return view.getAnimating();
            };
            var getCenter = function getCenter2() {
              return view.getCenter();
            };
            var getInteracting = function getInteracting2() {
              return view.getInteracting();
            };
            var getKeys = function getKeys2() {
              return view.getKeys();
            };
            var getMaxResolution = function getMaxResolution2() {
              return view.getMaxResolution();
            };
            var getMaxZoom = function getMaxZoom2() {
              return view.getMaxZoom();
            };
            var getMinResolution = function getMinResolution2() {
              return view.getMinResolution();
            };
            var getMinZoom = function getMinZoom2() {
              return view.getMinZoom();
            };
            var getProjection = function getProjection2() {
              return view.getProjection();
            };
            var getProperties = function getProperties2() {
              return view.getProperties();
            };
            var getResolution = function getResolution2() {
              return view.getResolution();
            };
            var getResolutionForExtent = function getResolutionForExtent2(extent, opt_size) {
              return view.getResolutionForExtent(extent, opt_size);
            };
            var getResolutionForZoom = function getResolutionForZoom2(zoom) {
              return view.getResolutionForZoom(zoom);
            };
            var getResolutions = function getResolutions2() {
              return view.getResolutions();
            };
            var getRevision = function getRevision2() {
              return view.getRevision();
            };
            var getRotation = function getRotation2() {
              return view.getRotation();
            };
            var getZoom = function getZoom2() {
              return view.getZoom();
            };
            var getZoomForResolution = function getZoomForResolution2(resolution) {
              return view.getZoomForResolution(resolution);
            };
            var setCenter = function setCenter2(center) {
              return view.setCenter(center);
            };
            var setConstrainResolution = function setConstrainResolution2(enabled) {
              return view.setConstrainResolution(enabled);
            };
            var setMaxZoom = function setMaxZoom2(zoom) {
              return view.setMaxZoom(zoom);
            };
            var setMinZoom = function setMinZoom2(zoom) {
              return view.setMinZoom(zoom);
            };
            var setResolution = function setResolution2(resolution) {
              return view.setResolution(resolution);
            };
            var setRotation = function setRotation2(rotation) {
              return view.setRotation(rotation);
            };
            var setZoom = function setZoom2(zoom) {
              return view.setZoom(zoom);
            };
            return {
              view,
              adjustCenter,
              adjustResolution,
              adjustRotation,
              adjustZoom,
              animate,
              beginInteraction,
              calculateExtent,
              cancelAnimations,
              centerOn,
              changed,
              dispatchEvent,
              endInteraction,
              fit,
              get,
              getAnimating,
              getCenter,
              getInteracting,
              getKeys,
              getMaxResolution,
              getMaxZoom,
              getMinResolution,
              getMinZoom,
              getProjection,
              getProperties,
              getResolution,
              getResolutionForExtent,
              getResolutionForZoom,
              getResolutions,
              getRevision,
              getRotation,
              getZoom,
              getZoomForResolution,
              setCenter,
              setConstrainResolution,
              setMaxZoom,
              setMinZoom,
              setResolution,
              setRotation,
              setZoom
            };
          }
          var Viewvue_type_script_lang_js = {
            name: "ol-view",
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var view = useView(props, emit);
              return _objectSpread2({}, view);
            },
            props: {
              center: {
                type: Array,
                default: function _default() {
                  return [0, 0];
                }
              },
              constrainRotation: {
                type: Boolean,
                default: true
              },
              enableRotation: {
                type: Boolean,
                default: true
              },
              extent: {
                type: Array
              },
              constrainOnlyCenter: {
                type: Boolean,
                default: false
              },
              smoothExtentConstraint: {
                type: Boolean,
                default: true
              },
              maxResolution: {
                type: Number
              },
              minResolution: {
                type: Number
              },
              maxZoom: {
                type: Number,
                default: 28
              },
              minZoom: {
                type: Number,
                default: 0
              },
              multiWorld: {
                type: Boolean,
                default: false
              },
              constrainResolution: {
                type: Boolean,
                default: false
              },
              smoothResolutionConstraint: {
                type: Boolean,
                default: true
              },
              showFullExtent: {
                type: Boolean,
                default: false
              },
              projection: {
                type: [String, Object],
                default: "EPSG:3857"
              },
              resolution: {
                type: Number
              },
              resolutions: {
                type: Array
              },
              rotation: {
                type: Number
              },
              zoom: {
                type: Number,
                default: 0
              },
              zoomFactor: {
                type: Number,
                default: 2
              },
              padding: {
                type: Array,
                default: function _default() {
                  return [0, 0, 0, 0];
                }
              }
            }
          };
          Viewvue_type_script_lang_js.render = Viewvue_type_template_id_1a31c3c4_lang_true_render;
          var map_View = Viewvue_type_script_lang_js;
          function Featurevue_type_template_id_11090cc7_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var Feature_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Feature_Feature = (
            /** @class */
            function(_super) {
              Feature_extends(Feature, _super);
              function Feature(opt_geometryOrProperties) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.id_ = void 0;
                _this.geometryName_ = "geometry";
                _this.style_ = null;
                _this.styleFunction_ = void 0;
                _this.geometryChangeKey_ = null;
                _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
                if (opt_geometryOrProperties) {
                  if (typeof /** @type {?} */
                  opt_geometryOrProperties.getSimplifiedGeometry === "function") {
                    var geometry = (
                      /** @type {Geometry} */
                      opt_geometryOrProperties
                    );
                    _this.setGeometry(geometry);
                  } else {
                    var properties = opt_geometryOrProperties;
                    _this.setProperties(properties);
                  }
                }
                return _this;
              }
              Feature.prototype.clone = function() {
                var clone2 = new Feature(this.hasProperties() ? this.getProperties() : null);
                clone2.setGeometryName(this.getGeometryName());
                var geometry = this.getGeometry();
                if (geometry) {
                  clone2.setGeometry(geometry.clone());
                }
                var style = this.getStyle();
                if (style) {
                  clone2.setStyle(style);
                }
                return clone2;
              };
              Feature.prototype.getGeometry = function() {
                return (
                  /** @type {Geometry|undefined} */
                  this.get(this.geometryName_)
                );
              };
              Feature.prototype.getId = function() {
                return this.id_;
              };
              Feature.prototype.getGeometryName = function() {
                return this.geometryName_;
              };
              Feature.prototype.getStyle = function() {
                return this.style_;
              };
              Feature.prototype.getStyleFunction = function() {
                return this.styleFunction_;
              };
              Feature.prototype.handleGeometryChange_ = function() {
                this.changed();
              };
              Feature.prototype.handleGeometryChanged_ = function() {
                if (this.geometryChangeKey_) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.geometryChangeKey_);
                  this.geometryChangeKey_ = null;
                }
                var geometry = this.getGeometry();
                if (geometry) {
                  this.geometryChangeKey_ = Object(events[
                    "a"
                    /* listen */
                  ])(geometry, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleGeometryChange_, this);
                }
                this.changed();
              };
              Feature.prototype.setGeometry = function(geometry) {
                this.set(this.geometryName_, geometry);
              };
              Feature.prototype.setStyle = function(opt_style) {
                this.style_ = opt_style;
                this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);
                this.changed();
              };
              Feature.prototype.setId = function(id) {
                this.id_ = id;
                this.changed();
              };
              Feature.prototype.setGeometryName = function(name) {
                this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
                this.geometryName_ = name;
                this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
                this.handleGeometryChanged_();
              };
              return Feature;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          function createStyleFunction(obj) {
            if (typeof obj === "function") {
              return obj;
            } else {
              var styles_1;
              if (Array.isArray(obj)) {
                styles_1 = obj;
              } else {
                assert2(typeof /** @type {?} */
                obj.getZIndex === "function", 41);
                var style = (
                  /** @type {import("./style/Style.js").default} */
                  obj
                );
                styles_1 = [style];
              }
              return function() {
                return styles_1;
              };
            }
          }
          var ol_Feature = Feature_Feature;
          var Featurevue_type_script_lang_js = {
            name: "ol-feature",
            setup: function setup(props) {
              var vectorSource = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
              var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
              var animation = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("animation", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var feature = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var f = new ol_Feature(properties);
                return f;
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(feature, function(newVal, oldVal) {
                vectorSource.value.removeFeature(oldVal);
                vectorSource.value.addFeature(newVal);
                vectorSource.value.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(vectorSource, function(newVal, oldVal) {
                oldVal.removeFeature(feature.value);
                newVal.addFeature(feature.value);
                newVal.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                vectorSource.value.addFeature(feature.value);
                if (animation != null) {
                  vectorLayer.value.animateFeature(feature.value, animation.value);
                }
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                vectorSource.value.removeFeature(feature.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("feature", feature);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", feature);
            },
            props: {
              geometryOrProperties: {
                type: [geom_Geometry, Object, Array]
              }
            }
          };
          Featurevue_type_script_lang_js.render = Featurevue_type_template_id_11090cc7_lang_true_render;
          var map_Feature = Featurevue_type_script_lang_js;
          var Overlayvue_type_template_id_fdec3864_lang_true_hoisted_1 = {
            ref: "htmlContent"
          };
          function Overlayvue_type_template_id_fdec3864_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", Overlayvue_type_template_id_fdec3864_lang_true_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
              position: $props.position
            })], 512);
          }
          var OverlayPositioning = {
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_CENTER: "bottom-center",
            BOTTOM_RIGHT: "bottom-right",
            CENTER_LEFT: "center-left",
            CENTER_CENTER: "center-center",
            CENTER_RIGHT: "center-right",
            TOP_LEFT: "top-left",
            TOP_CENTER: "top-center",
            TOP_RIGHT: "top-right"
          };
          var Overlay_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Overlay_Property = {
            ELEMENT: "element",
            MAP: "map",
            OFFSET: "offset",
            POSITION: "position",
            POSITIONING: "positioning"
          };
          var Overlay_Overlay = (
            /** @class */
            function(_super) {
              Overlay_extends(Overlay, _super);
              function Overlay(options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.options = options;
                _this.id = options.id;
                _this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
                _this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
                _this.element = document.createElement("div");
                _this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
                _this.element.style.position = "absolute";
                _this.element.style.pointerEvents = "auto";
                var autoPan = options.autoPan;
                if (autoPan && "object" !== typeof autoPan) {
                  autoPan = {
                    animation: options.autoPanAnimation,
                    margin: options.autoPanMargin
                  };
                }
                _this.autoPan = /** @type {PanIntoViewOptions} */
                autoPan || false;
                _this.rendered = {
                  transform_: "",
                  visible: true
                };
                _this.mapPostrenderListenerKey = null;
                _this.addChangeListener(Overlay_Property.ELEMENT, _this.handleElementChanged);
                _this.addChangeListener(Overlay_Property.MAP, _this.handleMapChanged);
                _this.addChangeListener(Overlay_Property.OFFSET, _this.handleOffsetChanged);
                _this.addChangeListener(Overlay_Property.POSITION, _this.handlePositionChanged);
                _this.addChangeListener(Overlay_Property.POSITIONING, _this.handlePositioningChanged);
                if (options.element !== void 0) {
                  _this.setElement(options.element);
                }
                _this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
                _this.setPositioning(options.positioning !== void 0 ? (
                  /** @type {import("./OverlayPositioning.js").default} */
                  options.positioning
                ) : OverlayPositioning.TOP_LEFT);
                if (options.position !== void 0) {
                  _this.setPosition(options.position);
                }
                return _this;
              }
              Overlay.prototype.getElement = function() {
                return (
                  /** @type {HTMLElement|undefined} */
                  this.get(Overlay_Property.ELEMENT)
                );
              };
              Overlay.prototype.getId = function() {
                return this.id;
              };
              Overlay.prototype.getMap = function() {
                return (
                  /** @type {import("./PluggableMap.js").default|undefined} */
                  this.get(Overlay_Property.MAP)
                );
              };
              Overlay.prototype.getOffset = function() {
                return (
                  /** @type {Array<number>} */
                  this.get(Overlay_Property.OFFSET)
                );
              };
              Overlay.prototype.getPosition = function() {
                return (
                  /** @type {import("./coordinate.js").Coordinate|undefined} */
                  this.get(Overlay_Property.POSITION)
                );
              };
              Overlay.prototype.getPositioning = function() {
                return (
                  /** @type {import("./OverlayPositioning.js").default} */
                  this.get(Overlay_Property.POSITIONING)
                );
              };
              Overlay.prototype.handleElementChanged = function() {
                Object(dom[
                  "d"
                  /* removeChildren */
                ])(this.element);
                var element = this.getElement();
                if (element) {
                  this.element.appendChild(element);
                }
              };
              Overlay.prototype.handleMapChanged = function() {
                if (this.mapPostrenderListenerKey) {
                  Object(dom[
                    "e"
                    /* removeNode */
                  ])(this.element);
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.mapPostrenderListenerKey);
                  this.mapPostrenderListenerKey = null;
                }
                var map = this.getMap();
                if (map) {
                  this.mapPostrenderListenerKey = Object(events[
                    "a"
                    /* listen */
                  ])(map, MapEventType[
                    "a"
                    /* default */
                  ].POSTRENDER, this.render, this);
                  this.updatePixelPosition();
                  var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
                  if (this.insertFirst) {
                    container.insertBefore(this.element, container.childNodes[0] || null);
                  } else {
                    container.appendChild(this.element);
                  }
                  this.performAutoPan();
                }
              };
              Overlay.prototype.render = function() {
                this.updatePixelPosition();
              };
              Overlay.prototype.handleOffsetChanged = function() {
                this.updatePixelPosition();
              };
              Overlay.prototype.handlePositionChanged = function() {
                this.updatePixelPosition();
                this.performAutoPan();
              };
              Overlay.prototype.handlePositioningChanged = function() {
                this.updatePixelPosition();
              };
              Overlay.prototype.setElement = function(element) {
                this.set(Overlay_Property.ELEMENT, element);
              };
              Overlay.prototype.setMap = function(map) {
                this.set(Overlay_Property.MAP, map);
              };
              Overlay.prototype.setOffset = function(offset) {
                this.set(Overlay_Property.OFFSET, offset);
              };
              Overlay.prototype.setPosition = function(position) {
                this.set(Overlay_Property.POSITION, position);
              };
              Overlay.prototype.performAutoPan = function() {
                if (this.autoPan) {
                  this.panIntoView(this.autoPan);
                }
              };
              Overlay.prototype.panIntoView = function(opt_panIntoViewOptions) {
                var map = this.getMap();
                if (!map || !map.getTargetElement() || !this.get(Overlay_Property.POSITION)) {
                  return;
                }
                var mapRect = this.getRect(map.getTargetElement(), map.getSize());
                var element = this.getElement();
                var overlayRect = this.getRect(element, [
                  Object(dom[
                    "c"
                    /* outerWidth */
                  ])(element),
                  Object(dom[
                    "b"
                    /* outerHeight */
                  ])(element)
                ]);
                var panIntoViewOptions = opt_panIntoViewOptions || {};
                var myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
                if (!containsExtent(mapRect, overlayRect)) {
                  var offsetLeft = overlayRect[0] - mapRect[0];
                  var offsetRight = mapRect[2] - overlayRect[2];
                  var offsetTop = overlayRect[1] - mapRect[1];
                  var offsetBottom = mapRect[3] - overlayRect[3];
                  var delta = [0, 0];
                  if (offsetLeft < 0) {
                    delta[0] = offsetLeft - myMargin;
                  } else if (offsetRight < 0) {
                    delta[0] = Math.abs(offsetRight) + myMargin;
                  }
                  if (offsetTop < 0) {
                    delta[1] = offsetTop - myMargin;
                  } else if (offsetBottom < 0) {
                    delta[1] = Math.abs(offsetBottom) + myMargin;
                  }
                  if (delta[0] !== 0 || delta[1] !== 0) {
                    var center = (
                      /** @type {import("./coordinate.js").Coordinate} */
                      map.getView().getCenterInternal()
                    );
                    var centerPx = map.getPixelFromCoordinateInternal(center);
                    if (!centerPx) {
                      return;
                    }
                    var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                    var panOptions = panIntoViewOptions.animation || {};
                    map.getView().animateInternal({
                      center: map.getCoordinateFromPixelInternal(newCenterPx),
                      duration: panOptions.duration,
                      easing: panOptions.easing
                    });
                  }
                }
              };
              Overlay.prototype.getRect = function(element, size) {
                var box = element.getBoundingClientRect();
                var offsetX = box.left + window.pageXOffset;
                var offsetY = box.top + window.pageYOffset;
                return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
              };
              Overlay.prototype.setPositioning = function(positioning) {
                this.set(Overlay_Property.POSITIONING, positioning);
              };
              Overlay.prototype.setVisible = function(visible) {
                if (this.rendered.visible !== visible) {
                  this.element.style.display = visible ? "" : "none";
                  this.rendered.visible = visible;
                }
              };
              Overlay.prototype.updatePixelPosition = function() {
                var map = this.getMap();
                var position = this.getPosition();
                if (!map || !map.isRendered() || !position) {
                  this.setVisible(false);
                  return;
                }
                var pixel = map.getPixelFromCoordinate(position);
                var mapSize = map.getSize();
                this.updateRenderedPosition(pixel, mapSize);
              };
              Overlay.prototype.updateRenderedPosition = function(pixel, mapSize) {
                var style = this.element.style;
                var offset = this.getOffset();
                var positioning = this.getPositioning();
                this.setVisible(true);
                var x = Math.round(pixel[0] + offset[0]) + "px";
                var y = Math.round(pixel[1] + offset[1]) + "px";
                var posX = "0%";
                var posY = "0%";
                if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {
                  posX = "-100%";
                } else if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {
                  posX = "-50%";
                }
                if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {
                  posY = "-100%";
                } else if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {
                  posY = "-50%";
                }
                var transform2 = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
                if (this.rendered.transform_ != transform2) {
                  this.rendered.transform_ = transform2;
                  style.transform = transform2;
                  style.msTransform = transform2;
                }
              };
              Overlay.prototype.getOptions = function() {
                return this.options;
              };
              return Overlay;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          var ol_Overlay = Overlay_Overlay;
          function useOverlay(props, emit) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var htmlContent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var overlay = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new ol_Overlay(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addOverlay(overlay.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeOverlay(overlay.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(overlay, function(newVal, oldVal) {
              map.removeOverlay(oldVal);
              map.addOverlay(newVal);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(function() {
              setElement(htmlContent.value);
            }, {
              flush: "post"
            });
            overlay.value.on("change:element", function() {
              return emit("elementChanged", getElement());
            });
            overlay.value.on("change:offset", function() {
              return emit("offsetChanged", getOffset());
            });
            overlay.value.on("change:position", function() {
              return emit("positionChanged", getPosition());
            });
            overlay.value.on("change:positioning", function() {
              return emit("positioningChanged", getPositioning());
            });
            var getElement = function getElement2() {
              return overlay.value.getElement();
            };
            var getOffset = function getOffset2() {
              return overlay.value.getOffset();
            };
            var getPosition = function getPosition2() {
              return overlay.value.getPosition();
            };
            var getPositioning = function getPositioning2() {
              return overlay.value.getPositioning();
            };
            var panIntoView = function panIntoView2(opt_panIntoViewOptions) {
              return overlay.value.panIntoView(opt_panIntoViewOptions);
            };
            var setElement = function setElement2(element) {
              return overlay.value.setElement(element);
            };
            var setOffset = function setOffset2(offset) {
              return overlay.value.setOffset(offset);
            };
            var setPosition = function setPosition2(position) {
              return overlay.value.setPosition(position);
            };
            var setPositioning = function setPositioning2(positioning) {
              return overlay.value.setPositioning(positioning);
            };
            return {
              overlay,
              htmlContent,
              getOffset,
              getPosition,
              getPositioning,
              panIntoView,
              setElement,
              setOffset,
              setPosition,
              setPositioning
            };
          }
          var Overlayvue_type_script_lang_js = {
            name: "ol-overlay",
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var overlay = new useOverlay(props, emit);
              return _objectSpread2({}, overlay);
            },
            props: {
              position: {
                type: Array
              },
              offset: {
                type: Array
              },
              positioning: {
                type: Array
              },
              stopEvent: {
                type: Boolean,
                default: true
              },
              insertFirst: {
                type: Boolean,
                default: true
              },
              autoPan: {
                type: Boolean,
                default: false
              },
              autoPanMargin: {
                type: Number,
                default: 20
              },
              autoPanAnimation: {
                type: Object,
                default: void 0
              }
            }
          };
          Overlayvue_type_script_lang_js.render = Overlayvue_type_template_id_fdec3864_lang_true_render;
          var map_Overlay = Overlayvue_type_script_lang_js;
          function GeoLocationvue_type_template_id_4348a5ab_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
              position: $setup.position,
              speed: $setup.speed,
              heading: $setup.heading,
              accuracy: $setup.accuracy,
              altitude: $setup.altitude,
              altitudeAccuracy: $setup.altitudeAccuracy,
              accuracyGeometry: $setup.accuracyGeometry
            });
          }
          var Geolocation_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Geolocation_Property = {
            ACCURACY: "accuracy",
            ACCURACY_GEOMETRY: "accuracyGeometry",
            ALTITUDE: "altitude",
            ALTITUDE_ACCURACY: "altitudeAccuracy",
            HEADING: "heading",
            POSITION: "position",
            PROJECTION: "projection",
            SPEED: "speed",
            TRACKING: "tracking",
            TRACKING_OPTIONS: "trackingOptions"
          };
          var Geolocation_GeolocationError = (
            /** @class */
            function(_super) {
              Geolocation_extends(GeolocationError, _super);
              function GeolocationError(error) {
                var _this = _super.call(this, EventType[
                  "a"
                  /* default */
                ].ERROR) || this;
                _this.code = error.code;
                _this.message = error.message;
                return _this;
              }
              return GeolocationError;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Geolocation_Geolocation = (
            /** @class */
            function(_super) {
              Geolocation_extends(Geolocation, _super);
              function Geolocation(opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var options = opt_options || {};
                _this.position_ = null;
                _this.transform_ = identityTransform;
                _this.watchId_ = void 0;
                _this.addChangeListener(Geolocation_Property.PROJECTION, _this.handleProjectionChanged_);
                _this.addChangeListener(Geolocation_Property.TRACKING, _this.handleTrackingChanged_);
                if (options.projection !== void 0) {
                  _this.setProjection(options.projection);
                }
                if (options.trackingOptions !== void 0) {
                  _this.setTrackingOptions(options.trackingOptions);
                }
                _this.setTracking(options.tracking !== void 0 ? options.tracking : false);
                return _this;
              }
              Geolocation.prototype.disposeInternal = function() {
                this.setTracking(false);
                _super.prototype.disposeInternal.call(this);
              };
              Geolocation.prototype.handleProjectionChanged_ = function() {
                var projection = this.getProjection();
                if (projection) {
                  this.transform_ = getTransformFromProjections(proj_get("EPSG:4326"), projection);
                  if (this.position_) {
                    this.set(Geolocation_Property.POSITION, this.transform_(this.position_));
                  }
                }
              };
              Geolocation.prototype.handleTrackingChanged_ = function() {
                if ("geolocation" in navigator) {
                  var tracking = this.getTracking();
                  if (tracking && this.watchId_ === void 0) {
                    this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
                  } else if (!tracking && this.watchId_ !== void 0) {
                    navigator.geolocation.clearWatch(this.watchId_);
                    this.watchId_ = void 0;
                  }
                }
              };
              Geolocation.prototype.positionChange_ = function(position) {
                var coords = position.coords;
                this.set(Geolocation_Property.ACCURACY, coords.accuracy);
                this.set(Geolocation_Property.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);
                this.set(Geolocation_Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);
                this.set(Geolocation_Property.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));
                if (!this.position_) {
                  this.position_ = [coords.longitude, coords.latitude];
                } else {
                  this.position_[0] = coords.longitude;
                  this.position_[1] = coords.latitude;
                }
                var projectedPosition = this.transform_(this.position_);
                this.set(Geolocation_Property.POSITION, projectedPosition);
                this.set(Geolocation_Property.SPEED, coords.speed === null ? void 0 : coords.speed);
                var geometry = circular(this.position_, coords.accuracy);
                geometry.applyTransform(this.transform_);
                this.set(Geolocation_Property.ACCURACY_GEOMETRY, geometry);
                this.changed();
              };
              Geolocation.prototype.positionError_ = function(error) {
                this.dispatchEvent(new Geolocation_GeolocationError(error));
              };
              Geolocation.prototype.getAccuracy = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(Geolocation_Property.ACCURACY)
                );
              };
              Geolocation.prototype.getAccuracyGeometry = function() {
                return (
                  /** @type {?import("./geom/Polygon.js").default} */
                  this.get(Geolocation_Property.ACCURACY_GEOMETRY) || null
                );
              };
              Geolocation.prototype.getAltitude = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(Geolocation_Property.ALTITUDE)
                );
              };
              Geolocation.prototype.getAltitudeAccuracy = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(Geolocation_Property.ALTITUDE_ACCURACY)
                );
              };
              Geolocation.prototype.getHeading = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(Geolocation_Property.HEADING)
                );
              };
              Geolocation.prototype.getPosition = function() {
                return (
                  /** @type {import("./coordinate.js").Coordinate|undefined} */
                  this.get(Geolocation_Property.POSITION)
                );
              };
              Geolocation.prototype.getProjection = function() {
                return (
                  /** @type {import("./proj/Projection.js").default|undefined} */
                  this.get(Geolocation_Property.PROJECTION)
                );
              };
              Geolocation.prototype.getSpeed = function() {
                return (
                  /** @type {number|undefined} */
                  this.get(Geolocation_Property.SPEED)
                );
              };
              Geolocation.prototype.getTracking = function() {
                return (
                  /** @type {boolean} */
                  this.get(Geolocation_Property.TRACKING)
                );
              };
              Geolocation.prototype.getTrackingOptions = function() {
                return (
                  /** @type {PositionOptions|undefined} */
                  this.get(Geolocation_Property.TRACKING_OPTIONS)
                );
              };
              Geolocation.prototype.setProjection = function(projection) {
                this.set(Geolocation_Property.PROJECTION, proj_get(projection));
              };
              Geolocation.prototype.setTracking = function(tracking) {
                this.set(Geolocation_Property.TRACKING, tracking);
              };
              Geolocation.prototype.setTrackingOptions = function(options) {
                this.set(Geolocation_Property.TRACKING_OPTIONS, options);
              };
              return Geolocation;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          var ol_Geolocation = Geolocation_Geolocation;
          var GeoLocationvue_type_script_lang_js = {
            name: "ol-geolocation",
            emits: ["positionChanged", "speedChanged", "headingChanged", "altitudeChanged", "altitudeAccuracyChanged", "accuracyGeometryChanged"],
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var geoLoc = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var g = new ol_Geolocation(properties);
                g.on("change", changeEvt);
                return g;
              });
              var position = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
              var accuracy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
              var altitude = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
              var altitudeAccuracy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
              var speed = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
              var heading = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
              var accuracyGeometry = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(position, function() {
                emit("positionChanged", position.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(speed, function() {
                emit("speedChanged", speed.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(heading, function() {
                emit("headingChanged", heading.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(altitude, function() {
                emit("altitudeChanged", altitude.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(altitudeAccuracy, function() {
                emit("altitudeAccuracyChanged", altitudeAccuracy.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(accuracyGeometry, function() {
                emit("accuracyGeometryChanged", accuracyGeometry.value);
              });
              var changeEvt = function changeEvt2() {
                position.value = geoLoc.value.getPosition();
                speed.value = geoLoc.value.getSpeed();
                heading.value = geoLoc.value.getHeading();
                accuracy.value = geoLoc.value.getAccuracy();
                altitude.value = geoLoc.value.getAltitude();
                altitudeAccuracy.value = geoLoc.value.getAltitudeAccuracy();
                accuracyGeometry.value = geoLoc.value.getAccuracyGeometry();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(geoLoc, function(newVal, oldVal) {
                oldVal.un("change", changeEvt);
                newVal.on("change", changeEvt);
              });
              return {
                geoLoc,
                position,
                accuracy,
                altitude,
                altitudeAccuracy,
                speed,
                heading,
                accuracyGeometry
              };
            },
            props: {
              projection: {
                type: [String, Object],
                default: "EPSG:3857"
              },
              tracking: {
                type: Boolean,
                default: true
              },
              trackingOptions: {
                type: Object,
                default: function _default() {
                  return {
                    enableHighAccuracy: true
                  };
                }
              }
            }
          };
          GeoLocationvue_type_script_lang_js.render = GeoLocationvue_type_template_id_4348a5ab_lang_true_render;
          var GeoLocation = GeoLocationvue_type_script_lang_js;
          function install(app) {
            if (install.installed) {
              return;
            }
            install.installed = true;
            app.component(map_Map.name, map_Map);
            app.component(map_View.name, map_View);
            app.component(map_Feature.name, map_Feature);
            app.component(map_Overlay.name, map_Overlay);
            app.component(GeoLocation.name, GeoLocation);
          }
          var components_map = install;
          function TileLayervue_type_template_id_c1b8091a_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var TileProperty = {
            PRELOAD: "preload",
            USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
          };
          var BaseTile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var BaseTile_BaseTileLayer = (
            /** @class */
            function(_super) {
              BaseTile_extends(BaseTileLayer, _super);
              function BaseTileLayer(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var baseOptions = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options);
                delete baseOptions.preload;
                delete baseOptions.useInterimTilesOnError;
                _this = _super.call(this, baseOptions) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.setPreload(options.preload !== void 0 ? options.preload : 0);
                _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
                return _this;
              }
              BaseTileLayer.prototype.getPreload = function() {
                return (
                  /** @type {number} */
                  this.get(TileProperty.PRELOAD)
                );
              };
              BaseTileLayer.prototype.setPreload = function(preload) {
                this.set(TileProperty.PRELOAD, preload);
              };
              BaseTileLayer.prototype.getUseInterimTilesOnError = function() {
                return (
                  /** @type {boolean} */
                  this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)
                );
              };
              BaseTileLayer.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
                this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
              };
              return BaseTileLayer;
            }(layer_Layer)
          );
          var BaseTile = BaseTile_BaseTileLayer;
          var ImageState = {
            IDLE: 0,
            LOADING: 1,
            LOADED: 2,
            ERROR: 3,
            EMPTY: 4
          };
          var Observable = __webpack_require__("35a7");
          var renderer_Layer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Layer_LayerRenderer = (
            /** @class */
            function(_super) {
              renderer_Layer_extends(LayerRenderer, _super);
              function LayerRenderer(layer) {
                var _this = _super.call(this) || this;
                _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
                _this.layer_ = layer;
                _this.declutterExecutorGroup = null;
                return _this;
              }
              LayerRenderer.prototype.getFeatures = function(pixel) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              LayerRenderer.prototype.prepareFrame = function(frameState) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              LayerRenderer.prototype.renderFrame = function(frameState, target) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              LayerRenderer.prototype.loadedTileCallback = function(tiles, zoom, tile) {
                if (!tiles[zoom]) {
                  tiles[zoom] = {};
                }
                tiles[zoom][tile.tileCoord.toString()] = tile;
                return void 0;
              };
              LayerRenderer.prototype.createLoadedTileFinder = function(source, projection, tiles) {
                return (
                  /**
                   * @param {number} zoom Zoom level.
                   * @param {import("../TileRange.js").default} tileRange Tile range.
                   * @return {boolean} The tile range is fully loaded.
                   * @this {LayerRenderer}
                   */
                  (function(zoom, tileRange) {
                    var callback = this.loadedTileCallback.bind(this, tiles, zoom);
                    return source.forEachLoadedTile(projection, zoom, tileRange, callback);
                  }).bind(this)
                );
              };
              LayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
                return void 0;
              };
              LayerRenderer.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              LayerRenderer.prototype.getLayer = function() {
                return this.layer_;
              };
              LayerRenderer.prototype.handleFontsChanged = function() {
              };
              LayerRenderer.prototype.handleImageChange_ = function(event) {
                var image = (
                  /** @type {import("../Image.js").default} */
                  event.target
                );
                if (image.getState() === ImageState.LOADED) {
                  this.renderIfReadyAndVisible();
                }
              };
              LayerRenderer.prototype.loadImage = function(image) {
                var imageState = image.getState();
                if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
                  image.addEventListener(EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.boundHandleImageChange_);
                }
                if (imageState == ImageState.IDLE) {
                  image.load();
                  imageState = image.getState();
                }
                return imageState == ImageState.LOADED;
              };
              LayerRenderer.prototype.renderIfReadyAndVisible = function() {
                var layer = this.getLayer();
                if (layer.getVisible() && layer.getSourceState() == State.READY) {
                  layer.changed();
                }
              };
              return LayerRenderer;
            }(Observable[
              "a"
              /* default */
            ])
          );
          var renderer_Layer = Layer_LayerRenderer;
          var canvas_Layer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Layer_CanvasLayerRenderer = (
            /** @class */
            function(_super) {
              canvas_Layer_extends(CanvasLayerRenderer, _super);
              function CanvasLayerRenderer(layer) {
                var _this = _super.call(this, layer) || this;
                _this.container = null;
                _this.renderedResolution;
                _this.tempTransform = create();
                _this.pixelTransform = create();
                _this.inversePixelTransform = create();
                _this.context = null;
                _this.containerReused = false;
                return _this;
              }
              CanvasLayerRenderer.prototype.useContainer = function(target, transform2, opacity) {
                var layerClassName = this.getLayer().getClassName();
                var container, context;
                if (target && target.style.opacity === "" && target.className === layerClassName) {
                  var canvas = target.firstElementChild;
                  if (canvas instanceof HTMLCanvasElement) {
                    context = canvas.getContext("2d");
                  }
                }
                if (context && (context.canvas.width === 0 || context.canvas.style.transform === transform2)) {
                  this.container = target;
                  this.context = context;
                  this.containerReused = true;
                } else if (this.containerReused) {
                  this.container = null;
                  this.context = null;
                  this.containerReused = false;
                }
                if (!this.container) {
                  container = document.createElement("div");
                  container.className = layerClassName;
                  var style = container.style;
                  style.position = "absolute";
                  style.width = "100%";
                  style.height = "100%";
                  context = Object(dom[
                    "a"
                    /* createCanvasContext2D */
                  ])();
                  var canvas = context.canvas;
                  container.appendChild(canvas);
                  style = canvas.style;
                  style.position = "absolute";
                  style.left = "0";
                  style.transformOrigin = "top left";
                  this.container = container;
                  this.context = context;
                }
              };
              CanvasLayerRenderer.prototype.clipUnrotated = function(context, frameState, extent) {
                var topLeft = getTopLeft(extent);
                var topRight = getTopRight(extent);
                var bottomRight = getBottomRight(extent);
                var bottomLeft = getBottomLeft(extent);
                apply(frameState.coordinateToPixelTransform, topLeft);
                apply(frameState.coordinateToPixelTransform, topRight);
                apply(frameState.coordinateToPixelTransform, bottomRight);
                apply(frameState.coordinateToPixelTransform, bottomLeft);
                var inverted = this.inversePixelTransform;
                apply(inverted, topLeft);
                apply(inverted, topRight);
                apply(inverted, bottomRight);
                apply(inverted, bottomLeft);
                context.save();
                context.beginPath();
                context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
                context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
                context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
                context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
                context.clip();
              };
              CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
                var layer = this.getLayer();
                if (layer.hasListener(type)) {
                  var event_1 = new render_Event(type, this.inversePixelTransform, frameState, context);
                  layer.dispatchEvent(event_1);
                }
              };
              CanvasLayerRenderer.prototype.preRender = function(context, frameState) {
                this.dispatchRenderEvent_(render_EventType.PRERENDER, context, frameState);
              };
              CanvasLayerRenderer.prototype.postRender = function(context, frameState) {
                this.dispatchRenderEvent_(render_EventType.POSTRENDER, context, frameState);
              };
              CanvasLayerRenderer.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {
                var dx1 = width / 2;
                var dy1 = height / 2;
                var sx = pixelRatio / resolution;
                var sy = -sx;
                var dx2 = -center[0] + offsetX;
                var dy2 = -center[1];
                return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
              };
              CanvasLayerRenderer.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
                var renderPixel = apply(this.inversePixelTransform, pixel.slice());
                var context = this.context;
                var layer = this.getLayer();
                var layerExtent = layer.getExtent();
                if (layerExtent) {
                  var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
                  if (!containsCoordinate(layerExtent, renderCoordinate)) {
                    return null;
                  }
                }
                var data;
                try {
                  var x = Math.round(renderPixel[0]);
                  var y = Math.round(renderPixel[1]);
                  var newCanvas = document.createElement("canvas");
                  var newContext = newCanvas.getContext("2d");
                  newCanvas.width = 1;
                  newCanvas.height = 1;
                  newContext.clearRect(0, 0, 1, 1);
                  newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
                  data = newContext.getImageData(0, 0, 1, 1).data;
                } catch (err) {
                  if (err.name === "SecurityError") {
                    return new Uint8Array();
                  }
                  return data;
                }
                if (data[3] === 0) {
                  return null;
                }
                return data;
              };
              return CanvasLayerRenderer;
            }(renderer_Layer)
          );
          var canvas_Layer = Layer_CanvasLayerRenderer;
          var TileRange = (
            /** @class */
            function() {
              function TileRange2(minX, maxX, minY, maxY) {
                this.minX = minX;
                this.maxX = maxX;
                this.minY = minY;
                this.maxY = maxY;
              }
              TileRange2.prototype.contains = function(tileCoord) {
                return this.containsXY(tileCoord[1], tileCoord[2]);
              };
              TileRange2.prototype.containsTileRange = function(tileRange) {
                return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
              };
              TileRange2.prototype.containsXY = function(x, y) {
                return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
              };
              TileRange2.prototype.equals = function(tileRange) {
                return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
              };
              TileRange2.prototype.extend = function(tileRange) {
                if (tileRange.minX < this.minX) {
                  this.minX = tileRange.minX;
                }
                if (tileRange.maxX > this.maxX) {
                  this.maxX = tileRange.maxX;
                }
                if (tileRange.minY < this.minY) {
                  this.minY = tileRange.minY;
                }
                if (tileRange.maxY > this.maxY) {
                  this.maxY = tileRange.maxY;
                }
              };
              TileRange2.prototype.getHeight = function() {
                return this.maxY - this.minY + 1;
              };
              TileRange2.prototype.getSize = function() {
                return [this.getWidth(), this.getHeight()];
              };
              TileRange2.prototype.getWidth = function() {
                return this.maxX - this.minX + 1;
              };
              TileRange2.prototype.intersects = function(tileRange) {
                return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
              };
              return TileRange2;
            }()
          );
          function TileRange_createOrUpdate(minX, maxX, minY, maxY, tileRange) {
            if (tileRange !== void 0) {
              tileRange.minX = minX;
              tileRange.maxX = maxX;
              tileRange.minY = minY;
              tileRange.maxY = maxY;
              return tileRange;
            } else {
              return new TileRange(minX, maxX, minY, maxY);
            }
          }
          var ol_TileRange = TileRange;
          var TileLayer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TileLayer_CanvasTileLayerRenderer = (
            /** @class */
            function(_super) {
              TileLayer_extends(CanvasTileLayerRenderer, _super);
              function CanvasTileLayerRenderer(tileLayer) {
                var _this = _super.call(this, tileLayer) || this;
                _this.extentChanged = true;
                _this.renderedExtent_ = null;
                _this.renderedPixelRatio;
                _this.renderedProjection = null;
                _this.renderedRevision;
                _this.renderedTiles = [];
                _this.newTiles_ = false;
                _this.tmpExtent = createEmpty();
                _this.tmpTileRange_ = new ol_TileRange(0, 0, 0, 0);
                return _this;
              }
              CanvasTileLayerRenderer.prototype.isDrawableTile = function(tile) {
                var tileLayer = this.getLayer();
                var tileState = tile.getState();
                var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
                return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
              };
              CanvasTileLayerRenderer.prototype.getTile = function(z, x, y, frameState) {
                var pixelRatio = frameState.pixelRatio;
                var projection = frameState.viewState.projection;
                var tileLayer = this.getLayer();
                var tileSource = tileLayer.getSource();
                var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                if (tile.getState() == TileState.ERROR) {
                  if (!tileLayer.getUseInterimTilesOnError()) {
                    tile.setState(TileState.LOADED);
                  } else if (tileLayer.getPreload() > 0) {
                    this.newTiles_ = true;
                  }
                }
                if (!this.isDrawableTile(tile)) {
                  tile = tile.getInterimTile();
                }
                return tile;
              };
              CanvasTileLayerRenderer.prototype.loadedTileCallback = function(tiles, zoom, tile) {
                if (this.isDrawableTile(tile)) {
                  return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
                }
                return false;
              };
              CanvasTileLayerRenderer.prototype.prepareFrame = function(frameState) {
                return !!this.getLayer().getSource();
              };
              CanvasTileLayerRenderer.prototype.renderFrame = function(frameState, target) {
                var layerState = frameState.layerStatesArray[frameState.layerIndex];
                var viewState = frameState.viewState;
                var projection = viewState.projection;
                var viewResolution = viewState.resolution;
                var viewCenter = viewState.center;
                var rotation = viewState.rotation;
                var pixelRatio = frameState.pixelRatio;
                var tileLayer = this.getLayer();
                var tileSource = tileLayer.getSource();
                var sourceRevision = tileSource.getRevision();
                var tileGrid = tileSource.getTileGridForProjection(projection);
                var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
                var tileResolution = tileGrid.getResolution(z);
                var extent = frameState.extent;
                var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
                if (layerExtent) {
                  extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));
                }
                var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
                var width = Math.round(frameState.size[0] * tilePixelRatio);
                var height = Math.round(frameState.size[1] * tilePixelRatio);
                if (rotation) {
                  var size = Math.round(Math.sqrt(width * width + height * height));
                  width = size;
                  height = size;
                }
                var dx = tileResolution * width / 2 / tilePixelRatio;
                var dy = tileResolution * height / 2 / tilePixelRatio;
                var canvasExtent = [
                  viewCenter[0] - dx,
                  viewCenter[1] - dy,
                  viewCenter[0] + dx,
                  viewCenter[1] + dy
                ];
                var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
                var tilesToDrawByZ = {};
                tilesToDrawByZ[z] = {};
                var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
                var tmpExtent = this.tmpExtent;
                var tmpTileRange = this.tmpTileRange_;
                this.newTiles_ = false;
                for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
                  for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                    var tile = this.getTile(z, x, y, frameState);
                    if (this.isDrawableTile(tile)) {
                      var uid = Object(util[
                        "c"
                        /* getUid */
                      ])(this);
                      if (tile.getState() == TileState.LOADED) {
                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                        var inTransition = tile.inTransition(uid);
                        if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                          this.newTiles_ = true;
                        }
                      }
                      if (tile.getAlpha(uid, frameState.time) === 1) {
                        continue;
                      }
                    }
                    var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                    var covered = false;
                    if (childTileRange) {
                      covered = findLoadedTiles(z + 1, childTileRange);
                    }
                    if (!covered) {
                      tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                    }
                  }
                }
                var canvasScale = tileResolution / viewResolution;
                compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
                var canvasTransform = transform_toString(this.pixelTransform);
                this.useContainer(target, canvasTransform, layerState.opacity);
                var context = this.context;
                var canvas = context.canvas;
                makeInverse(this.inversePixelTransform, this.pixelTransform);
                compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
                if (canvas.width != width || canvas.height != height) {
                  canvas.width = width;
                  canvas.height = height;
                } else if (!this.containerReused) {
                  context.clearRect(0, 0, width, height);
                }
                if (layerExtent) {
                  this.clipUnrotated(context, frameState, layerExtent);
                }
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(context, tileSource.getContextOptions());
                this.preRender(context, frameState);
                this.renderedTiles.length = 0;
                var zs = Object.keys(tilesToDrawByZ).map(Number);
                zs.sort(ol_array[
                  "i"
                  /* numberSafeCompareFunction */
                ]);
                var clips, clipZs, currentClip;
                if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
                  zs = zs.reverse();
                } else {
                  clips = [];
                  clipZs = [];
                }
                for (var i = zs.length - 1; i >= 0; --i) {
                  var currentZ = zs[i];
                  var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
                  var currentResolution = tileGrid.getResolution(currentZ);
                  var currentScale = currentResolution / tileResolution;
                  var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
                  var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
                  var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
                  var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
                  var origin_1 = apply(this.tempTransform, [
                    tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
                    tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
                  ]);
                  var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
                  var tilesToDraw = tilesToDrawByZ[currentZ];
                  for (var tileCoordKey in tilesToDraw) {
                    var tile = (
                      /** @type {import("../../ImageTile.js").default} */
                      tilesToDraw[tileCoordKey]
                    );
                    var tileCoord = tile.tileCoord;
                    var xIndex = originTileCoord[1] - tileCoord[1];
                    var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
                    var yIndex = originTileCoord[2] - tileCoord[2];
                    var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
                    var x = Math.round(origin_1[0] - xIndex * dx_1);
                    var y = Math.round(origin_1[1] - yIndex * dy_1);
                    var w = nextX - x;
                    var h = nextY - y;
                    var transition = z === currentZ;
                    var inTransition = transition && tile.getAlpha(Object(util[
                      "c"
                      /* getUid */
                    ])(this), frameState.time) !== 1;
                    if (!inTransition) {
                      if (clips) {
                        context.save();
                        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                        for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                          if (z !== currentZ && currentZ < clipZs[i_1]) {
                            var clip = clips[i_1];
                            context.beginPath();
                            context.moveTo(currentClip[0], currentClip[1]);
                            context.lineTo(currentClip[2], currentClip[3]);
                            context.lineTo(currentClip[4], currentClip[5]);
                            context.lineTo(currentClip[6], currentClip[7]);
                            context.moveTo(clip[6], clip[7]);
                            context.lineTo(clip[4], clip[5]);
                            context.lineTo(clip[2], clip[3]);
                            context.lineTo(clip[0], clip[1]);
                            context.clip();
                          }
                        }
                        clips.push(currentClip);
                        clipZs.push(currentZ);
                      } else {
                        context.clearRect(x, y, w, h);
                      }
                    }
                    this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);
                    if (clips && !inTransition) {
                      context.restore();
                      this.renderedTiles.unshift(tile);
                    } else {
                      this.renderedTiles.push(tile);
                    }
                    this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
                  }
                }
                this.renderedRevision = sourceRevision;
                this.renderedResolution = tileResolution;
                this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);
                this.renderedExtent_ = canvasExtent;
                this.renderedPixelRatio = pixelRatio;
                this.renderedProjection = projection;
                this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
                this.scheduleExpireCache(frameState, tileSource);
                this.postRender(context, frameState);
                if (layerState.extent) {
                  context.restore();
                }
                if (canvasTransform !== canvas.style.transform) {
                  canvas.style.transform = canvasTransform;
                }
                return this.container;
              };
              CanvasTileLayerRenderer.prototype.drawTileImage = function(tile, frameState, x, y, w, h, gutter, transition, opacity) {
                var image = this.getTileImage(tile);
                if (!image) {
                  return;
                }
                var uid = Object(util[
                  "c"
                  /* getUid */
                ])(this);
                var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
                var alpha = opacity * tileAlpha;
                var alphaChanged = alpha !== this.context.globalAlpha;
                if (alphaChanged) {
                  this.context.save();
                  this.context.globalAlpha = alpha;
                }
                this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
                if (alphaChanged) {
                  this.context.restore();
                }
                if (tileAlpha !== 1) {
                  frameState.animate = true;
                } else if (transition) {
                  tile.endTransition(uid);
                }
              };
              CanvasTileLayerRenderer.prototype.getImage = function() {
                var context = this.context;
                return context ? context.canvas : null;
              };
              CanvasTileLayerRenderer.prototype.getTileImage = function(tile) {
                return tile.getImage();
              };
              CanvasTileLayerRenderer.prototype.scheduleExpireCache = function(frameState, tileSource) {
                if (tileSource.canExpireCache()) {
                  var postRenderFunction = (function(tileSource2, map, frameState2) {
                    var tileSourceKey = Object(util[
                      "c"
                      /* getUid */
                    ])(tileSource2);
                    if (tileSourceKey in frameState2.usedTiles) {
                      tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);
                    }
                  }).bind(null, tileSource);
                  frameState.postRenderFunctions.push(
                    /** @type {import("../../PluggableMap.js").PostRenderFunction} */
                    postRenderFunction
                  );
                }
              };
              CanvasTileLayerRenderer.prototype.updateUsedTiles = function(usedTiles, tileSource, tile) {
                var tileSourceKey = Object(util[
                  "c"
                  /* getUid */
                ])(tileSource);
                if (!(tileSourceKey in usedTiles)) {
                  usedTiles[tileSourceKey] = {};
                }
                usedTiles[tileSourceKey][tile.getKey()] = true;
              };
              CanvasTileLayerRenderer.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
                var tileSourceKey = Object(util[
                  "c"
                  /* getUid */
                ])(tileSource);
                if (!(tileSourceKey in frameState.wantedTiles)) {
                  frameState.wantedTiles[tileSourceKey] = {};
                }
                var wantedTiles = frameState.wantedTiles[tileSourceKey];
                var tileQueue = frameState.tileQueue;
                var minZoom = tileGrid.getMinZoom();
                var tileCount = 0;
                var tile, tileRange, tileResolution, x, y, z;
                for (z = minZoom; z <= currentZ; ++z) {
                  tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
                  tileResolution = tileGrid.getResolution(z);
                  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                      if (currentZ - z <= preload) {
                        ++tileCount;
                        tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                        if (tile.getState() == TileState.IDLE) {
                          wantedTiles[tile.getKey()] = true;
                          if (!tileQueue.isKeyQueued(tile.getKey())) {
                            tileQueue.enqueue([
                              tile,
                              tileSourceKey,
                              tileGrid.getTileCoordCenter(tile.tileCoord),
                              tileResolution
                            ]);
                          }
                        }
                        if (opt_tileCallback !== void 0) {
                          opt_tileCallback(tile);
                        }
                      } else {
                        tileSource.useTile(z, x, y, projection);
                      }
                    }
                  }
                }
                tileSource.updateCacheSize(tileCount, projection);
              };
              return CanvasTileLayerRenderer;
            }(canvas_Layer)
          );
          TileLayer_CanvasTileLayerRenderer.prototype.getLayer;
          var canvas_TileLayer = TileLayer_CanvasTileLayerRenderer;
          var Tile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Tile_TileLayer = (
            /** @class */
            function(_super) {
              Tile_extends(TileLayer, _super);
              function TileLayer(opt_options) {
                return _super.call(this, opt_options) || this;
              }
              TileLayer.prototype.createRenderer = function() {
                return new canvas_TileLayer(this);
              };
              return TileLayer;
            }(BaseTile)
          );
          var layer_Tile = Tile_TileLayer;
          var TileLayervue_type_script_lang_js = {
            name: "ol-tile-layer",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var overViewMap = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("overviewMap", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var tileLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new layer_Tile(properties);
              });
              var applyTileLayer = function applyTileLayer2() {
                if (overViewMap != null) {
                  overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
                  overViewMap.value.changed();
                } else {
                  map.addLayer(tileLayer.value);
                }
              };
              var removeTileLayer = function removeTileLayer2() {
                if (overViewMap != null) {
                  overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
                  overViewMap.value.changed();
                } else {
                  map.removeLayer(tileLayer.value);
                }
              };
              if (overViewMap != null) {
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(overViewMap, function() {
                  removeTileLayer();
                  applyTileLayer();
                });
              }
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                applyTileLayer();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                removeTileLayer();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("tileLayer", tileLayer);
              return {
                tileLayer
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-layer"
              },
              opacity: {
                type: Number,
                default: 1
              },
              visible: {
                type: Boolean,
                default: true
              },
              extent: {
                type: Array
              },
              zIndex: {
                type: Number
              },
              minResolution: {
                type: Number
              },
              maxResolution: {
                type: Number
              },
              minZoom: {
                type: Number
              },
              maxZoom: {
                type: Number
              },
              preload: {
                type: Number,
                default: 1
              }
            }
          };
          TileLayervue_type_script_lang_js.render = TileLayervue_type_template_id_c1b8091a_lang_true_render;
          var layers_TileLayer = TileLayervue_type_script_lang_js;
          function ImageLayervue_type_template_id_0b4ad435_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var BaseImage_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var BaseImageLayer = (
            /** @class */
            function(_super) {
              BaseImage_extends(BaseImageLayer2, _super);
              function BaseImageLayer2(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, options) || this;
                return _this;
              }
              return BaseImageLayer2;
            }(layer_Layer)
          );
          var BaseImage = BaseImageLayer;
          var ERROR_THRESHOLD = 0.5;
          var ENABLE_RASTER_REPROJECTION = true;
          var ImageLayer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageLayer_CanvasImageLayerRenderer = (
            /** @class */
            function(_super) {
              ImageLayer_extends(CanvasImageLayerRenderer, _super);
              function CanvasImageLayerRenderer(imageLayer) {
                var _this = _super.call(this, imageLayer) || this;
                _this.image_ = null;
                return _this;
              }
              CanvasImageLayerRenderer.prototype.getImage = function() {
                return !this.image_ ? null : this.image_.getImage();
              };
              CanvasImageLayerRenderer.prototype.prepareFrame = function(frameState) {
                var layerState = frameState.layerStatesArray[frameState.layerIndex];
                var pixelRatio = frameState.pixelRatio;
                var viewState = frameState.viewState;
                var viewResolution = viewState.resolution;
                var imageSource = this.getLayer().getSource();
                var hints = frameState.viewHints;
                var renderedExtent = frameState.extent;
                if (layerState.extent !== void 0) {
                  renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
                }
                if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !extent_isEmpty(renderedExtent)) {
                  if (imageSource) {
                    var projection = viewState.projection;
                    if (!ENABLE_RASTER_REPROJECTION) {
                      var sourceProjection = imageSource.getProjection();
                      if (sourceProjection) {
                        projection = sourceProjection;
                      }
                    }
                    var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                    if (image && this.loadImage(image)) {
                      this.image_ = image;
                    }
                  } else {
                    this.image_ = null;
                  }
                }
                return !!this.image_;
              };
              CanvasImageLayerRenderer.prototype.renderFrame = function(frameState, target) {
                var image = this.image_;
                var imageExtent = image.getExtent();
                var imageResolution = image.getResolution();
                var imagePixelRatio = image.getPixelRatio();
                var layerState = frameState.layerStatesArray[frameState.layerIndex];
                var pixelRatio = frameState.pixelRatio;
                var viewState = frameState.viewState;
                var viewCenter = viewState.center;
                var viewResolution = viewState.resolution;
                var size = frameState.size;
                var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
                var width = Math.round(size[0] * pixelRatio);
                var height = Math.round(size[1] * pixelRatio);
                var rotation = viewState.rotation;
                if (rotation) {
                  var size_1 = Math.round(Math.sqrt(width * width + height * height));
                  width = size_1;
                  height = size_1;
                }
                compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
                makeInverse(this.inversePixelTransform, this.pixelTransform);
                var canvasTransform = transform_toString(this.pixelTransform);
                this.useContainer(target, canvasTransform, layerState.opacity);
                var context = this.context;
                var canvas = context.canvas;
                if (canvas.width != width || canvas.height != height) {
                  canvas.width = width;
                  canvas.height = height;
                } else if (!this.containerReused) {
                  context.clearRect(0, 0, width, height);
                }
                var clipped = false;
                var render = true;
                if (layerState.extent) {
                  var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
                  render = extent_intersects(layerExtent, frameState.extent);
                  clipped = render && !containsExtent(layerExtent, frameState.extent);
                  if (clipped) {
                    this.clipUnrotated(context, frameState, layerExtent);
                  }
                }
                var img = image.getImage();
                var transform2 = compose(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
                this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
                var dw = img.width * transform2[0];
                var dh = img.height * transform2[3];
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(context, this.getLayer().getSource().getContextOptions());
                this.preRender(context, frameState);
                if (render && dw >= 0.5 && dh >= 0.5) {
                  var dx = transform2[4];
                  var dy = transform2[5];
                  var opacity = layerState.opacity;
                  var previousAlpha = void 0;
                  if (opacity !== 1) {
                    previousAlpha = context.globalAlpha;
                    context.globalAlpha = opacity;
                  }
                  context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
                  if (opacity !== 1) {
                    context.globalAlpha = previousAlpha;
                  }
                }
                this.postRender(context, frameState);
                if (clipped) {
                  context.restore();
                }
                if (canvasTransform !== canvas.style.transform) {
                  canvas.style.transform = canvasTransform;
                }
                return this.container;
              };
              return CanvasImageLayerRenderer;
            }(canvas_Layer)
          );
          var canvas_ImageLayer = ImageLayer_CanvasImageLayerRenderer;
          var Image_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Image_ImageLayer = (
            /** @class */
            function(_super) {
              Image_extends(ImageLayer, _super);
              function ImageLayer(opt_options) {
                return _super.call(this, opt_options) || this;
              }
              ImageLayer.prototype.createRenderer = function() {
                return new canvas_ImageLayer(this);
              };
              return ImageLayer;
            }(BaseImage)
          );
          var layer_Image = Image_ImageLayer;
          var ImageLayervue_type_script_lang_js = {
            name: "ol-image-layer",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var imageLayer = new layer_Image(properties);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                imageLayer.setProperties(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addLayer(imageLayer);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeLayer(imageLayer);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("imageLayer", imageLayer);
              return {
                imageLayer
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-layer"
              },
              opacity: {
                type: Number,
                default: 1
              },
              visible: {
                type: Boolean,
                default: true
              },
              extent: {
                type: Array
              },
              zIndex: {
                type: Number
              },
              minResolution: {
                type: Number
              },
              maxResolution: {
                type: Number
              },
              minZoom: {
                type: Number
              },
              maxZoom: {
                type: Number
              }
            }
          };
          ImageLayervue_type_script_lang_js.render = ImageLayervue_type_template_id_0b4ad435_lang_true_render;
          var layers_ImageLayer = ImageLayervue_type_script_lang_js;
          function VectorLayervue_type_template_id_9de2931c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var rbush_min = __webpack_require__("25a5");
          var rbush_min_default = __webpack_require__.n(rbush_min);
          var Image_ImageStyle = (
            /** @class */
            function() {
              function ImageStyle(options) {
                this.opacity_ = options.opacity;
                this.rotateWithView_ = options.rotateWithView;
                this.rotation_ = options.rotation;
                this.scale_ = options.scale;
                this.scaleArray_ = toSize(options.scale);
                this.displacement_ = options.displacement;
              }
              ImageStyle.prototype.clone = function() {
                var scale = this.getScale();
                return new ImageStyle({
                  opacity: this.getOpacity(),
                  scale: Array.isArray(scale) ? scale.slice() : scale,
                  rotation: this.getRotation(),
                  rotateWithView: this.getRotateWithView(),
                  displacement: this.getDisplacement().slice()
                });
              };
              ImageStyle.prototype.getOpacity = function() {
                return this.opacity_;
              };
              ImageStyle.prototype.getRotateWithView = function() {
                return this.rotateWithView_;
              };
              ImageStyle.prototype.getRotation = function() {
                return this.rotation_;
              };
              ImageStyle.prototype.getScale = function() {
                return this.scale_;
              };
              ImageStyle.prototype.getScaleArray = function() {
                return this.scaleArray_;
              };
              ImageStyle.prototype.getDisplacement = function() {
                return this.displacement_;
              };
              ImageStyle.prototype.getAnchor = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getImage = function(pixelRatio) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getHitDetectionImage = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getPixelRatio = function(pixelRatio) {
                return 1;
              };
              ImageStyle.prototype.getImageState = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getImageSize = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getOrigin = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.getSize = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.setOpacity = function(opacity) {
                this.opacity_ = opacity;
              };
              ImageStyle.prototype.setRotateWithView = function(rotateWithView) {
                this.rotateWithView_ = rotateWithView;
              };
              ImageStyle.prototype.setRotation = function(rotation) {
                this.rotation_ = rotation;
              };
              ImageStyle.prototype.setScale = function(scale) {
                this.scale_ = scale;
                this.scaleArray_ = toSize(scale);
              };
              ImageStyle.prototype.listenImageChange = function(listener) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.load = function() {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageStyle.prototype.unlistenImageChange = function(listener) {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              return ImageStyle;
            }()
          );
          var style_Image = Image_ImageStyle;
          function asColorLike(color) {
            if (Array.isArray(color)) {
              return color_toString(color);
            } else {
              return color;
            }
          }
          var RegularShape_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var RegularShape_RegularShape = (
            /** @class */
            function(_super) {
              RegularShape_extends(RegularShape, _super);
              function RegularShape(options) {
                var _this = this;
                var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
                _this = _super.call(this, {
                  opacity: 1,
                  rotateWithView,
                  rotation: options.rotation !== void 0 ? options.rotation : 0,
                  scale: options.scale !== void 0 ? options.scale : 1,
                  displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
                }) || this;
                _this.canvas_ = void 0;
                _this.hitDetectionCanvas_ = null;
                _this.fill_ = options.fill !== void 0 ? options.fill : null;
                _this.origin_ = [0, 0];
                _this.points_ = options.points;
                _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
                _this.radius2_ = options.radius2;
                _this.angle_ = options.angle !== void 0 ? options.angle : 0;
                _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
                _this.anchor_ = null;
                _this.size_ = null;
                _this.renderOptions_ = null;
                _this.render();
                return _this;
              }
              RegularShape.prototype.clone = function() {
                var scale = this.getScale();
                var style = new RegularShape({
                  fill: this.getFill() ? this.getFill().clone() : void 0,
                  points: this.getPoints(),
                  radius: this.getRadius(),
                  radius2: this.getRadius2(),
                  angle: this.getAngle(),
                  stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                  rotation: this.getRotation(),
                  rotateWithView: this.getRotateWithView(),
                  scale: Array.isArray(scale) ? scale.slice() : scale,
                  displacement: this.getDisplacement().slice()
                });
                style.setOpacity(this.getOpacity());
                return style;
              };
              RegularShape.prototype.getAnchor = function() {
                return this.anchor_;
              };
              RegularShape.prototype.getAngle = function() {
                return this.angle_;
              };
              RegularShape.prototype.getFill = function() {
                return this.fill_;
              };
              RegularShape.prototype.getHitDetectionImage = function() {
                if (!this.hitDetectionCanvas_) {
                  this.createHitDetectionCanvas_(this.renderOptions_);
                }
                return this.hitDetectionCanvas_;
              };
              RegularShape.prototype.getImage = function(pixelRatio) {
                var image = this.canvas_[pixelRatio];
                if (!image) {
                  var renderOptions = this.renderOptions_;
                  var context = Object(dom[
                    "a"
                    /* createCanvasContext2D */
                  ])(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
                  this.draw_(renderOptions, context, pixelRatio);
                  image = context.canvas;
                  this.canvas_[pixelRatio] = image;
                }
                return image;
              };
              RegularShape.prototype.getPixelRatio = function(pixelRatio) {
                return pixelRatio;
              };
              RegularShape.prototype.getImageSize = function() {
                return this.size_;
              };
              RegularShape.prototype.getImageState = function() {
                return ImageState.LOADED;
              };
              RegularShape.prototype.getOrigin = function() {
                return this.origin_;
              };
              RegularShape.prototype.getPoints = function() {
                return this.points_;
              };
              RegularShape.prototype.getRadius = function() {
                return this.radius_;
              };
              RegularShape.prototype.getRadius2 = function() {
                return this.radius2_;
              };
              RegularShape.prototype.getSize = function() {
                return this.size_;
              };
              RegularShape.prototype.getStroke = function() {
                return this.stroke_;
              };
              RegularShape.prototype.listenImageChange = function(listener) {
              };
              RegularShape.prototype.load = function() {
              };
              RegularShape.prototype.unlistenImageChange = function(listener) {
              };
              RegularShape.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
                if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
                  return strokeWidth;
                }
                var r1 = this.radius_;
                var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
                if (r1 < r2) {
                  var tmp = r1;
                  r1 = r2;
                  r2 = tmp;
                }
                var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
                var alpha = 2 * Math.PI / points;
                var a = r2 * Math.sin(alpha);
                var b = Math.sqrt(r2 * r2 - a * a);
                var d = r1 - b;
                var e = Math.sqrt(a * a + d * d);
                var miterRatio = e / a;
                if (lineJoin === "miter" && miterRatio <= miterLimit) {
                  return miterRatio * strokeWidth;
                }
                var k = strokeWidth / 2 / miterRatio;
                var l = strokeWidth / 2 * (d / e);
                var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
                var bevelAdd = maxr - r1;
                if (this.radius2_ === void 0 || lineJoin === "bevel") {
                  return bevelAdd * 2;
                }
                var aa = r1 * Math.sin(alpha);
                var bb = Math.sqrt(r1 * r1 - aa * aa);
                var dd = r2 - bb;
                var ee = Math.sqrt(aa * aa + dd * dd);
                var innerMiterRatio = ee / aa;
                if (innerMiterRatio <= miterLimit) {
                  var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
                  return 2 * Math.max(bevelAdd, innerLength);
                }
                return bevelAdd * 2;
              };
              RegularShape.prototype.createRenderOptions = function() {
                var lineJoin = defaultLineJoin;
                var miterLimit = 0;
                var lineDash = null;
                var lineDashOffset = 0;
                var strokeStyle;
                var strokeWidth = 0;
                if (this.stroke_) {
                  strokeStyle = this.stroke_.getColor();
                  if (strokeStyle === null) {
                    strokeStyle = defaultStrokeStyle;
                  }
                  strokeStyle = asColorLike(strokeStyle);
                  strokeWidth = this.stroke_.getWidth();
                  if (strokeWidth === void 0) {
                    strokeWidth = defaultLineWidth;
                  }
                  lineDash = this.stroke_.getLineDash();
                  lineDashOffset = this.stroke_.getLineDashOffset();
                  lineJoin = this.stroke_.getLineJoin();
                  if (lineJoin === void 0) {
                    lineJoin = defaultLineJoin;
                  }
                  miterLimit = this.stroke_.getMiterLimit();
                  if (miterLimit === void 0) {
                    miterLimit = defaultMiterLimit;
                  }
                }
                var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
                var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
                var size = Math.ceil(2 * maxRadius + add);
                return {
                  strokeStyle,
                  strokeWidth,
                  size,
                  lineDash,
                  lineDashOffset,
                  lineJoin,
                  miterLimit
                };
              };
              RegularShape.prototype.render = function() {
                this.renderOptions_ = this.createRenderOptions();
                var size = this.renderOptions_.size;
                var displacement = this.getDisplacement();
                this.canvas_ = {};
                this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
                this.size_ = [size, size];
              };
              RegularShape.prototype.draw_ = function(renderOptions, context, pixelRatio) {
                context.scale(pixelRatio, pixelRatio);
                context.translate(renderOptions.size / 2, renderOptions.size / 2);
                this.createPath_(context);
                if (this.fill_) {
                  var color = this.fill_.getColor();
                  if (color === null) {
                    color = defaultFillStyle;
                  }
                  context.fillStyle = asColorLike(color);
                  context.fill();
                }
                if (this.stroke_) {
                  context.strokeStyle = renderOptions.strokeStyle;
                  context.lineWidth = renderOptions.strokeWidth;
                  if (context.setLineDash && renderOptions.lineDash) {
                    context.setLineDash(renderOptions.lineDash);
                    context.lineDashOffset = renderOptions.lineDashOffset;
                  }
                  context.lineJoin = renderOptions.lineJoin;
                  context.miterLimit = renderOptions.miterLimit;
                  context.stroke();
                }
              };
              RegularShape.prototype.createHitDetectionCanvas_ = function(renderOptions) {
                if (this.fill_) {
                  var color = this.fill_.getColor();
                  var opacity = 0;
                  if (typeof color === "string") {
                    color = asArray(color);
                  }
                  if (color === null) {
                    opacity = 1;
                  } else if (Array.isArray(color)) {
                    opacity = color.length === 4 ? color[3] : 1;
                  }
                  if (opacity === 0) {
                    var context = Object(dom[
                      "a"
                      /* createCanvasContext2D */
                    ])(renderOptions.size, renderOptions.size);
                    this.hitDetectionCanvas_ = context.canvas;
                    this.drawHitDetectionCanvas_(renderOptions, context);
                  }
                }
                if (!this.hitDetectionCanvas_) {
                  this.hitDetectionCanvas_ = this.getImage(1);
                }
              };
              RegularShape.prototype.createPath_ = function(context) {
                var points = this.points_;
                var radius = this.radius_;
                if (points === Infinity) {
                  context.arc(0, 0, radius, 0, 2 * Math.PI);
                } else {
                  var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
                  if (this.radius2_ !== void 0) {
                    points *= 2;
                  }
                  var startAngle = this.angle_ - Math.PI / 2;
                  var step = 2 * Math.PI / points;
                  for (var i = 0; i < points; i++) {
                    var angle0 = startAngle + i * step;
                    var radiusC = i % 2 === 0 ? radius : radius2;
                    context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
                  }
                  context.closePath();
                }
              };
              RegularShape.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
                context.translate(renderOptions.size / 2, renderOptions.size / 2);
                this.createPath_(context);
                context.fillStyle = defaultFillStyle;
                context.fill();
                if (this.stroke_) {
                  context.strokeStyle = renderOptions.strokeStyle;
                  context.lineWidth = renderOptions.strokeWidth;
                  if (renderOptions.lineDash) {
                    context.setLineDash(renderOptions.lineDash);
                    context.lineDashOffset = renderOptions.lineDashOffset;
                  }
                  context.lineJoin = renderOptions.lineJoin;
                  context.miterLimit = renderOptions.miterLimit;
                  context.stroke();
                }
              };
              return RegularShape;
            }(style_Image)
          );
          var style_RegularShape = RegularShape_RegularShape;
          var Circle_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var CircleStyle = (
            /** @class */
            function(_super) {
              Circle_extends(CircleStyle2, _super);
              function CircleStyle2(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  points: Infinity,
                  fill: options.fill,
                  radius: options.radius,
                  stroke: options.stroke,
                  scale: options.scale !== void 0 ? options.scale : 1,
                  rotation: options.rotation !== void 0 ? options.rotation : 0,
                  rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
                  displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
                }) || this;
                return _this;
              }
              CircleStyle2.prototype.clone = function() {
                var scale = this.getScale();
                var style = new CircleStyle2({
                  fill: this.getFill() ? this.getFill().clone() : void 0,
                  stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                  radius: this.getRadius(),
                  scale: Array.isArray(scale) ? scale.slice() : scale,
                  rotation: this.getRotation(),
                  rotateWithView: this.getRotateWithView(),
                  displacement: this.getDisplacement().slice()
                });
                style.setOpacity(this.getOpacity());
                return style;
              };
              CircleStyle2.prototype.setRadius = function(radius) {
                this.radius_ = radius;
                this.render();
              };
              return CircleStyle2;
            }(style_RegularShape)
          );
          var style_Circle = CircleStyle;
          var Fill = (
            /** @class */
            function() {
              function Fill2(opt_options) {
                var options = opt_options || {};
                this.color_ = options.color !== void 0 ? options.color : null;
              }
              Fill2.prototype.clone = function() {
                var color = this.getColor();
                return new Fill2({
                  color: Array.isArray(color) ? color.slice() : color || void 0
                });
              };
              Fill2.prototype.getColor = function() {
                return this.color_;
              };
              Fill2.prototype.setColor = function(color) {
                this.color_ = color;
              };
              return Fill2;
            }()
          );
          var style_Fill = Fill;
          var Stroke = (
            /** @class */
            function() {
              function Stroke2(opt_options) {
                var options = opt_options || {};
                this.color_ = options.color !== void 0 ? options.color : null;
                this.lineCap_ = options.lineCap;
                this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
                this.lineDashOffset_ = options.lineDashOffset;
                this.lineJoin_ = options.lineJoin;
                this.miterLimit_ = options.miterLimit;
                this.width_ = options.width;
              }
              Stroke2.prototype.clone = function() {
                var color = this.getColor();
                return new Stroke2({
                  color: Array.isArray(color) ? color.slice() : color || void 0,
                  lineCap: this.getLineCap(),
                  lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
                  lineDashOffset: this.getLineDashOffset(),
                  lineJoin: this.getLineJoin(),
                  miterLimit: this.getMiterLimit(),
                  width: this.getWidth()
                });
              };
              Stroke2.prototype.getColor = function() {
                return this.color_;
              };
              Stroke2.prototype.getLineCap = function() {
                return this.lineCap_;
              };
              Stroke2.prototype.getLineDash = function() {
                return this.lineDash_;
              };
              Stroke2.prototype.getLineDashOffset = function() {
                return this.lineDashOffset_;
              };
              Stroke2.prototype.getLineJoin = function() {
                return this.lineJoin_;
              };
              Stroke2.prototype.getMiterLimit = function() {
                return this.miterLimit_;
              };
              Stroke2.prototype.getWidth = function() {
                return this.width_;
              };
              Stroke2.prototype.setColor = function(color) {
                this.color_ = color;
              };
              Stroke2.prototype.setLineCap = function(lineCap) {
                this.lineCap_ = lineCap;
              };
              Stroke2.prototype.setLineDash = function(lineDash) {
                this.lineDash_ = lineDash;
              };
              Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {
                this.lineDashOffset_ = lineDashOffset;
              };
              Stroke2.prototype.setLineJoin = function(lineJoin) {
                this.lineJoin_ = lineJoin;
              };
              Stroke2.prototype.setMiterLimit = function(miterLimit) {
                this.miterLimit_ = miterLimit;
              };
              Stroke2.prototype.setWidth = function(width) {
                this.width_ = width;
              };
              return Stroke2;
            }()
          );
          var style_Stroke = Stroke;
          var Style = (
            /** @class */
            function() {
              function Style2(opt_options) {
                var options = opt_options || {};
                this.geometry_ = null;
                this.geometryFunction_ = defaultGeometryFunction;
                if (options.geometry !== void 0) {
                  this.setGeometry(options.geometry);
                }
                this.fill_ = options.fill !== void 0 ? options.fill : null;
                this.image_ = options.image !== void 0 ? options.image : null;
                this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
                this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
                this.text_ = options.text !== void 0 ? options.text : null;
                this.zIndex_ = options.zIndex;
              }
              Style2.prototype.clone = function() {
                var geometry = this.getGeometry();
                if (geometry && typeof geometry === "object") {
                  geometry = /** @type {import("../geom/Geometry.js").default} */
                  geometry.clone();
                }
                return new Style2({
                  geometry,
                  fill: this.getFill() ? this.getFill().clone() : void 0,
                  image: this.getImage() ? this.getImage().clone() : void 0,
                  renderer: this.getRenderer(),
                  stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                  text: this.getText() ? this.getText().clone() : void 0,
                  zIndex: this.getZIndex()
                });
              };
              Style2.prototype.getRenderer = function() {
                return this.renderer_;
              };
              Style2.prototype.setRenderer = function(renderer) {
                this.renderer_ = renderer;
              };
              Style2.prototype.getGeometry = function() {
                return this.geometry_;
              };
              Style2.prototype.getGeometryFunction = function() {
                return this.geometryFunction_;
              };
              Style2.prototype.getFill = function() {
                return this.fill_;
              };
              Style2.prototype.setFill = function(fill) {
                this.fill_ = fill;
              };
              Style2.prototype.getImage = function() {
                return this.image_;
              };
              Style2.prototype.setImage = function(image) {
                this.image_ = image;
              };
              Style2.prototype.getStroke = function() {
                return this.stroke_;
              };
              Style2.prototype.setStroke = function(stroke) {
                this.stroke_ = stroke;
              };
              Style2.prototype.getText = function() {
                return this.text_;
              };
              Style2.prototype.setText = function(text) {
                this.text_ = text;
              };
              Style2.prototype.getZIndex = function() {
                return this.zIndex_;
              };
              Style2.prototype.setGeometry = function(geometry) {
                if (typeof geometry === "function") {
                  this.geometryFunction_ = geometry;
                } else if (typeof geometry === "string") {
                  this.geometryFunction_ = function(feature) {
                    return (
                      /** @type {import("../geom/Geometry.js").default} */
                      feature.get(geometry)
                    );
                  };
                } else if (!geometry) {
                  this.geometryFunction_ = defaultGeometryFunction;
                } else if (geometry !== void 0) {
                  this.geometryFunction_ = function() {
                    return (
                      /** @type {import("../geom/Geometry.js").default} */
                      geometry
                    );
                  };
                }
                this.geometry_ = geometry;
              };
              Style2.prototype.setZIndex = function(zIndex) {
                this.zIndex_ = zIndex;
              };
              return Style2;
            }()
          );
          function toFunction(obj) {
            var styleFunction;
            if (typeof obj === "function") {
              styleFunction = obj;
            } else {
              var styles_1;
              if (Array.isArray(obj)) {
                styles_1 = obj;
              } else {
                assert2(typeof /** @type {?} */
                obj.getZIndex === "function", 41);
                var style = (
                  /** @type {Style} */
                  obj
                );
                styles_1 = [style];
              }
              styleFunction = function() {
                return styles_1;
              };
            }
            return styleFunction;
          }
          var defaultStyles = null;
          function createDefaultStyle(feature, resolution) {
            if (!defaultStyles) {
              var fill = new style_Fill({
                color: "rgba(255,255,255,0.4)"
              });
              var stroke = new style_Stroke({
                color: "#3399CC",
                width: 1.25
              });
              defaultStyles = [
                new Style({
                  image: new style_Circle({
                    fill,
                    stroke,
                    radius: 5
                  }),
                  fill,
                  stroke
                })
              ];
            }
            return defaultStyles;
          }
          function createEditingStyle() {
            var styles = {};
            var white = [255, 255, 255, 1];
            var blue = [0, 153, 255, 1];
            var width = 3;
            styles[geom_GeometryType.POLYGON] = [
              new Style({
                fill: new style_Fill({
                  color: [255, 255, 255, 0.5]
                })
              })
            ];
            styles[geom_GeometryType.MULTI_POLYGON] = styles[geom_GeometryType.POLYGON];
            styles[geom_GeometryType.LINE_STRING] = [
              new Style({
                stroke: new style_Stroke({
                  color: white,
                  width: width + 2
                })
              }),
              new Style({
                stroke: new style_Stroke({
                  color: blue,
                  width
                })
              })
            ];
            styles[geom_GeometryType.MULTI_LINE_STRING] = styles[geom_GeometryType.LINE_STRING];
            styles[geom_GeometryType.CIRCLE] = styles[geom_GeometryType.POLYGON].concat(styles[geom_GeometryType.LINE_STRING]);
            styles[geom_GeometryType.POINT] = [
              new Style({
                image: new style_Circle({
                  radius: width * 2,
                  fill: new style_Fill({
                    color: blue
                  }),
                  stroke: new style_Stroke({
                    color: white,
                    width: width / 2
                  })
                }),
                zIndex: Infinity
              })
            ];
            styles[geom_GeometryType.MULTI_POINT] = styles[geom_GeometryType.POINT];
            styles[geom_GeometryType.GEOMETRY_COLLECTION] = styles[geom_GeometryType.POLYGON].concat(styles[geom_GeometryType.LINE_STRING], styles[geom_GeometryType.POINT]);
            return styles;
          }
          function defaultGeometryFunction(feature) {
            return feature.getGeometry();
          }
          var style_Style = Style;
          var BaseVector_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var BaseVector_Property = {
            RENDER_ORDER: "renderOrder"
          };
          var BaseVector_BaseVectorLayer = (
            /** @class */
            function(_super) {
              BaseVector_extends(BaseVectorLayer, _super);
              function BaseVectorLayer(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var baseOptions = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, options);
                delete baseOptions.style;
                delete baseOptions.renderBuffer;
                delete baseOptions.updateWhileAnimating;
                delete baseOptions.updateWhileInteracting;
                _this = _super.call(this, baseOptions) || this;
                _this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
                _this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
                _this.style_ = null;
                _this.styleFunction_ = void 0;
                _this.setStyle(options.style);
                _this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
                _this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
                return _this;
              }
              BaseVectorLayer.prototype.getDeclutter = function() {
                return this.declutter_;
              };
              BaseVectorLayer.prototype.getFeatures = function(pixel) {
                return _super.prototype.getFeatures.call(this, pixel);
              };
              BaseVectorLayer.prototype.getRenderBuffer = function() {
                return this.renderBuffer_;
              };
              BaseVectorLayer.prototype.getRenderOrder = function() {
                return (
                  /** @type {import("../render.js").OrderFunction|null|undefined} */
                  this.get(BaseVector_Property.RENDER_ORDER)
                );
              };
              BaseVectorLayer.prototype.getStyle = function() {
                return this.style_;
              };
              BaseVectorLayer.prototype.getStyleFunction = function() {
                return this.styleFunction_;
              };
              BaseVectorLayer.prototype.getUpdateWhileAnimating = function() {
                return this.updateWhileAnimating_;
              };
              BaseVectorLayer.prototype.getUpdateWhileInteracting = function() {
                return this.updateWhileInteracting_;
              };
              BaseVectorLayer.prototype.renderDeclutter = function(frameState) {
                if (!frameState.declutterTree) {
                  frameState.declutterTree = new rbush_min_default.a(9);
                }
                this.getRenderer().renderDeclutter(frameState);
              };
              BaseVectorLayer.prototype.setRenderOrder = function(renderOrder) {
                this.set(BaseVector_Property.RENDER_ORDER, renderOrder);
              };
              BaseVectorLayer.prototype.setStyle = function(opt_style) {
                this.style_ = opt_style !== void 0 ? opt_style : createDefaultStyle;
                this.styleFunction_ = opt_style === null ? void 0 : toFunction(this.style_);
                this.changed();
              };
              return BaseVectorLayer;
            }(layer_Layer)
          );
          var BaseVector = BaseVector_BaseVectorLayer;
          var Instruction = {
            BEGIN_GEOMETRY: 0,
            BEGIN_PATH: 1,
            CIRCLE: 2,
            CLOSE_PATH: 3,
            CUSTOM: 4,
            DRAW_CHARS: 5,
            DRAW_IMAGE: 6,
            END_GEOMETRY: 7,
            FILL: 8,
            MOVE_TO_LINE_TO: 9,
            SET_FILL_STYLE: 10,
            SET_STROKE_STYLE: 11,
            STROKE: 12
          };
          var Instruction_fillInstruction = [Instruction.FILL];
          var Instruction_strokeInstruction = [Instruction.STROKE];
          var beginPathInstruction = [Instruction.BEGIN_PATH];
          var closePathInstruction = [Instruction.CLOSE_PATH];
          var canvas_Instruction = Instruction;
          var VectorContext = (
            /** @class */
            function() {
              function VectorContext2() {
              }
              VectorContext2.prototype.drawCustom = function(geometry, feature, renderer) {
              };
              VectorContext2.prototype.drawGeometry = function(geometry) {
              };
              VectorContext2.prototype.setStyle = function(style) {
              };
              VectorContext2.prototype.drawCircle = function(circleGeometry, feature) {
              };
              VectorContext2.prototype.drawFeature = function(feature, style) {
              };
              VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
              };
              VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature) {
              };
              VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
              };
              VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
              };
              VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
              };
              VectorContext2.prototype.drawPoint = function(pointGeometry, feature) {
              };
              VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature) {
              };
              VectorContext2.prototype.drawText = function(geometry, feature) {
              };
              VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
              };
              VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
              };
              VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
              };
              return VectorContext2;
            }()
          );
          var render_VectorContext = VectorContext;
          var Builder_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Builder_CanvasBuilder = (
            /** @class */
            function(_super) {
              Builder_extends(CanvasBuilder, _super);
              function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
                var _this = _super.call(this) || this;
                _this.tolerance = tolerance;
                _this.maxExtent = maxExtent;
                _this.pixelRatio = pixelRatio;
                _this.maxLineWidth = 0;
                _this.resolution = resolution;
                _this.beginGeometryInstruction1_ = null;
                _this.beginGeometryInstruction2_ = null;
                _this.bufferedMaxExtent_ = null;
                _this.instructions = [];
                _this.coordinates = [];
                _this.tmpCoordinate_ = [];
                _this.hitDetectionInstructions = [];
                _this.state = /** @type {import("../canvas.js").FillStrokeState} */
                {};
                return _this;
              }
              CanvasBuilder.prototype.applyPixelRatio = function(dashArray) {
                var pixelRatio = this.pixelRatio;
                return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
                  return dash * pixelRatio;
                });
              };
              CanvasBuilder.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
                var extent = this.getBufferedMaxExtent();
                var tmpCoord = this.tmpCoordinate_;
                var coordinates = this.coordinates;
                var myEnd = coordinates.length;
                for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                  tmpCoord[0] = flatCoordinates[i];
                  tmpCoord[1] = flatCoordinates[i + 1];
                  if (containsCoordinate(extent, tmpCoord)) {
                    coordinates[myEnd++] = tmpCoord[0];
                    coordinates[myEnd++] = tmpCoord[1];
                  }
                }
                return myEnd;
              };
              CanvasBuilder.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
                var coordinates = this.coordinates;
                var myEnd = coordinates.length;
                var extent = this.getBufferedMaxExtent();
                if (skipFirst) {
                  offset += stride;
                }
                var lastXCoord = flatCoordinates[offset];
                var lastYCoord = flatCoordinates[offset + 1];
                var nextCoord = this.tmpCoordinate_;
                var skipped = true;
                var i, lastRel, nextRel;
                for (i = offset + stride; i < end; i += stride) {
                  nextCoord[0] = flatCoordinates[i];
                  nextCoord[1] = flatCoordinates[i + 1];
                  nextRel = coordinateRelationship(extent, nextCoord);
                  if (nextRel !== lastRel) {
                    if (skipped) {
                      coordinates[myEnd++] = lastXCoord;
                      coordinates[myEnd++] = lastYCoord;
                      skipped = false;
                    }
                    coordinates[myEnd++] = nextCoord[0];
                    coordinates[myEnd++] = nextCoord[1];
                  } else if (nextRel === Relationship.INTERSECTING) {
                    coordinates[myEnd++] = nextCoord[0];
                    coordinates[myEnd++] = nextCoord[1];
                    skipped = false;
                  } else {
                    skipped = true;
                  }
                  lastXCoord = nextCoord[0];
                  lastYCoord = nextCoord[1];
                  lastRel = nextRel;
                }
                if (closed && skipped || i === offset + stride) {
                  coordinates[myEnd++] = lastXCoord;
                  coordinates[myEnd++] = lastYCoord;
                }
                return myEnd;
              };
              CanvasBuilder.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, builderEnds) {
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  var end = ends[i];
                  var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
                  builderEnds.push(builderEnd);
                  offset = end;
                }
                return offset;
              };
              CanvasBuilder.prototype.drawCustom = function(geometry, feature, renderer) {
                this.beginGeometry(geometry, feature);
                var type = geometry.getType();
                var stride = geometry.getStride();
                var builderBegin = this.coordinates.length;
                var flatCoordinates, builderEnd, builderEnds, builderEndss;
                var offset;
                if (type == geom_GeometryType.MULTI_POLYGON) {
                  flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
                  geometry.getOrientedFlatCoordinates();
                  builderEndss = [];
                  var endss = (
                    /** @type {import("../../geom/MultiPolygon.js").default} */
                    geometry.getEndss()
                  );
                  offset = 0;
                  for (var i = 0, ii = endss.length; i < ii; ++i) {
                    var myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                  }
                  this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    inflateMultiCoordinatesArray
                  ]);
                } else if (type == geom_GeometryType.POLYGON || type == geom_GeometryType.MULTI_LINE_STRING) {
                  builderEnds = [];
                  flatCoordinates = type == geom_GeometryType.POLYGON ? (
                    /** @type {import("../../geom/Polygon.js").default} */
                    geometry.getOrientedFlatCoordinates()
                  ) : geometry.getFlatCoordinates();
                  offset = this.drawCustomCoordinates_(
                    flatCoordinates,
                    0,
                    /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
                    geometry.getEnds(),
                    stride,
                    builderEnds
                  );
                  this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    inflateCoordinatesArray
                  ]);
                } else if (type == geom_GeometryType.LINE_STRING || type == geom_GeometryType.CIRCLE) {
                  flatCoordinates = geometry.getFlatCoordinates();
                  builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                  this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    inflateCoordinates
                  ]);
                } else if (type == geom_GeometryType.MULTI_POINT) {
                  flatCoordinates = geometry.getFlatCoordinates();
                  builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                  if (builderEnd > builderBegin) {
                    this.instructions.push([
                      canvas_Instruction.CUSTOM,
                      builderBegin,
                      builderEnd,
                      geometry,
                      renderer,
                      inflateCoordinates
                    ]);
                  }
                } else if (type == geom_GeometryType.POINT) {
                  flatCoordinates = geometry.getFlatCoordinates();
                  this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                  builderEnd = this.coordinates.length;
                  this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer
                  ]);
                }
                this.endGeometry(feature);
              };
              CanvasBuilder.prototype.beginGeometry = function(geometry, feature) {
                this.beginGeometryInstruction1_ = [
                  canvas_Instruction.BEGIN_GEOMETRY,
                  feature,
                  0,
                  geometry
                ];
                this.instructions.push(this.beginGeometryInstruction1_);
                this.beginGeometryInstruction2_ = [
                  canvas_Instruction.BEGIN_GEOMETRY,
                  feature,
                  0,
                  geometry
                ];
                this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
              };
              CanvasBuilder.prototype.finish = function() {
                return {
                  instructions: this.instructions,
                  hitDetectionInstructions: this.hitDetectionInstructions,
                  coordinates: this.coordinates
                };
              };
              CanvasBuilder.prototype.reverseHitDetectionInstructions = function() {
                var hitDetectionInstructions = this.hitDetectionInstructions;
                hitDetectionInstructions.reverse();
                var i;
                var n = hitDetectionInstructions.length;
                var instruction;
                var type;
                var begin = -1;
                for (i = 0; i < n; ++i) {
                  instruction = hitDetectionInstructions[i];
                  type = /** @type {import("./Instruction.js").default} */
                  instruction[0];
                  if (type == canvas_Instruction.END_GEOMETRY) {
                    begin = i;
                  } else if (type == canvas_Instruction.BEGIN_GEOMETRY) {
                    instruction[2] = i;
                    Object(ol_array[
                      "j"
                      /* reverseSubArray */
                    ])(this.hitDetectionInstructions, begin, i);
                    begin = -1;
                  }
                }
              };
              CanvasBuilder.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
                var state = this.state;
                if (fillStyle) {
                  var fillStyleColor = fillStyle.getColor();
                  state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
                } else {
                  state.fillStyle = void 0;
                }
                if (strokeStyle) {
                  var strokeStyleColor = strokeStyle.getColor();
                  state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
                  var strokeStyleLineCap = strokeStyle.getLineCap();
                  state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
                  var strokeStyleLineDash = strokeStyle.getLineDash();
                  state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
                  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
                  state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
                  var strokeStyleLineJoin = strokeStyle.getLineJoin();
                  state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
                  var strokeStyleWidth = strokeStyle.getWidth();
                  state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
                  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
                  state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
                  if (state.lineWidth > this.maxLineWidth) {
                    this.maxLineWidth = state.lineWidth;
                    this.bufferedMaxExtent_ = null;
                  }
                } else {
                  state.strokeStyle = void 0;
                  state.lineCap = void 0;
                  state.lineDash = null;
                  state.lineDashOffset = void 0;
                  state.lineJoin = void 0;
                  state.lineWidth = void 0;
                  state.miterLimit = void 0;
                }
              };
              CanvasBuilder.prototype.createFill = function(state) {
                var fillStyle = state.fillStyle;
                var fillInstruction = [canvas_Instruction.SET_FILL_STYLE, fillStyle];
                if (typeof fillStyle !== "string") {
                  fillInstruction.push(true);
                }
                return fillInstruction;
              };
              CanvasBuilder.prototype.applyStroke = function(state) {
                this.instructions.push(this.createStroke(state));
              };
              CanvasBuilder.prototype.createStroke = function(state) {
                return [
                  canvas_Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth * this.pixelRatio,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  this.applyPixelRatio(state.lineDash),
                  state.lineDashOffset * this.pixelRatio
                ];
              };
              CanvasBuilder.prototype.updateFillStyle = function(state, createFill) {
                var fillStyle = state.fillStyle;
                if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
                  if (fillStyle !== void 0) {
                    this.instructions.push(createFill.call(this, state));
                  }
                  state.currentFillStyle = fillStyle;
                }
              };
              CanvasBuilder.prototype.updateStrokeStyle = function(state, applyStroke) {
                var strokeStyle = state.strokeStyle;
                var lineCap = state.lineCap;
                var lineDash = state.lineDash;
                var lineDashOffset = state.lineDashOffset;
                var lineJoin = state.lineJoin;
                var lineWidth = state.lineWidth;
                var miterLimit = state.miterLimit;
                if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !Object(ol_array[
                  "b"
                  /* equals */
                ])(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
                  if (strokeStyle !== void 0) {
                    applyStroke.call(this, state);
                  }
                  state.currentStrokeStyle = strokeStyle;
                  state.currentLineCap = lineCap;
                  state.currentLineDash = lineDash;
                  state.currentLineDashOffset = lineDashOffset;
                  state.currentLineJoin = lineJoin;
                  state.currentLineWidth = lineWidth;
                  state.currentMiterLimit = miterLimit;
                }
              };
              CanvasBuilder.prototype.endGeometry = function(feature) {
                this.beginGeometryInstruction1_[2] = this.instructions.length;
                this.beginGeometryInstruction1_ = null;
                this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
                this.beginGeometryInstruction2_ = null;
                var endGeometryInstruction = [canvas_Instruction.END_GEOMETRY, feature];
                this.instructions.push(endGeometryInstruction);
                this.hitDetectionInstructions.push(endGeometryInstruction);
              };
              CanvasBuilder.prototype.getBufferedMaxExtent = function() {
                if (!this.bufferedMaxExtent_) {
                  this.bufferedMaxExtent_ = clone(this.maxExtent);
                  if (this.maxLineWidth > 0) {
                    var width = this.resolution * (this.maxLineWidth + 1) / 2;
                    extent_buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
                  }
                }
                return this.bufferedMaxExtent_;
              };
              return CanvasBuilder;
            }(render_VectorContext)
          );
          var Builder = Builder_CanvasBuilder;
          var ImageBuilder_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageBuilder_CanvasImageBuilder = (
            /** @class */
            function(_super) {
              ImageBuilder_extends(CanvasImageBuilder, _super);
              function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
                var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
                _this.hitDetectionImage_ = null;
                _this.image_ = null;
                _this.imagePixelRatio_ = void 0;
                _this.anchorX_ = void 0;
                _this.anchorY_ = void 0;
                _this.height_ = void 0;
                _this.opacity_ = void 0;
                _this.originX_ = void 0;
                _this.originY_ = void 0;
                _this.rotateWithView_ = void 0;
                _this.rotation_ = void 0;
                _this.scale_ = void 0;
                _this.width_ = void 0;
                _this.declutterImageWithText_ = void 0;
                return _this;
              }
              CanvasImageBuilder.prototype.drawPoint = function(pointGeometry, feature) {
                if (!this.image_) {
                  return;
                }
                this.beginGeometry(pointGeometry, feature);
                var flatCoordinates = pointGeometry.getFlatCoordinates();
                var stride = pointGeometry.getStride();
                var myBegin = this.coordinates.length;
                var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                this.instructions.push([
                  canvas_Instruction.DRAW_IMAGE,
                  myBegin,
                  myEnd,
                  this.image_,
                  // Remaining arguments to DRAW_IMAGE are in alphabetical order
                  this.anchorX_ * this.imagePixelRatio_,
                  this.anchorY_ * this.imagePixelRatio_,
                  Math.ceil(this.height_ * this.imagePixelRatio_),
                  this.opacity_,
                  this.originX_,
                  this.originY_,
                  this.rotateWithView_,
                  this.rotation_,
                  [
                    this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                    this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
                  ],
                  Math.ceil(this.width_ * this.imagePixelRatio_),
                  this.declutterImageWithText_
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.DRAW_IMAGE,
                  myBegin,
                  myEnd,
                  this.hitDetectionImage_,
                  // Remaining arguments to DRAW_IMAGE are in alphabetical order
                  this.anchorX_,
                  this.anchorY_,
                  this.height_,
                  this.opacity_,
                  this.originX_,
                  this.originY_,
                  this.rotateWithView_,
                  this.rotation_,
                  this.scale_,
                  this.width_,
                  this.declutterImageWithText_
                ]);
                this.endGeometry(feature);
              };
              CanvasImageBuilder.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
                if (!this.image_) {
                  return;
                }
                this.beginGeometry(multiPointGeometry, feature);
                var flatCoordinates = multiPointGeometry.getFlatCoordinates();
                var stride = multiPointGeometry.getStride();
                var myBegin = this.coordinates.length;
                var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                this.instructions.push([
                  canvas_Instruction.DRAW_IMAGE,
                  myBegin,
                  myEnd,
                  this.image_,
                  // Remaining arguments to DRAW_IMAGE are in alphabetical order
                  this.anchorX_ * this.imagePixelRatio_,
                  this.anchorY_ * this.imagePixelRatio_,
                  Math.ceil(this.height_ * this.imagePixelRatio_),
                  this.opacity_,
                  this.originX_,
                  this.originY_,
                  this.rotateWithView_,
                  this.rotation_,
                  [
                    this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                    this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
                  ],
                  Math.ceil(this.width_ * this.imagePixelRatio_),
                  this.declutterImageWithText_
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.DRAW_IMAGE,
                  myBegin,
                  myEnd,
                  this.hitDetectionImage_,
                  // Remaining arguments to DRAW_IMAGE are in alphabetical order
                  this.anchorX_,
                  this.anchorY_,
                  this.height_,
                  this.opacity_,
                  this.originX_,
                  this.originY_,
                  this.rotateWithView_,
                  this.rotation_,
                  this.scale_,
                  this.width_,
                  this.declutterImageWithText_
                ]);
                this.endGeometry(feature);
              };
              CanvasImageBuilder.prototype.finish = function() {
                this.reverseHitDetectionInstructions();
                this.anchorX_ = void 0;
                this.anchorY_ = void 0;
                this.hitDetectionImage_ = null;
                this.image_ = null;
                this.imagePixelRatio_ = void 0;
                this.height_ = void 0;
                this.scale_ = void 0;
                this.opacity_ = void 0;
                this.originX_ = void 0;
                this.originY_ = void 0;
                this.rotateWithView_ = void 0;
                this.rotation_ = void 0;
                this.width_ = void 0;
                return _super.prototype.finish.call(this);
              };
              CanvasImageBuilder.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
                var anchor = imageStyle.getAnchor();
                var size = imageStyle.getSize();
                var hitDetectionImage = imageStyle.getHitDetectionImage();
                var image = imageStyle.getImage(this.pixelRatio);
                var origin = imageStyle.getOrigin();
                this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
                this.anchorX_ = anchor[0];
                this.anchorY_ = anchor[1];
                this.hitDetectionImage_ = hitDetectionImage;
                this.image_ = image;
                this.height_ = size[1];
                this.opacity_ = imageStyle.getOpacity();
                this.originX_ = origin[0];
                this.originY_ = origin[1];
                this.rotateWithView_ = imageStyle.getRotateWithView();
                this.rotation_ = imageStyle.getRotation();
                this.scale_ = imageStyle.getScaleArray();
                this.width_ = size[0];
                this.declutterImageWithText_ = opt_sharedData;
              };
              return CanvasImageBuilder;
            }(Builder)
          );
          var ImageBuilder = ImageBuilder_CanvasImageBuilder;
          var LineStringBuilder_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LineStringBuilder_CanvasLineStringBuilder = (
            /** @class */
            function(_super) {
              LineStringBuilder_extends(CanvasLineStringBuilder, _super);
              function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
                return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
              }
              CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
                var myBegin = this.coordinates.length;
                var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
                var moveToLineToInstruction = [
                  canvas_Instruction.MOVE_TO_LINE_TO,
                  myBegin,
                  myEnd
                ];
                this.instructions.push(moveToLineToInstruction);
                this.hitDetectionInstructions.push(moveToLineToInstruction);
                return end;
              };
              CanvasLineStringBuilder.prototype.drawLineString = function(lineStringGeometry, feature) {
                var state = this.state;
                var strokeStyle = state.strokeStyle;
                var lineWidth = state.lineWidth;
                if (strokeStyle === void 0 || lineWidth === void 0) {
                  return;
                }
                this.updateStrokeStyle(state, this.applyStroke);
                this.beginGeometry(lineStringGeometry, feature);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  defaultLineDash,
                  defaultLineDashOffset
                ], beginPathInstruction);
                var flatCoordinates = lineStringGeometry.getFlatCoordinates();
                var stride = lineStringGeometry.getStride();
                this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
                this.hitDetectionInstructions.push(Instruction_strokeInstruction);
                this.endGeometry(feature);
              };
              CanvasLineStringBuilder.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
                var state = this.state;
                var strokeStyle = state.strokeStyle;
                var lineWidth = state.lineWidth;
                if (strokeStyle === void 0 || lineWidth === void 0) {
                  return;
                }
                this.updateStrokeStyle(state, this.applyStroke);
                this.beginGeometry(multiLineStringGeometry, feature);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset
                ], beginPathInstruction);
                var ends = multiLineStringGeometry.getEnds();
                var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
                var stride = multiLineStringGeometry.getStride();
                var offset = 0;
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  offset = this.drawFlatCoordinates_(
                    flatCoordinates,
                    offset,
                    /** @type {number} */
                    ends[i],
                    stride
                  );
                }
                this.hitDetectionInstructions.push(Instruction_strokeInstruction);
                this.endGeometry(feature);
              };
              CanvasLineStringBuilder.prototype.finish = function() {
                var state = this.state;
                if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
                  this.instructions.push(Instruction_strokeInstruction);
                }
                this.reverseHitDetectionInstructions();
                this.state = null;
                return _super.prototype.finish.call(this);
              };
              CanvasLineStringBuilder.prototype.applyStroke = function(state) {
                if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
                  this.instructions.push(Instruction_strokeInstruction);
                  state.lastStroke = this.coordinates.length;
                }
                state.lastStroke = 0;
                _super.prototype.applyStroke.call(this, state);
                this.instructions.push(beginPathInstruction);
              };
              return CanvasLineStringBuilder;
            }(Builder)
          );
          var LineStringBuilder = LineStringBuilder_CanvasLineStringBuilder;
          var PolygonBuilder_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var PolygonBuilder_CanvasPolygonBuilder = (
            /** @class */
            function(_super) {
              PolygonBuilder_extends(CanvasPolygonBuilder, _super);
              function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
                return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
              }
              CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
                var state = this.state;
                var fill = state.fillStyle !== void 0;
                var stroke = state.strokeStyle !== void 0;
                var numEnds = ends.length;
                this.instructions.push(beginPathInstruction);
                this.hitDetectionInstructions.push(beginPathInstruction);
                for (var i = 0; i < numEnds; ++i) {
                  var end = ends[i];
                  var myBegin = this.coordinates.length;
                  var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
                  var moveToLineToInstruction = [
                    canvas_Instruction.MOVE_TO_LINE_TO,
                    myBegin,
                    myEnd
                  ];
                  this.instructions.push(moveToLineToInstruction);
                  this.hitDetectionInstructions.push(moveToLineToInstruction);
                  if (stroke) {
                    this.instructions.push(closePathInstruction);
                    this.hitDetectionInstructions.push(closePathInstruction);
                  }
                  offset = end;
                }
                if (fill) {
                  this.instructions.push(Instruction_fillInstruction);
                  this.hitDetectionInstructions.push(Instruction_fillInstruction);
                }
                if (stroke) {
                  this.instructions.push(Instruction_strokeInstruction);
                  this.hitDetectionInstructions.push(Instruction_strokeInstruction);
                }
                return offset;
              };
              CanvasPolygonBuilder.prototype.drawCircle = function(circleGeometry, feature) {
                var state = this.state;
                var fillStyle = state.fillStyle;
                var strokeStyle = state.strokeStyle;
                if (fillStyle === void 0 && strokeStyle === void 0) {
                  return;
                }
                this.setFillStrokeStyles_();
                this.beginGeometry(circleGeometry, feature);
                if (state.fillStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_FILL_STYLE,
                    defaultFillStyle
                  ]);
                }
                if (state.strokeStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset
                  ]);
                }
                var flatCoordinates = circleGeometry.getFlatCoordinates();
                var stride = circleGeometry.getStride();
                var myBegin = this.coordinates.length;
                this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                var circleInstruction = [canvas_Instruction.CIRCLE, myBegin];
                this.instructions.push(beginPathInstruction, circleInstruction);
                this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
                if (state.fillStyle !== void 0) {
                  this.instructions.push(Instruction_fillInstruction);
                  this.hitDetectionInstructions.push(Instruction_fillInstruction);
                }
                if (state.strokeStyle !== void 0) {
                  this.instructions.push(Instruction_strokeInstruction);
                  this.hitDetectionInstructions.push(Instruction_strokeInstruction);
                }
                this.endGeometry(feature);
              };
              CanvasPolygonBuilder.prototype.drawPolygon = function(polygonGeometry, feature) {
                var state = this.state;
                var fillStyle = state.fillStyle;
                var strokeStyle = state.strokeStyle;
                if (fillStyle === void 0 && strokeStyle === void 0) {
                  return;
                }
                this.setFillStrokeStyles_();
                this.beginGeometry(polygonGeometry, feature);
                if (state.fillStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_FILL_STYLE,
                    defaultFillStyle
                  ]);
                }
                if (state.strokeStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset
                  ]);
                }
                var ends = polygonGeometry.getEnds();
                var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
                var stride = polygonGeometry.getStride();
                this.drawFlatCoordinatess_(
                  flatCoordinates,
                  0,
                  /** @type {Array<number>} */
                  ends,
                  stride
                );
                this.endGeometry(feature);
              };
              CanvasPolygonBuilder.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
                var state = this.state;
                var fillStyle = state.fillStyle;
                var strokeStyle = state.strokeStyle;
                if (fillStyle === void 0 && strokeStyle === void 0) {
                  return;
                }
                this.setFillStrokeStyles_();
                this.beginGeometry(multiPolygonGeometry, feature);
                if (state.fillStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_FILL_STYLE,
                    defaultFillStyle
                  ]);
                }
                if (state.strokeStyle !== void 0) {
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.SET_STROKE_STYLE,
                    state.strokeStyle,
                    state.lineWidth,
                    state.lineCap,
                    state.lineJoin,
                    state.miterLimit,
                    state.lineDash,
                    state.lineDashOffset
                  ]);
                }
                var endss = multiPolygonGeometry.getEndss();
                var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
                var stride = multiPolygonGeometry.getStride();
                var offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
                }
                this.endGeometry(feature);
              };
              CanvasPolygonBuilder.prototype.finish = function() {
                this.reverseHitDetectionInstructions();
                this.state = null;
                var tolerance = this.tolerance;
                if (tolerance !== 0) {
                  var coordinates = this.coordinates;
                  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                    coordinates[i] = simplify_snap(coordinates[i], tolerance);
                  }
                }
                return _super.prototype.finish.call(this);
              };
              CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function() {
                var state = this.state;
                var fillStyle = state.fillStyle;
                if (fillStyle !== void 0) {
                  this.updateFillStyle(state, this.createFill);
                }
                if (state.strokeStyle !== void 0) {
                  this.updateStrokeStyle(state, this.applyStroke);
                }
              };
              return CanvasPolygonBuilder;
            }(Builder)
          );
          var PolygonBuilder = PolygonBuilder_CanvasPolygonBuilder;
          var TextPlacement = {
            POINT: "point",
            LINE: "line"
          };
          function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
            var chunkStart = offset;
            var chunkEnd = offset;
            var chunkM = 0;
            var m = 0;
            var start = offset;
            var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
            for (i = offset; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              if (x1 !== void 0) {
                x23 = x2 - x1;
                y23 = y2 - y1;
                m23 = Math.sqrt(x23 * x23 + y23 * y23);
                if (x12 !== void 0) {
                  m += m12;
                  acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                  if (acos > maxAngle) {
                    if (m > chunkM) {
                      chunkM = m;
                      chunkStart = start;
                      chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                  }
                }
                m12 = m23;
                x12 = x23;
                y12 = y23;
              }
              x1 = x2;
              y1 = y2;
            }
            m += m23;
            return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
          }
          var TextBuilder_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TEXT_ALIGN = {
            "left": 0,
            "end": 0,
            "center": 0.5,
            "right": 1,
            "start": 1,
            "top": 0,
            "middle": 0.5,
            "hanging": 0.2,
            "alphabetic": 0.8,
            "ideographic": 0.8,
            "bottom": 1
          };
          var TextBuilder_CanvasTextBuilder = (
            /** @class */
            function(_super) {
              TextBuilder_extends(CanvasTextBuilder, _super);
              function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
                var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
                _this.labels_ = null;
                _this.text_ = "";
                _this.textOffsetX_ = 0;
                _this.textOffsetY_ = 0;
                _this.textRotateWithView_ = void 0;
                _this.textRotation_ = 0;
                _this.textFillState_ = null;
                _this.fillStates = {};
                _this.textStrokeState_ = null;
                _this.strokeStates = {};
                _this.textState_ = /** @type {import("../canvas.js").TextState} */
                {};
                _this.textStates = {};
                _this.textKey_ = "";
                _this.fillKey_ = "";
                _this.strokeKey_ = "";
                _this.declutterImageWithText_ = void 0;
                return _this;
              }
              CanvasTextBuilder.prototype.finish = function() {
                var instructions = _super.prototype.finish.call(this);
                instructions.textStates = this.textStates;
                instructions.fillStates = this.fillStates;
                instructions.strokeStates = this.strokeStates;
                return instructions;
              };
              CanvasTextBuilder.prototype.drawText = function(geometry, feature) {
                var fillState = this.textFillState_;
                var strokeState = this.textStrokeState_;
                var textState = this.textState_;
                if (this.text_ === "" || !textState || !fillState && !strokeState) {
                  return;
                }
                var coordinates = this.coordinates;
                var begin = coordinates.length;
                var geometryType = geometry.getType();
                var flatCoordinates = null;
                var stride = geometry.getStride();
                if (textState.placement === TextPlacement.LINE && (geometryType == geom_GeometryType.LINE_STRING || geometryType == geom_GeometryType.MULTI_LINE_STRING || geometryType == geom_GeometryType.POLYGON || geometryType == geom_GeometryType.MULTI_POLYGON)) {
                  if (!extent_intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                    return;
                  }
                  var ends = void 0;
                  flatCoordinates = geometry.getFlatCoordinates();
                  if (geometryType == geom_GeometryType.LINE_STRING) {
                    ends = [flatCoordinates.length];
                  } else if (geometryType == geom_GeometryType.MULTI_LINE_STRING) {
                    ends = /** @type {import("../../geom/MultiLineString.js").default} */
                    geometry.getEnds();
                  } else if (geometryType == geom_GeometryType.POLYGON) {
                    ends = /** @type {import("../../geom/Polygon.js").default} */
                    geometry.getEnds().slice(0, 1);
                  } else if (geometryType == geom_GeometryType.MULTI_POLYGON) {
                    var endss = (
                      /** @type {import("../../geom/MultiPolygon.js").default} */
                      geometry.getEndss()
                    );
                    ends = [];
                    for (var i = 0, ii = endss.length; i < ii; ++i) {
                      ends.push(endss[i][0]);
                    }
                  }
                  this.beginGeometry(geometry, feature);
                  var textAlign = textState.textAlign;
                  var flatOffset = 0;
                  var flatEnd = void 0;
                  for (var o = 0, oo = ends.length; o < oo; ++o) {
                    if (textAlign == void 0) {
                      var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                      flatOffset = range[0];
                      flatEnd = range[1];
                    } else {
                      flatEnd = ends[o];
                    }
                    for (var i = flatOffset; i < flatEnd; i += stride) {
                      coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                    }
                    var end = coordinates.length;
                    flatOffset = ends[o];
                    this.drawChars_(begin, end);
                    begin = end;
                  }
                  this.endGeometry(feature);
                } else {
                  var geometryWidths = textState.overflow ? null : [];
                  switch (geometryType) {
                    case geom_GeometryType.POINT:
                    case geom_GeometryType.MULTI_POINT:
                      flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
                      geometry.getFlatCoordinates();
                      break;
                    case geom_GeometryType.LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
                      geometry.getFlatMidpoint();
                      break;
                    case geom_GeometryType.CIRCLE:
                      flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
                      geometry.getCenter();
                      break;
                    case geom_GeometryType.MULTI_LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
                      geometry.getFlatMidpoints();
                      stride = 2;
                      break;
                    case geom_GeometryType.POLYGON:
                      flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
                      geometry.getFlatInteriorPoint();
                      if (!textState.overflow) {
                        geometryWidths.push(flatCoordinates[2] / this.resolution);
                      }
                      stride = 3;
                      break;
                    case geom_GeometryType.MULTI_POLYGON:
                      var interiorPoints = (
                        /** @type {import("../../geom/MultiPolygon.js").default} */
                        geometry.getFlatInteriorPoints()
                      );
                      flatCoordinates = [];
                      for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                        if (!textState.overflow) {
                          geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                        }
                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                      }
                      if (flatCoordinates.length === 0) {
                        return;
                      }
                      stride = 2;
                      break;
                    default:
                  }
                  var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
                  if (end === begin) {
                    return;
                  }
                  if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                    var beg_1 = begin / 2;
                    geometryWidths = geometryWidths.filter(function(w, i2) {
                      var keep = coordinates[(beg_1 + i2) * 2] === flatCoordinates[i2 * stride] && coordinates[(beg_1 + i2) * 2 + 1] === flatCoordinates[i2 * stride + 1];
                      if (!keep) {
                        --beg_1;
                      }
                      return keep;
                    });
                  }
                  this.saveTextStates_();
                  if (textState.backgroundFill || textState.backgroundStroke) {
                    this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                    if (textState.backgroundFill) {
                      this.updateFillStyle(this.state, this.createFill);
                      this.hitDetectionInstructions.push(this.createFill(this.state));
                    }
                    if (textState.backgroundStroke) {
                      this.updateStrokeStyle(this.state, this.applyStroke);
                      this.hitDetectionInstructions.push(this.createStroke(this.state));
                    }
                  }
                  this.beginGeometry(geometry, feature);
                  var padding = textState.padding;
                  if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                    var p0 = textState.padding[0];
                    var p1 = textState.padding[1];
                    var p2 = textState.padding[2];
                    var p3 = textState.padding[3];
                    if (textState.scale[0] < 0) {
                      p1 = -p1;
                      p3 = -p3;
                    }
                    if (textState.scale[1] < 0) {
                      p0 = -p0;
                      p2 = -p2;
                    }
                    padding = [p0, p1, p2, p3];
                  }
                  var pixelRatio_1 = this.pixelRatio;
                  this.instructions.push([
                    canvas_Instruction.DRAW_IMAGE,
                    begin,
                    end,
                    null,
                    NaN,
                    NaN,
                    NaN,
                    1,
                    0,
                    0,
                    this.textRotateWithView_,
                    this.textRotation_,
                    [1, 1],
                    NaN,
                    this.declutterImageWithText_,
                    padding == defaultPadding ? defaultPadding : padding.map(function(p) {
                      return p * pixelRatio_1;
                    }),
                    !!textState.backgroundFill,
                    !!textState.backgroundStroke,
                    this.text_,
                    this.textKey_,
                    this.strokeKey_,
                    this.fillKey_,
                    this.textOffsetX_,
                    this.textOffsetY_,
                    geometryWidths
                  ]);
                  var scale = 1 / pixelRatio_1;
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.DRAW_IMAGE,
                    begin,
                    end,
                    null,
                    NaN,
                    NaN,
                    NaN,
                    1,
                    0,
                    0,
                    this.textRotateWithView_,
                    this.textRotation_,
                    [scale, scale],
                    NaN,
                    this.declutterImageWithText_,
                    padding,
                    !!textState.backgroundFill,
                    !!textState.backgroundStroke,
                    this.text_,
                    this.textKey_,
                    this.strokeKey_,
                    this.fillKey_,
                    this.textOffsetX_,
                    this.textOffsetY_,
                    geometryWidths
                  ]);
                  this.endGeometry(feature);
                }
              };
              CanvasTextBuilder.prototype.saveTextStates_ = function() {
                var strokeState = this.textStrokeState_;
                var textState = this.textState_;
                var fillState = this.textFillState_;
                var strokeKey = this.strokeKey_;
                if (strokeState) {
                  if (!(strokeKey in this.strokeStates)) {
                    this.strokeStates[strokeKey] = {
                      strokeStyle: strokeState.strokeStyle,
                      lineCap: strokeState.lineCap,
                      lineDashOffset: strokeState.lineDashOffset,
                      lineWidth: strokeState.lineWidth,
                      lineJoin: strokeState.lineJoin,
                      miterLimit: strokeState.miterLimit,
                      lineDash: strokeState.lineDash
                    };
                  }
                }
                var textKey = this.textKey_;
                if (!(textKey in this.textStates)) {
                  this.textStates[textKey] = {
                    font: textState.font,
                    textAlign: textState.textAlign || defaultTextAlign,
                    textBaseline: textState.textBaseline || defaultTextBaseline,
                    scale: textState.scale
                  };
                }
                var fillKey = this.fillKey_;
                if (fillState) {
                  if (!(fillKey in this.fillStates)) {
                    this.fillStates[fillKey] = {
                      fillStyle: fillState.fillStyle
                    };
                  }
                }
              };
              CanvasTextBuilder.prototype.drawChars_ = function(begin, end) {
                var strokeState = this.textStrokeState_;
                var textState = this.textState_;
                var strokeKey = this.strokeKey_;
                var textKey = this.textKey_;
                var fillKey = this.fillKey_;
                this.saveTextStates_();
                var pixelRatio = this.pixelRatio;
                var baseline = TEXT_ALIGN[textState.textBaseline];
                var offsetY = this.textOffsetY_ * pixelRatio;
                var text = this.text_;
                var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
                this.instructions.push([
                  canvas_Instruction.DRAW_CHARS,
                  begin,
                  end,
                  baseline,
                  textState.overflow,
                  fillKey,
                  textState.maxAngle,
                  pixelRatio,
                  offsetY,
                  strokeKey,
                  strokeWidth * pixelRatio,
                  text,
                  textKey,
                  1
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.DRAW_CHARS,
                  begin,
                  end,
                  baseline,
                  textState.overflow,
                  fillKey,
                  textState.maxAngle,
                  1,
                  offsetY,
                  strokeKey,
                  strokeWidth,
                  text,
                  textKey,
                  1 / pixelRatio
                ]);
              };
              CanvasTextBuilder.prototype.setTextStyle = function(textStyle, opt_sharedData) {
                var textState, fillState, strokeState;
                if (!textStyle) {
                  this.text_ = "";
                } else {
                  var textFillStyle = textStyle.getFill();
                  if (!textFillStyle) {
                    fillState = null;
                    this.textFillState_ = fillState;
                  } else {
                    fillState = this.textFillState_;
                    if (!fillState) {
                      fillState = /** @type {import("../canvas.js").FillState} */
                      {};
                      this.textFillState_ = fillState;
                    }
                    fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
                  }
                  var textStrokeStyle = textStyle.getStroke();
                  if (!textStrokeStyle) {
                    strokeState = null;
                    this.textStrokeState_ = strokeState;
                  } else {
                    strokeState = this.textStrokeState_;
                    if (!strokeState) {
                      strokeState = /** @type {import("../canvas.js").StrokeState} */
                      {};
                      this.textStrokeState_ = strokeState;
                    }
                    var lineDash = textStrokeStyle.getLineDash();
                    var lineDashOffset = textStrokeStyle.getLineDashOffset();
                    var lineWidth = textStrokeStyle.getWidth();
                    var miterLimit = textStrokeStyle.getMiterLimit();
                    strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                    strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                    strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
                    strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                    strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
                    strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
                    strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
                  }
                  textState = this.textState_;
                  var font = textStyle.getFont() || defaultFont;
                  registerFont(font);
                  var textScale = textStyle.getScaleArray();
                  textState.overflow = textStyle.getOverflow();
                  textState.font = font;
                  textState.maxAngle = textStyle.getMaxAngle();
                  textState.placement = textStyle.getPlacement();
                  textState.textAlign = textStyle.getTextAlign();
                  textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
                  textState.backgroundFill = textStyle.getBackgroundFill();
                  textState.backgroundStroke = textStyle.getBackgroundStroke();
                  textState.padding = textStyle.getPadding() || defaultPadding;
                  textState.scale = textScale === void 0 ? [1, 1] : textScale;
                  var textOffsetX = textStyle.getOffsetX();
                  var textOffsetY = textStyle.getOffsetY();
                  var textRotateWithView = textStyle.getRotateWithView();
                  var textRotation = textStyle.getRotation();
                  this.text_ = textStyle.getText() || "";
                  this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
                  this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
                  this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
                  this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
                  this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : Object(util[
                    "c"
                    /* getUid */
                  ])(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
                  this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.textBaseline || "?");
                  this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + Object(util[
                    "c"
                    /* getUid */
                  ])(fillState.fillStyle) : "";
                }
                this.declutterImageWithText_ = opt_sharedData;
              };
              return CanvasTextBuilder;
            }(Builder)
          );
          var TextBuilder = TextBuilder_CanvasTextBuilder;
          var BATCH_CONSTRUCTORS = {
            "Circle": PolygonBuilder,
            "Default": Builder,
            "Image": ImageBuilder,
            "LineString": LineStringBuilder,
            "Polygon": PolygonBuilder,
            "Text": TextBuilder
          };
          var BuilderGroup = (
            /** @class */
            function() {
              function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {
                this.tolerance_ = tolerance;
                this.maxExtent_ = maxExtent;
                this.pixelRatio_ = pixelRatio;
                this.resolution_ = resolution;
                this.buildersByZIndex_ = {};
              }
              BuilderGroup2.prototype.finish = function() {
                var builderInstructions = {};
                for (var zKey in this.buildersByZIndex_) {
                  builderInstructions[zKey] = builderInstructions[zKey] || {};
                  var builders = this.buildersByZIndex_[zKey];
                  for (var builderKey in builders) {
                    var builderInstruction = builders[builderKey].finish();
                    builderInstructions[zKey][builderKey] = builderInstruction;
                  }
                }
                return builderInstructions;
              };
              BuilderGroup2.prototype.getBuilder = function(zIndex, builderType) {
                var zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
                var replays = this.buildersByZIndex_[zIndexKey];
                if (replays === void 0) {
                  replays = {};
                  this.buildersByZIndex_[zIndexKey] = replays;
                }
                var replay = replays[builderType];
                if (replay === void 0) {
                  var Constructor = BATCH_CONSTRUCTORS[builderType];
                  replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
                  replays[builderType] = replay;
                }
                return replay;
              };
              return BuilderGroup2;
            }()
          );
          var canvas_BuilderGroup = BuilderGroup;
          var BuilderType = {
            CIRCLE: "Circle",
            DEFAULT: "Default",
            IMAGE: "Image",
            LINE_STRING: "LineString",
            POLYGON: "Polygon",
            TEXT: "Text"
          };
          function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            var x1 = 0;
            var y1 = 0;
            var segmentLength = 0;
            var segmentM = 0;
            function advance() {
              x1 = x2;
              y1 = y2;
              offset += stride;
              x2 = flatCoordinates[offset];
              y2 = flatCoordinates[offset + 1];
              segmentM += segmentLength;
              segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            }
            do {
              advance();
            } while (offset < end - stride && segmentM + segmentLength < startM);
            var interpolate = (startM - segmentM) / segmentLength;
            var beginX = lerp(x1, x2, interpolate);
            var beginY = lerp(y1, y2, interpolate);
            var startOffset = offset - stride;
            var startLength = segmentM;
            var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
            while (offset < end - stride && segmentM + segmentLength < endM) {
              advance();
            }
            interpolate = (endM - segmentM) / segmentLength;
            var endX = lerp(x1, x2, interpolate);
            var endY = lerp(y1, y2, interpolate);
            var reverse;
            if (rotation) {
              var flat = [beginX, beginY, endX, endY];
              transform_rotate(flat, 0, 4, 2, rotation, flat, flat);
              reverse = flat[0] > flat[2];
            } else {
              reverse = beginX > endX;
            }
            var PI = Math.PI;
            var result = [];
            var singleSegment = startOffset + stride === offset;
            offset = startOffset;
            segmentLength = 0;
            segmentM = startLength;
            x2 = flatCoordinates[offset];
            y2 = flatCoordinates[offset + 1];
            if (singleSegment) {
              advance();
              var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);
              if (reverse) {
                previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;
              }
              var x = (endX + beginX) / 2;
              var y = (endY + beginY) / 2;
              result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];
              return result;
            }
            var previousAngle;
            for (var i = 0, ii = text.length; i < ii; ) {
              advance();
              var angle = Math.atan2(y2 - y1, x2 - x1);
              if (reverse) {
                angle += angle > 0 ? -PI : PI;
              }
              if (previousAngle !== void 0) {
                var delta = angle - previousAngle;
                delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
                if (Math.abs(delta) > maxAngle) {
                  return null;
                }
              }
              previousAngle = angle;
              var iStart = i;
              var charLength = 0;
              for (; i < ii; ++i) {
                var index = reverse ? ii - i - 1 : i;
                var len = scale * measureAndCacheTextWidth(font, text[index], cache);
                if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
                  break;
                }
                charLength += len;
              }
              if (i === iStart) {
                continue;
              }
              var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
              interpolate = (startM + charLength / 2 - segmentM) / segmentLength;
              var x = lerp(x1, x2, interpolate);
              var y = lerp(y1, y2, interpolate);
              result.push([x, y, charLength / 2, angle, chars]);
              startM += charLength;
            }
            return result;
          }
          function lineStringLength(flatCoordinates, offset, end, stride) {
            var x1 = flatCoordinates[offset];
            var y1 = flatCoordinates[offset + 1];
            var length = 0;
            for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              x1 = x2;
              y1 = y2;
            }
            return length;
          }
          function linearRingLength(flatCoordinates, offset, end, stride) {
            var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
            var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
            var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
            perimeter += Math.sqrt(dx * dx + dy * dy);
            return perimeter;
          }
          var Executor_tmpExtent = createEmpty();
          var Executor_p1 = [];
          var Executor_p2 = [];
          var Executor_p3 = [];
          var p4 = [];
          function getDeclutterBox(replayImageOrLabelArgs) {
            return replayImageOrLabelArgs[3].declutterBox;
          }
          var rtlRegEx = new RegExp(
            /* eslint-disable prettier/prettier */
            "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
            /* eslint-enable prettier/prettier */
          );
          function horizontalTextAlign(text, align) {
            if ((align === "start" || align === "end") && !rtlRegEx.test(text)) {
              align = align === "start" ? "left" : "right";
            }
            return TEXT_ALIGN[align];
          }
          var Executor_Executor = (
            /** @class */
            function() {
              function Executor(resolution, pixelRatio, overlaps, instructions) {
                this.overlaps = overlaps;
                this.pixelRatio = pixelRatio;
                this.resolution = resolution;
                this.alignFill_;
                this.instructions = instructions.instructions;
                this.coordinates = instructions.coordinates;
                this.coordinateCache_ = {};
                this.renderedTransform_ = create();
                this.hitDetectionInstructions = instructions.hitDetectionInstructions;
                this.pixelCoordinates_ = null;
                this.viewRotation_ = 0;
                this.fillStates = instructions.fillStates || {};
                this.strokeStates = instructions.strokeStates || {};
                this.textStates = instructions.textStates || {};
                this.widths_ = {};
                this.labels_ = {};
              }
              Executor.prototype.createLabel = function(text, textKey, fillKey, strokeKey) {
                var key = text + textKey + fillKey + strokeKey;
                if (this.labels_[key]) {
                  return this.labels_[key];
                }
                var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
                var fillState = fillKey ? this.fillStates[fillKey] : null;
                var textState = this.textStates[textKey];
                var pixelRatio = this.pixelRatio;
                var scale = [
                  textState.scale[0] * pixelRatio,
                  textState.scale[1] * pixelRatio
                ];
                var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
                var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
                var lines = text.split("\n");
                var numLines = lines.length;
                var widths = [];
                var width = measureTextWidths(textState.font, lines, widths);
                var lineHeight = measureTextHeight(textState.font);
                var height = lineHeight * numLines;
                var renderWidth = width + strokeWidth;
                var contextInstructions = [];
                var w = (renderWidth + 2) * scale[0];
                var h = (height + strokeWidth) * scale[1];
                var label = {
                  width: w < 0 ? Math.floor(w) : Math.ceil(w),
                  height: h < 0 ? Math.floor(h) : Math.ceil(h),
                  contextInstructions
                };
                if (scale[0] != 1 || scale[1] != 1) {
                  contextInstructions.push("scale", scale);
                }
                contextInstructions.push("font", textState.font);
                if (strokeKey) {
                  contextInstructions.push("strokeStyle", strokeState.strokeStyle);
                  contextInstructions.push("lineWidth", strokeWidth);
                  contextInstructions.push("lineCap", strokeState.lineCap);
                  contextInstructions.push("lineJoin", strokeState.lineJoin);
                  contextInstructions.push("miterLimit", strokeState.miterLimit);
                  var Context = has[
                    "g"
                    /* WORKER_OFFSCREEN_CANVAS */
                  ] ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
                  if (Context.prototype.setLineDash) {
                    contextInstructions.push("setLineDash", [strokeState.lineDash]);
                    contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
                  }
                }
                if (fillKey) {
                  contextInstructions.push("fillStyle", fillState.fillStyle);
                }
                contextInstructions.push("textBaseline", "middle");
                contextInstructions.push("textAlign", "center");
                var leftRight = 0.5 - align;
                var x = align * renderWidth + leftRight * strokeWidth;
                var i;
                if (strokeKey) {
                  for (i = 0; i < numLines; ++i) {
                    contextInstructions.push("strokeText", [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight
                    ]);
                  }
                }
                if (fillKey) {
                  for (i = 0; i < numLines; ++i) {
                    contextInstructions.push("fillText", [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight
                    ]);
                  }
                }
                this.labels_[key] = label;
                return label;
              };
              Executor.prototype.replayTextBackground_ = function(context, p1, p2, p3, p42, fillInstruction, strokeInstruction) {
                context.beginPath();
                context.moveTo.apply(context, p1);
                context.lineTo.apply(context, p2);
                context.lineTo.apply(context, p3);
                context.lineTo.apply(context, p42);
                context.lineTo.apply(context, p1);
                if (fillInstruction) {
                  this.alignFill_ = /** @type {boolean} */
                  fillInstruction[2];
                  this.fill_(context);
                }
                if (strokeInstruction) {
                  this.setStrokeStyle_(
                    context,
                    /** @type {Array<*>} */
                    strokeInstruction
                  );
                  context.stroke();
                }
              };
              Executor.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
                anchorX *= scale[0];
                anchorY *= scale[1];
                var x = centerX - anchorX;
                var y = centerY - anchorY;
                var w = width + originX > sheetWidth ? sheetWidth - originX : width;
                var h = height + originY > sheetHeight ? sheetHeight - originY : height;
                var boxW = padding[3] + w * scale[0] + padding[1];
                var boxH = padding[0] + h * scale[1] + padding[2];
                var boxX = x - padding[3];
                var boxY = y - padding[0];
                if (fillStroke || rotation !== 0) {
                  Executor_p1[0] = boxX;
                  p4[0] = boxX;
                  Executor_p1[1] = boxY;
                  Executor_p2[1] = boxY;
                  Executor_p2[0] = boxX + boxW;
                  Executor_p3[0] = Executor_p2[0];
                  Executor_p3[1] = boxY + boxH;
                  p4[1] = Executor_p3[1];
                }
                var transform2;
                if (rotation !== 0) {
                  transform2 = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                  apply(transform2, Executor_p1);
                  apply(transform2, Executor_p2);
                  apply(transform2, Executor_p3);
                  apply(transform2, p4);
                  createOrUpdate(Math.min(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.min(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), Math.max(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.max(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), Executor_tmpExtent);
                } else {
                  createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), Executor_tmpExtent);
                }
                if (snapToPixel) {
                  x = Math.round(x);
                  y = Math.round(y);
                }
                return {
                  drawImageX: x,
                  drawImageY: y,
                  drawImageW: w,
                  drawImageH: h,
                  originX,
                  originY,
                  declutterBox: {
                    minX: Executor_tmpExtent[0],
                    minY: Executor_tmpExtent[1],
                    maxX: Executor_tmpExtent[2],
                    maxY: Executor_tmpExtent[3],
                    value: feature
                  },
                  canvasTransform: transform2,
                  scale
                };
              };
              Executor.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
                var fillStroke = !!(fillInstruction || strokeInstruction);
                var box = dimensions.declutterBox;
                var canvas = context.canvas;
                var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
                var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
                if (intersects) {
                  if (fillStroke) {
                    this.replayTextBackground_(
                      context,
                      Executor_p1,
                      Executor_p2,
                      Executor_p3,
                      p4,
                      /** @type {Array<*>} */
                      fillInstruction,
                      /** @type {Array<*>} */
                      strokeInstruction
                    );
                  }
                  drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
                }
                return true;
              };
              Executor.prototype.fill_ = function(context) {
                if (this.alignFill_) {
                  var origin_1 = apply(this.renderedTransform_, [0, 0]);
                  var repeatSize = 512 * this.pixelRatio;
                  context.save();
                  context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
                  context.rotate(this.viewRotation_);
                }
                context.fill();
                if (this.alignFill_) {
                  context.restore();
                }
              };
              Executor.prototype.setStrokeStyle_ = function(context, instruction) {
                context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
                instruction[1];
                context.lineWidth = /** @type {number} */
                instruction[2];
                context.lineCap = /** @type {CanvasLineCap} */
                instruction[3];
                context.lineJoin = /** @type {CanvasLineJoin} */
                instruction[4];
                context.miterLimit = /** @type {number} */
                instruction[5];
                if (context.setLineDash) {
                  context.lineDashOffset = /** @type {number} */
                  instruction[7];
                  context.setLineDash(
                    /** @type {Array<number>} */
                    instruction[6]
                  );
                }
              };
              Executor.prototype.drawLabelWithPointPlacement_ = function(text, textKey, strokeKey, fillKey) {
                var textState = this.textStates[textKey];
                var label = this.createLabel(text, textKey, fillKey, strokeKey);
                var strokeState = this.strokeStates[strokeKey];
                var pixelRatio = this.pixelRatio;
                var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
                var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
                var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
                var width = label.width / pixelRatio - 2 * textState.scale[0];
                var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
                var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
                return {
                  label,
                  anchorX,
                  anchorY
                };
              };
              Executor.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
                var pixelCoordinates;
                if (this.pixelCoordinates_ && Object(ol_array[
                  "b"
                  /* equals */
                ])(transform2, this.renderedTransform_)) {
                  pixelCoordinates = this.pixelCoordinates_;
                } else {
                  if (!this.pixelCoordinates_) {
                    this.pixelCoordinates_ = [];
                  }
                  pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
                  setFromArray(this.renderedTransform_, transform2);
                }
                var i = 0;
                var ii = instructions.length;
                var d = 0;
                var dd;
                var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
                var pendingFill = 0;
                var pendingStroke = 0;
                var lastFillInstruction = null;
                var lastStrokeInstruction = null;
                var coordinateCache = this.coordinateCache_;
                var viewRotation = this.viewRotation_;
                var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
                var state = (
                  /** @type {import("../../render.js").State} */
                  {
                    context,
                    pixelRatio: this.pixelRatio,
                    resolution: this.resolution,
                    rotation: viewRotation
                  }
                );
                var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
                var feature;
                var x, y, currentGeometry;
                while (i < ii) {
                  var instruction = instructions[i];
                  var type = (
                    /** @type {import("./Instruction.js").default} */
                    instruction[0]
                  );
                  switch (type) {
                    case canvas_Instruction.BEGIN_GEOMETRY:
                      feature = /** @type {import("../../Feature.js").FeatureLike} */
                      instruction[1];
                      currentGeometry = instruction[3];
                      if (!feature.getGeometry()) {
                        i = /** @type {number} */
                        instruction[2];
                      } else if (opt_hitExtent !== void 0 && !extent_intersects(opt_hitExtent, currentGeometry.getExtent())) {
                        i = /** @type {number} */
                        instruction[2] + 1;
                      } else {
                        ++i;
                      }
                      break;
                    case canvas_Instruction.BEGIN_PATH:
                      if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                      }
                      if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                      }
                      if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                      }
                      ++i;
                      break;
                    case canvas_Instruction.CIRCLE:
                      d = /** @type {number} */
                      instruction[1];
                      var x1 = pixelCoordinates[d];
                      var y1 = pixelCoordinates[d + 1];
                      var x2 = pixelCoordinates[d + 2];
                      var y2 = pixelCoordinates[d + 3];
                      var dx = x2 - x1;
                      var dy = y2 - y1;
                      var r = Math.sqrt(dx * dx + dy * dy);
                      context.moveTo(x1 + r, y1);
                      context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                      ++i;
                      break;
                    case canvas_Instruction.CLOSE_PATH:
                      context.closePath();
                      ++i;
                      break;
                    case canvas_Instruction.CUSTOM:
                      d = /** @type {number} */
                      instruction[1];
                      dd = instruction[2];
                      var geometry = (
                        /** @type {import("../../geom/SimpleGeometry.js").default} */
                        instruction[3]
                      );
                      var renderer = instruction[4];
                      var fn = instruction.length == 6 ? instruction[5] : void 0;
                      state.geometry = geometry;
                      state.feature = feature;
                      if (!(i in coordinateCache)) {
                        coordinateCache[i] = [];
                      }
                      var coords = coordinateCache[i];
                      if (fn) {
                        fn(pixelCoordinates, d, dd, 2, coords);
                      } else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                      }
                      renderer(coords, state);
                      ++i;
                      break;
                    case canvas_Instruction.DRAW_IMAGE:
                      d = /** @type {number} */
                      instruction[1];
                      dd = /** @type {number} */
                      instruction[2];
                      image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
                      instruction[3];
                      anchorX = /** @type {number} */
                      instruction[4];
                      anchorY = /** @type {number} */
                      instruction[5];
                      var height = (
                        /** @type {number} */
                        instruction[6]
                      );
                      var opacity = (
                        /** @type {number} */
                        instruction[7]
                      );
                      var originX = (
                        /** @type {number} */
                        instruction[8]
                      );
                      var originY = (
                        /** @type {number} */
                        instruction[9]
                      );
                      var rotateWithView = (
                        /** @type {boolean} */
                        instruction[10]
                      );
                      var rotation = (
                        /** @type {number} */
                        instruction[11]
                      );
                      var scale = (
                        /** @type {import("../../size.js").Size} */
                        instruction[12]
                      );
                      var width = (
                        /** @type {number} */
                        instruction[13]
                      );
                      var declutterImageWithText = (
                        /** @type {import("../canvas.js").DeclutterImageWithText} */
                        instruction[14]
                      );
                      if (!image && instruction.length >= 19) {
                        text = /** @type {string} */
                        instruction[18];
                        textKey = /** @type {string} */
                        instruction[19];
                        strokeKey = /** @type {string} */
                        instruction[20];
                        fillKey = /** @type {string} */
                        instruction[21];
                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        var textOffsetX = (
                          /** @type {number} */
                          instruction[22]
                        );
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        var textOffsetY = (
                          /** @type {number} */
                          instruction[23]
                        );
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                      }
                      var geometryWidths = void 0;
                      if (instruction.length > 24) {
                        geometryWidths = /** @type {number} */
                        instruction[24];
                      }
                      var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                      if (instruction.length > 16) {
                        padding = /** @type {Array<number>} */
                        instruction[15];
                        backgroundFill = /** @type {boolean} */
                        instruction[16];
                        backgroundStroke = /** @type {boolean} */
                        instruction[17];
                      } else {
                        padding = defaultPadding;
                        backgroundFill = false;
                        backgroundStroke = false;
                      }
                      if (rotateWithView && viewRotationFromTransform) {
                        rotation += viewRotation;
                      } else if (!rotateWithView && !viewRotationFromTransform) {
                        rotation -= viewRotation;
                      }
                      var widthIndex = 0;
                      for (; d < dd; d += 2) {
                        if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                          continue;
                        }
                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        var args = [
                          context,
                          contextScale,
                          image,
                          dimensions,
                          opacity,
                          backgroundFill ? (
                            /** @type {Array<*>} */
                            lastFillInstruction
                          ) : null,
                          backgroundStroke ? (
                            /** @type {Array<*>} */
                            lastStrokeInstruction
                          ) : null
                        ];
                        var imageArgs = void 0;
                        var imageDeclutterBox = void 0;
                        if (opt_declutterTree && declutterImageWithText) {
                          var index = dd - d;
                          if (!declutterImageWithText[index]) {
                            declutterImageWithText[index] = args;
                            continue;
                          }
                          imageArgs = declutterImageWithText[index];
                          delete declutterImageWithText[index];
                          imageDeclutterBox = getDeclutterBox(imageArgs);
                          if (opt_declutterTree.collides(imageDeclutterBox)) {
                            continue;
                          }
                        }
                        if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                          continue;
                        }
                        if (imageArgs) {
                          if (opt_declutterTree) {
                            opt_declutterTree.insert(imageDeclutterBox);
                          }
                          this.replayImageOrLabel_.apply(this, imageArgs);
                        }
                        if (opt_declutterTree) {
                          opt_declutterTree.insert(dimensions.declutterBox);
                        }
                        this.replayImageOrLabel_.apply(this, args);
                      }
                      ++i;
                      break;
                    case canvas_Instruction.DRAW_CHARS:
                      var begin = (
                        /** @type {number} */
                        instruction[1]
                      );
                      var end = (
                        /** @type {number} */
                        instruction[2]
                      );
                      var baseline = (
                        /** @type {number} */
                        instruction[3]
                      );
                      var overflow = (
                        /** @type {number} */
                        instruction[4]
                      );
                      fillKey = /** @type {string} */
                      instruction[5];
                      var maxAngle = (
                        /** @type {number} */
                        instruction[6]
                      );
                      var measurePixelRatio = (
                        /** @type {number} */
                        instruction[7]
                      );
                      var offsetY = (
                        /** @type {number} */
                        instruction[8]
                      );
                      strokeKey = /** @type {string} */
                      instruction[9];
                      var strokeWidth = (
                        /** @type {number} */
                        instruction[10]
                      );
                      text = /** @type {string} */
                      instruction[11];
                      textKey = /** @type {string} */
                      instruction[12];
                      var pixelRatioScale = [
                        /** @type {number} */
                        instruction[13],
                        /** @type {number} */
                        instruction[13]
                      ];
                      var textState = this.textStates[textKey];
                      var font = textState.font;
                      var textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio
                      ];
                      var cachedWidths = void 0;
                      if (font in this.widths_) {
                        cachedWidths = this.widths_[font];
                      } else {
                        cachedWidths = {};
                        this.widths_[font] = cachedWidths;
                      }
                      var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                      var textLength = Math.abs(textScale[0]) * canvas_measureAndCacheTextWidth(font, text, cachedWidths);
                      if (overflow || textLength <= pathLength) {
                        var textAlign = this.textStates[textKey].textAlign;
                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), canvas_measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                          var replayImageOrLabelArgs = [];
                          var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                          if (strokeKey) {
                            for (c = 0, cc = parts.length; c < cc; ++c) {
                              part = parts[c];
                              chars = /** @type {string} */
                              part[4];
                              label = this.createLabel(chars, textKey, "", strokeKey);
                              anchorX = /** @type {number} */
                              part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                              anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                              var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                              if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                                break drawChars;
                              }
                              replayImageOrLabelArgs.push([
                                context,
                                contextScale,
                                label,
                                dimensions,
                                1,
                                null,
                                null
                              ]);
                            }
                          }
                          if (fillKey) {
                            for (c = 0, cc = parts.length; c < cc; ++c) {
                              part = parts[c];
                              chars = /** @type {string} */
                              part[4];
                              label = this.createLabel(chars, textKey, fillKey, "");
                              anchorX = /** @type {number} */
                              part[2];
                              anchorY = baseline * label.height - offsetY;
                              var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                              if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                                break drawChars;
                              }
                              replayImageOrLabelArgs.push([
                                context,
                                contextScale,
                                label,
                                dimensions,
                                1,
                                null,
                                null
                              ]);
                            }
                          }
                          if (opt_declutterTree) {
                            opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                          }
                          for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                            this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                          }
                        }
                      }
                      ++i;
                      break;
                    case canvas_Instruction.END_GEOMETRY:
                      if (opt_featureCallback !== void 0) {
                        feature = /** @type {import("../../Feature.js").FeatureLike} */
                        instruction[1];
                        var result = opt_featureCallback(feature, currentGeometry);
                        if (result) {
                          return result;
                        }
                      }
                      ++i;
                      break;
                    case canvas_Instruction.FILL:
                      if (batchSize) {
                        pendingFill++;
                      } else {
                        this.fill_(context);
                      }
                      ++i;
                      break;
                    case canvas_Instruction.MOVE_TO_LINE_TO:
                      d = /** @type {number} */
                      instruction[1];
                      dd = /** @type {number} */
                      instruction[2];
                      x = pixelCoordinates[d];
                      y = pixelCoordinates[d + 1];
                      roundX = x + 0.5 | 0;
                      roundY = y + 0.5 | 0;
                      if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                      }
                      for (d += 2; d < dd; d += 2) {
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = x + 0.5 | 0;
                        roundY = y + 0.5 | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                          context.lineTo(x, y);
                          prevX = roundX;
                          prevY = roundY;
                        }
                      }
                      ++i;
                      break;
                    case canvas_Instruction.SET_FILL_STYLE:
                      lastFillInstruction = instruction;
                      this.alignFill_ = instruction[2];
                      if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                          context.stroke();
                          pendingStroke = 0;
                        }
                      }
                      context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
                      instruction[1];
                      ++i;
                      break;
                    case canvas_Instruction.SET_STROKE_STYLE:
                      lastStrokeInstruction = instruction;
                      if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                      }
                      this.setStrokeStyle_(
                        context,
                        /** @type {Array<*>} */
                        instruction
                      );
                      ++i;
                      break;
                    case canvas_Instruction.STROKE:
                      if (batchSize) {
                        pendingStroke++;
                      } else {
                        context.stroke();
                      }
                      ++i;
                      break;
                    default:
                      ++i;
                      break;
                  }
                }
                if (pendingFill) {
                  this.fill_(context);
                }
                if (pendingStroke) {
                  context.stroke();
                }
                return void 0;
              };
              Executor.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {
                this.viewRotation_ = viewRotation;
                this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);
              };
              Executor.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {
                this.viewRotation_ = viewRotation;
                return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
              };
              return Executor;
            }()
          );
          var canvas_Executor = Executor_Executor;
          var ORDER = [
            BuilderType.POLYGON,
            BuilderType.CIRCLE,
            BuilderType.LINE_STRING,
            BuilderType.IMAGE,
            BuilderType.TEXT,
            BuilderType.DEFAULT
          ];
          var ExecutorGroup_ExecutorGroup = (
            /** @class */
            function() {
              function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
                this.maxExtent_ = maxExtent;
                this.overlaps_ = overlaps;
                this.pixelRatio_ = pixelRatio;
                this.resolution_ = resolution;
                this.renderBuffer_ = opt_renderBuffer;
                this.executorsByZIndex_ = {};
                this.hitDetectionContext_ = null;
                this.hitDetectionTransform_ = create();
                this.createExecutors_(allInstructions);
              }
              ExecutorGroup.prototype.clip = function(context, transform2) {
                var flatClipCoords = this.getClipCoords(transform2);
                context.beginPath();
                context.moveTo(flatClipCoords[0], flatClipCoords[1]);
                context.lineTo(flatClipCoords[2], flatClipCoords[3]);
                context.lineTo(flatClipCoords[4], flatClipCoords[5]);
                context.lineTo(flatClipCoords[6], flatClipCoords[7]);
                context.clip();
              };
              ExecutorGroup.prototype.createExecutors_ = function(allInstructions) {
                for (var zIndex in allInstructions) {
                  var executors = this.executorsByZIndex_[zIndex];
                  if (executors === void 0) {
                    executors = {};
                    this.executorsByZIndex_[zIndex] = executors;
                  }
                  var instructionByZindex = allInstructions[zIndex];
                  for (var builderType in instructionByZindex) {
                    var instructions = instructionByZindex[builderType];
                    executors[builderType] = new canvas_Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
                  }
                }
              };
              ExecutorGroup.prototype.hasExecutors = function(executors) {
                for (var zIndex in this.executorsByZIndex_) {
                  var candidates = this.executorsByZIndex_[zIndex];
                  for (var i = 0, ii = executors.length; i < ii; ++i) {
                    if (executors[i] in candidates) {
                      return true;
                    }
                  }
                }
                return false;
              };
              ExecutorGroup.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
                hitTolerance = Math.round(hitTolerance);
                var contextSize = hitTolerance * 2 + 1;
                var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
                var newContext = !this.hitDetectionContext_;
                if (newContext) {
                  this.hitDetectionContext_ = Object(dom[
                    "a"
                    /* createCanvasContext2D */
                  ])(contextSize, contextSize);
                }
                var context = this.hitDetectionContext_;
                if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
                  context.canvas.width = contextSize;
                  context.canvas.height = contextSize;
                } else if (!newContext) {
                  context.clearRect(0, 0, contextSize, contextSize);
                }
                var hitExtent;
                if (this.renderBuffer_ !== void 0) {
                  hitExtent = createEmpty();
                  extendCoordinate(hitExtent, coordinate);
                  extent_buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
                }
                var indexes = getPixelIndexArray(hitTolerance);
                var builderType;
                function featureCallback(feature, geometry) {
                  var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
                  for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
                    if (imageData[indexes[i_1]] > 0) {
                      if (!declutteredFeatures || builderType !== BuilderType.IMAGE && builderType !== BuilderType.TEXT || declutteredFeatures.indexOf(feature) !== -1) {
                        var idx = (indexes[i_1] - 3) / 4;
                        var x = hitTolerance - idx % contextSize;
                        var y = hitTolerance - (idx / contextSize | 0);
                        var result_1 = callback(feature, geometry, x * x + y * y);
                        if (result_1) {
                          return result_1;
                        }
                      }
                      context.clearRect(0, 0, contextSize, contextSize);
                      break;
                    }
                  }
                  return void 0;
                }
                var zs = Object.keys(this.executorsByZIndex_).map(Number);
                zs.sort(ol_array[
                  "i"
                  /* numberSafeCompareFunction */
                ]);
                var i, j, executors, executor, result;
                for (i = zs.length - 1; i >= 0; --i) {
                  var zIndexKey = zs[i].toString();
                  executors = this.executorsByZIndex_[zIndexKey];
                  for (j = ORDER.length - 1; j >= 0; --j) {
                    builderType = ORDER[j];
                    executor = executors[builderType];
                    if (executor !== void 0) {
                      result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);
                      if (result) {
                        return result;
                      }
                    }
                  }
                }
                return void 0;
              };
              ExecutorGroup.prototype.getClipCoords = function(transform2) {
                var maxExtent = this.maxExtent_;
                if (!maxExtent) {
                  return null;
                }
                var minX = maxExtent[0];
                var minY = maxExtent[1];
                var maxX = maxExtent[2];
                var maxY = maxExtent[3];
                var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
                transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
                return flatClipCoords;
              };
              ExecutorGroup.prototype.isEmpty = function() {
                return Object(ol_obj[
                  "d"
                  /* isEmpty */
                ])(this.executorsByZIndex_);
              };
              ExecutorGroup.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
                var zs = Object.keys(this.executorsByZIndex_).map(Number);
                zs.sort(ol_array[
                  "i"
                  /* numberSafeCompareFunction */
                ]);
                if (this.maxExtent_) {
                  context.save();
                  this.clip(context, transform2);
                }
                var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
                var i, ii, j, jj, replays, replay;
                if (opt_declutterTree) {
                  zs.reverse();
                }
                for (i = 0, ii = zs.length; i < ii; ++i) {
                  var zIndexKey = zs[i].toString();
                  replays = this.executorsByZIndex_[zIndexKey];
                  for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                    var builderType = builderTypes[j];
                    replay = replays[builderType];
                    if (replay !== void 0) {
                      replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);
                    }
                  }
                }
                if (this.maxExtent_) {
                  context.restore();
                }
              };
              return ExecutorGroup;
            }()
          );
          var circlePixelIndexArrayCache = {};
          function getPixelIndexArray(radius) {
            if (circlePixelIndexArrayCache[radius] !== void 0) {
              return circlePixelIndexArrayCache[radius];
            }
            var size = radius * 2 + 1;
            var maxDistanceSq = radius * radius;
            var distances = new Array(maxDistanceSq + 1);
            for (var i = 0; i <= radius; ++i) {
              for (var j = 0; j <= radius; ++j) {
                var distanceSq = i * i + j * j;
                if (distanceSq > maxDistanceSq) {
                  break;
                }
                var distance = distances[distanceSq];
                if (!distance) {
                  distance = [];
                  distances[distanceSq] = distance;
                }
                distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
                if (i > 0) {
                  distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
                }
                if (j > 0) {
                  distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
                  if (i > 0) {
                    distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
                  }
                }
              }
            }
            var pixelIndex = [];
            for (var i = 0, ii = distances.length; i < ii; ++i) {
              if (distances[i]) {
                pixelIndex.push.apply(pixelIndex, distances[i]);
              }
            }
            circlePixelIndexArrayCache[radius] = pixelIndex;
            return pixelIndex;
          }
          var canvas_ExecutorGroup = ExecutorGroup_ExecutorGroup;
          var Immediate_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Immediate_CanvasImmediateRenderer = (
            /** @class */
            function(_super) {
              Immediate_extends(CanvasImmediateRenderer, _super);
              function CanvasImmediateRenderer(context, pixelRatio, extent, transform2, viewRotation, opt_squaredTolerance, opt_userTransform) {
                var _this = _super.call(this) || this;
                _this.context_ = context;
                _this.pixelRatio_ = pixelRatio;
                _this.extent_ = extent;
                _this.transform_ = transform2;
                _this.viewRotation_ = viewRotation;
                _this.squaredTolerance_ = opt_squaredTolerance;
                _this.userTransform_ = opt_userTransform;
                _this.contextFillState_ = null;
                _this.contextStrokeState_ = null;
                _this.contextTextState_ = null;
                _this.fillState_ = null;
                _this.strokeState_ = null;
                _this.image_ = null;
                _this.imageAnchorX_ = 0;
                _this.imageAnchorY_ = 0;
                _this.imageHeight_ = 0;
                _this.imageOpacity_ = 0;
                _this.imageOriginX_ = 0;
                _this.imageOriginY_ = 0;
                _this.imageRotateWithView_ = false;
                _this.imageRotation_ = 0;
                _this.imageScale_ = [0, 0];
                _this.imageWidth_ = 0;
                _this.text_ = "";
                _this.textOffsetX_ = 0;
                _this.textOffsetY_ = 0;
                _this.textRotateWithView_ = false;
                _this.textRotation_ = 0;
                _this.textScale_ = [0, 0];
                _this.textFillState_ = null;
                _this.textStrokeState_ = null;
                _this.textState_ = null;
                _this.pixelCoordinates_ = [];
                _this.tmpLocalTransform_ = create();
                return _this;
              }
              CanvasImmediateRenderer.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {
                if (!this.image_) {
                  return;
                }
                var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
                var context = this.context_;
                var localTransform = this.tmpLocalTransform_;
                var alpha = context.globalAlpha;
                if (this.imageOpacity_ != 1) {
                  context.globalAlpha = alpha * this.imageOpacity_;
                }
                var rotation = this.imageRotation_;
                if (this.imageRotateWithView_) {
                  rotation += this.viewRotation_;
                }
                for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
                  var x = pixelCoordinates[i] - this.imageAnchorX_;
                  var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
                  if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                    var centerX = x + this.imageAnchorX_;
                    var centerY = y + this.imageAnchorY_;
                    compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                    context.setTransform.apply(context, localTransform);
                    context.translate(centerX, centerY);
                    context.scale(this.imageScale_[0], this.imageScale_[1]);
                    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                    context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
                  }
                }
                if (this.imageOpacity_ != 1) {
                  context.globalAlpha = alpha;
                }
              };
              CanvasImmediateRenderer.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
                if (!this.textState_ || this.text_ === "") {
                  return;
                }
                if (this.textFillState_) {
                  this.setContextFillState_(this.textFillState_);
                }
                if (this.textStrokeState_) {
                  this.setContextStrokeState_(this.textStrokeState_);
                }
                this.setContextTextState_(this.textState_);
                var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
                var context = this.context_;
                var rotation = this.textRotation_;
                if (this.textRotateWithView_) {
                  rotation += this.viewRotation_;
                }
                for (; offset < end; offset += stride) {
                  var x = pixelCoordinates[offset] + this.textOffsetX_;
                  var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
                  if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                    var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                    context.setTransform.apply(context, localTransform);
                    context.translate(x, y);
                    context.scale(this.textScale_[0], this.textScale_[1]);
                    if (this.textStrokeState_) {
                      context.strokeText(this.text_, 0, 0);
                    }
                    if (this.textFillState_) {
                      context.fillText(this.text_, 0, 0);
                    }
                    context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    if (this.textStrokeState_) {
                      context.strokeText(this.text_, x, y);
                    }
                    if (this.textFillState_) {
                      context.fillText(this.text_, x, y);
                    }
                  }
                }
              };
              CanvasImmediateRenderer.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {
                var context = this.context_;
                var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
                context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
                var length = pixelCoordinates.length;
                if (close) {
                  length -= 2;
                }
                for (var i = 2; i < length; i += 2) {
                  context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
                }
                if (close) {
                  context.closePath();
                }
                return end;
              };
              CanvasImmediateRenderer.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
                }
                return offset;
              };
              CanvasImmediateRenderer.prototype.drawCircle = function(geometry) {
                if (!extent_intersects(this.extent_, geometry.getExtent())) {
                  return;
                }
                if (this.fillState_ || this.strokeState_) {
                  if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                  }
                  if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                  }
                  var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
                  var dx = pixelCoordinates[2] - pixelCoordinates[0];
                  var dy = pixelCoordinates[3] - pixelCoordinates[1];
                  var radius = Math.sqrt(dx * dx + dy * dy);
                  var context = this.context_;
                  context.beginPath();
                  context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
                  if (this.fillState_) {
                    context.fill();
                  }
                  if (this.strokeState_) {
                    context.stroke();
                  }
                }
                if (this.text_ !== "") {
                  this.drawText_(geometry.getCenter(), 0, 2, 2);
                }
              };
              CanvasImmediateRenderer.prototype.setStyle = function(style) {
                this.setFillStrokeStyle(style.getFill(), style.getStroke());
                this.setImageStyle(style.getImage());
                this.setTextStyle(style.getText());
              };
              CanvasImmediateRenderer.prototype.setTransform = function(transform2) {
                this.transform_ = transform2;
              };
              CanvasImmediateRenderer.prototype.drawGeometry = function(geometry) {
                var type = geometry.getType();
                switch (type) {
                  case geom_GeometryType.POINT:
                    this.drawPoint(
                      /** @type {import("../../geom/Point.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.LINE_STRING:
                    this.drawLineString(
                      /** @type {import("../../geom/LineString.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.POLYGON:
                    this.drawPolygon(
                      /** @type {import("../../geom/Polygon.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.MULTI_POINT:
                    this.drawMultiPoint(
                      /** @type {import("../../geom/MultiPoint.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.MULTI_LINE_STRING:
                    this.drawMultiLineString(
                      /** @type {import("../../geom/MultiLineString.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.MULTI_POLYGON:
                    this.drawMultiPolygon(
                      /** @type {import("../../geom/MultiPolygon.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.GEOMETRY_COLLECTION:
                    this.drawGeometryCollection(
                      /** @type {import("../../geom/GeometryCollection.js").default} */
                      geometry
                    );
                    break;
                  case geom_GeometryType.CIRCLE:
                    this.drawCircle(
                      /** @type {import("../../geom/Circle.js").default} */
                      geometry
                    );
                    break;
                  default:
                }
              };
              CanvasImmediateRenderer.prototype.drawFeature = function(feature, style) {
                var geometry = style.getGeometryFunction()(feature);
                if (!geometry || !extent_intersects(this.extent_, geometry.getExtent())) {
                  return;
                }
                this.setStyle(style);
                this.drawGeometry(geometry);
              };
              CanvasImmediateRenderer.prototype.drawGeometryCollection = function(geometry) {
                var geometries = geometry.getGeometriesArray();
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  this.drawGeometry(geometries[i]);
                }
              };
              CanvasImmediateRenderer.prototype.drawPoint = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/Point.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                var flatCoordinates = geometry.getFlatCoordinates();
                var stride = geometry.getStride();
                if (this.image_) {
                  this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
                }
                if (this.text_ !== "") {
                  this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
                }
              };
              CanvasImmediateRenderer.prototype.drawMultiPoint = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/MultiPoint.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                var flatCoordinates = geometry.getFlatCoordinates();
                var stride = geometry.getStride();
                if (this.image_) {
                  this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
                }
                if (this.text_ !== "") {
                  this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
                }
              };
              CanvasImmediateRenderer.prototype.drawLineString = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/LineString.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                if (!extent_intersects(this.extent_, geometry.getExtent())) {
                  return;
                }
                if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
                  var context = this.context_;
                  var flatCoordinates = geometry.getFlatCoordinates();
                  context.beginPath();
                  this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
                  context.stroke();
                }
                if (this.text_ !== "") {
                  var flatMidpoint = geometry.getFlatMidpoint();
                  this.drawText_(flatMidpoint, 0, 2, 2);
                }
              };
              CanvasImmediateRenderer.prototype.drawMultiLineString = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/MultiLineString.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                var geometryExtent = geometry.getExtent();
                if (!extent_intersects(this.extent_, geometryExtent)) {
                  return;
                }
                if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
                  var context = this.context_;
                  var flatCoordinates = geometry.getFlatCoordinates();
                  var offset = 0;
                  var ends = (
                    /** @type {Array<number>} */
                    geometry.getEnds()
                  );
                  var stride = geometry.getStride();
                  context.beginPath();
                  for (var i = 0, ii = ends.length; i < ii; ++i) {
                    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
                  }
                  context.stroke();
                }
                if (this.text_ !== "") {
                  var flatMidpoints = geometry.getFlatMidpoints();
                  this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
                }
              };
              CanvasImmediateRenderer.prototype.drawPolygon = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/Polygon.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                if (!extent_intersects(this.extent_, geometry.getExtent())) {
                  return;
                }
                if (this.strokeState_ || this.fillState_) {
                  if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                  }
                  if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                  }
                  var context = this.context_;
                  context.beginPath();
                  this.drawRings_(
                    geometry.getOrientedFlatCoordinates(),
                    0,
                    /** @type {Array<number>} */
                    geometry.getEnds(),
                    geometry.getStride()
                  );
                  if (this.fillState_) {
                    context.fill();
                  }
                  if (this.strokeState_) {
                    context.stroke();
                  }
                }
                if (this.text_ !== "") {
                  var flatInteriorPoint = geometry.getFlatInteriorPoint();
                  this.drawText_(flatInteriorPoint, 0, 2, 2);
                }
              };
              CanvasImmediateRenderer.prototype.drawMultiPolygon = function(geometry) {
                if (this.squaredTolerance_) {
                  geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
                  geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
                }
                if (!extent_intersects(this.extent_, geometry.getExtent())) {
                  return;
                }
                if (this.strokeState_ || this.fillState_) {
                  if (this.fillState_) {
                    this.setContextFillState_(this.fillState_);
                  }
                  if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                  }
                  var context = this.context_;
                  var flatCoordinates = geometry.getOrientedFlatCoordinates();
                  var offset = 0;
                  var endss = geometry.getEndss();
                  var stride = geometry.getStride();
                  context.beginPath();
                  for (var i = 0, ii = endss.length; i < ii; ++i) {
                    var ends = endss[i];
                    offset = this.drawRings_(flatCoordinates, offset, ends, stride);
                  }
                  if (this.fillState_) {
                    context.fill();
                  }
                  if (this.strokeState_) {
                    context.stroke();
                  }
                }
                if (this.text_ !== "") {
                  var flatInteriorPoints = geometry.getFlatInteriorPoints();
                  this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
                }
              };
              CanvasImmediateRenderer.prototype.setContextFillState_ = function(fillState) {
                var context = this.context_;
                var contextFillState = this.contextFillState_;
                if (!contextFillState) {
                  context.fillStyle = fillState.fillStyle;
                  this.contextFillState_ = {
                    fillStyle: fillState.fillStyle
                  };
                } else {
                  if (contextFillState.fillStyle != fillState.fillStyle) {
                    contextFillState.fillStyle = fillState.fillStyle;
                    context.fillStyle = fillState.fillStyle;
                  }
                }
              };
              CanvasImmediateRenderer.prototype.setContextStrokeState_ = function(strokeState) {
                var context = this.context_;
                var contextStrokeState = this.contextStrokeState_;
                if (!contextStrokeState) {
                  context.lineCap = strokeState.lineCap;
                  if (context.setLineDash) {
                    context.setLineDash(strokeState.lineDash);
                    context.lineDashOffset = strokeState.lineDashOffset;
                  }
                  context.lineJoin = strokeState.lineJoin;
                  context.lineWidth = strokeState.lineWidth;
                  context.miterLimit = strokeState.miterLimit;
                  context.strokeStyle = strokeState.strokeStyle;
                  this.contextStrokeState_ = {
                    lineCap: strokeState.lineCap,
                    lineDash: strokeState.lineDash,
                    lineDashOffset: strokeState.lineDashOffset,
                    lineJoin: strokeState.lineJoin,
                    lineWidth: strokeState.lineWidth,
                    miterLimit: strokeState.miterLimit,
                    strokeStyle: strokeState.strokeStyle
                  };
                } else {
                  if (contextStrokeState.lineCap != strokeState.lineCap) {
                    contextStrokeState.lineCap = strokeState.lineCap;
                    context.lineCap = strokeState.lineCap;
                  }
                  if (context.setLineDash) {
                    if (!Object(ol_array[
                      "b"
                      /* equals */
                    ])(contextStrokeState.lineDash, strokeState.lineDash)) {
                      context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
                    }
                    if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                      contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                      context.lineDashOffset = strokeState.lineDashOffset;
                    }
                  }
                  if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                    contextStrokeState.lineJoin = strokeState.lineJoin;
                    context.lineJoin = strokeState.lineJoin;
                  }
                  if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                    contextStrokeState.lineWidth = strokeState.lineWidth;
                    context.lineWidth = strokeState.lineWidth;
                  }
                  if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                    contextStrokeState.miterLimit = strokeState.miterLimit;
                    context.miterLimit = strokeState.miterLimit;
                  }
                  if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                    contextStrokeState.strokeStyle = strokeState.strokeStyle;
                    context.strokeStyle = strokeState.strokeStyle;
                  }
                }
              };
              CanvasImmediateRenderer.prototype.setContextTextState_ = function(textState) {
                var context = this.context_;
                var contextTextState = this.contextTextState_;
                var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
                if (!contextTextState) {
                  context.font = textState.font;
                  context.textAlign = /** @type {CanvasTextAlign} */
                  textAlign;
                  context.textBaseline = /** @type {CanvasTextBaseline} */
                  textState.textBaseline;
                  this.contextTextState_ = {
                    font: textState.font,
                    textAlign,
                    textBaseline: textState.textBaseline
                  };
                } else {
                  if (contextTextState.font != textState.font) {
                    contextTextState.font = textState.font;
                    context.font = textState.font;
                  }
                  if (contextTextState.textAlign != textAlign) {
                    contextTextState.textAlign = /** @type {CanvasTextAlign} */
                    textAlign;
                    context.textAlign = /** @type {CanvasTextAlign} */
                    textAlign;
                  }
                  if (contextTextState.textBaseline != textState.textBaseline) {
                    contextTextState.textBaseline = /** @type {CanvasTextBaseline} */
                    textState.textBaseline;
                    context.textBaseline = /** @type {CanvasTextBaseline} */
                    textState.textBaseline;
                  }
                }
              };
              CanvasImmediateRenderer.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
                var _this = this;
                if (!fillStyle) {
                  this.fillState_ = null;
                } else {
                  var fillStyleColor = fillStyle.getColor();
                  this.fillState_ = {
                    fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
                  };
                }
                if (!strokeStyle) {
                  this.strokeState_ = null;
                } else {
                  var strokeStyleColor = strokeStyle.getColor();
                  var strokeStyleLineCap = strokeStyle.getLineCap();
                  var strokeStyleLineDash = strokeStyle.getLineDash();
                  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
                  var strokeStyleLineJoin = strokeStyle.getLineJoin();
                  var strokeStyleWidth = strokeStyle.getWidth();
                  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
                  var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
                  this.strokeState_ = {
                    lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
                    lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n) {
                      return n * _this.pixelRatio_;
                    }),
                    lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
                    lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
                    lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
                    miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
                    strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
                  };
                }
              };
              CanvasImmediateRenderer.prototype.setImageStyle = function(imageStyle) {
                var imageSize;
                if (!imageStyle || !(imageSize = imageStyle.getSize())) {
                  this.image_ = null;
                  return;
                }
                var imageAnchor = imageStyle.getAnchor();
                var imageOrigin = imageStyle.getOrigin();
                this.image_ = imageStyle.getImage(this.pixelRatio_);
                this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
                this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
                this.imageHeight_ = imageSize[1] * this.pixelRatio_;
                this.imageOpacity_ = imageStyle.getOpacity();
                this.imageOriginX_ = imageOrigin[0];
                this.imageOriginY_ = imageOrigin[1];
                this.imageRotateWithView_ = imageStyle.getRotateWithView();
                this.imageRotation_ = imageStyle.getRotation();
                this.imageScale_ = imageStyle.getScaleArray();
                this.imageWidth_ = imageSize[0] * this.pixelRatio_;
              };
              CanvasImmediateRenderer.prototype.setTextStyle = function(textStyle) {
                if (!textStyle) {
                  this.text_ = "";
                } else {
                  var textFillStyle = textStyle.getFill();
                  if (!textFillStyle) {
                    this.textFillState_ = null;
                  } else {
                    var textFillStyleColor = textFillStyle.getColor();
                    this.textFillState_ = {
                      fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
                    };
                  }
                  var textStrokeStyle = textStyle.getStroke();
                  if (!textStrokeStyle) {
                    this.textStrokeState_ = null;
                  } else {
                    var textStrokeStyleColor = textStrokeStyle.getColor();
                    var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                    var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                    var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                    var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                    var textStrokeStyleWidth = textStrokeStyle.getWidth();
                    var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                    this.textStrokeState_ = {
                      lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
                      lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
                      lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
                      lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
                      lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
                      miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
                      strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
                    };
                  }
                  var textFont = textStyle.getFont();
                  var textOffsetX = textStyle.getOffsetX();
                  var textOffsetY = textStyle.getOffsetY();
                  var textRotateWithView = textStyle.getRotateWithView();
                  var textRotation = textStyle.getRotation();
                  var textScale = textStyle.getScaleArray();
                  var textText = textStyle.getText();
                  var textTextAlign = textStyle.getTextAlign();
                  var textTextBaseline = textStyle.getTextBaseline();
                  this.textState_ = {
                    font: textFont !== void 0 ? textFont : defaultFont,
                    textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
                    textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
                  };
                  this.text_ = textText !== void 0 ? textText : "";
                  this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
                  this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
                  this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
                  this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
                  this.textScale_ = [
                    this.pixelRatio_ * textScale[0],
                    this.pixelRatio_ * textScale[1]
                  ];
                }
              };
              return CanvasImmediateRenderer;
            }(render_VectorContext)
          );
          var Immediate = Immediate_CanvasImmediateRenderer;
          var IconAnchorUnits = {
            /**
             * Anchor is a fraction
             * @api
             */
            FRACTION: "fraction",
            /**
             * Anchor is in pixels
             * @api
             */
            PIXELS: "pixels"
          };
          var IconOrigin = {
            /**
             * Origin is at bottom left
             * @api
             */
            BOTTOM_LEFT: "bottom-left",
            /**
             * Origin is at bottom right
             * @api
             */
            BOTTOM_RIGHT: "bottom-right",
            /**
             * Origin is at top left
             * @api
             */
            TOP_LEFT: "top-left",
            /**
             * Origin is at top right
             * @api
             */
            TOP_RIGHT: "top-right"
          };
          var ImageBase_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageBase_ImageBase = (
            /** @class */
            function(_super) {
              ImageBase_extends(ImageBase, _super);
              function ImageBase(extent, resolution, pixelRatio, state) {
                var _this = _super.call(this) || this;
                _this.extent = extent;
                _this.pixelRatio_ = pixelRatio;
                _this.resolution = resolution;
                _this.state = state;
                return _this;
              }
              ImageBase.prototype.changed = function() {
                this.dispatchEvent(EventType[
                  "a"
                  /* default */
                ].CHANGE);
              };
              ImageBase.prototype.getExtent = function() {
                return this.extent;
              };
              ImageBase.prototype.getImage = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageBase.prototype.getPixelRatio = function() {
                return this.pixelRatio_;
              };
              ImageBase.prototype.getResolution = function() {
                return (
                  /** @type {number} */
                  this.resolution
                );
              };
              ImageBase.prototype.getState = function() {
                return this.state;
              };
              ImageBase.prototype.load = function() {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              return ImageBase;
            }(Target[
              "a"
              /* default */
            ])
          );
          var ol_ImageBase = ImageBase_ImageBase;
          var ol_Image_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Image_ImageWrapper = (
            /** @class */
            function(_super) {
              ol_Image_extends(ImageWrapper, _super);
              function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
                var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
                _this.src_ = src;
                _this.image_ = new Image();
                if (crossOrigin !== null) {
                  _this.image_.crossOrigin = crossOrigin;
                }
                _this.unlisten_ = null;
                _this.state = ImageState.IDLE;
                _this.imageLoadFunction_ = imageLoadFunction;
                return _this;
              }
              ImageWrapper.prototype.getImage = function() {
                return this.image_;
              };
              ImageWrapper.prototype.handleImageError_ = function() {
                this.state = ImageState.ERROR;
                this.unlistenImage_();
                this.changed();
              };
              ImageWrapper.prototype.handleImageLoad_ = function() {
                if (this.resolution === void 0) {
                  this.resolution = getHeight(this.extent) / this.image_.height;
                }
                this.state = ImageState.LOADED;
                this.unlistenImage_();
                this.changed();
              };
              ImageWrapper.prototype.load = function() {
                if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
                  this.state = ImageState.LOADING;
                  this.changed();
                  this.imageLoadFunction_(this, this.src_);
                  this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
                }
              };
              ImageWrapper.prototype.setImage = function(image) {
                this.image_ = image;
                this.resolution = getHeight(this.extent) / this.image_.height;
              };
              ImageWrapper.prototype.unlistenImage_ = function() {
                if (this.unlisten_) {
                  this.unlisten_();
                  this.unlisten_ = null;
                }
              };
              return ImageWrapper;
            }(ol_ImageBase)
          );
          function listenImage(image, loadHandler, errorHandler) {
            var img = (
              /** @type {HTMLImageElement} */
              image
            );
            if (img.src && has[
              "c"
              /* IMAGE_DECODE */
            ]) {
              var promise = img.decode();
              var listening_1 = true;
              var unlisten = function() {
                listening_1 = false;
              };
              promise.then(function() {
                if (listening_1) {
                  loadHandler();
                }
              }).catch(function(error) {
                if (listening_1) {
                  if (error.name === "EncodingError" && error.message === "Invalid image type.") {
                    loadHandler();
                  } else {
                    errorHandler();
                  }
                }
              });
              return unlisten;
            }
            var listenerKeys = [
              Object(events[
                "b"
                /* listenOnce */
              ])(img, EventType[
                "a"
                /* default */
              ].LOAD, loadHandler),
              Object(events[
                "b"
                /* listenOnce */
              ])(img, EventType[
                "a"
                /* default */
              ].ERROR, errorHandler)
            ];
            return function unlisten2() {
              listenerKeys.forEach(events[
                "c"
                /* unlistenByKey */
              ]);
            };
          }
          var ol_Image = Image_ImageWrapper;
          var IconImage_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var taintedTestContext = null;
          var IconImage_IconImage = (
            /** @class */
            function(_super) {
              IconImage_extends(IconImage, _super);
              function IconImage(image, src, size, crossOrigin, imageState, color) {
                var _this = _super.call(this) || this;
                _this.hitDetectionImage_ = null;
                _this.image_ = !image ? new Image() : image;
                if (crossOrigin !== null) {
                  _this.image_.crossOrigin = crossOrigin;
                }
                _this.canvas_ = {};
                _this.color_ = color;
                _this.unlisten_ = null;
                _this.imageState_ = imageState;
                _this.size_ = size;
                _this.src_ = src;
                _this.tainted_;
                return _this;
              }
              IconImage.prototype.isTainted_ = function() {
                if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
                  if (!taintedTestContext) {
                    taintedTestContext = Object(dom[
                      "a"
                      /* createCanvasContext2D */
                    ])(1, 1);
                  }
                  taintedTestContext.drawImage(this.image_, 0, 0);
                  try {
                    taintedTestContext.getImageData(0, 0, 1, 1);
                    this.tainted_ = false;
                  } catch (e) {
                    taintedTestContext = null;
                    this.tainted_ = true;
                  }
                }
                return this.tainted_ === true;
              };
              IconImage.prototype.dispatchChangeEvent_ = function() {
                this.dispatchEvent(EventType[
                  "a"
                  /* default */
                ].CHANGE);
              };
              IconImage.prototype.handleImageError_ = function() {
                this.imageState_ = ImageState.ERROR;
                this.unlistenImage_();
                this.dispatchChangeEvent_();
              };
              IconImage.prototype.handleImageLoad_ = function() {
                this.imageState_ = ImageState.LOADED;
                if (this.size_) {
                  this.image_.width = this.size_[0];
                  this.image_.height = this.size_[1];
                } else {
                  this.size_ = [this.image_.width, this.image_.height];
                }
                this.unlistenImage_();
                this.dispatchChangeEvent_();
              };
              IconImage.prototype.getImage = function(pixelRatio) {
                this.replaceColor_(pixelRatio);
                return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
              };
              IconImage.prototype.getPixelRatio = function(pixelRatio) {
                this.replaceColor_(pixelRatio);
                return this.canvas_[pixelRatio] ? pixelRatio : 1;
              };
              IconImage.prototype.getImageState = function() {
                return this.imageState_;
              };
              IconImage.prototype.getHitDetectionImage = function() {
                if (!this.hitDetectionImage_) {
                  if (this.isTainted_()) {
                    var width = this.size_[0];
                    var height = this.size_[1];
                    var context = Object(dom[
                      "a"
                      /* createCanvasContext2D */
                    ])(width, height);
                    context.fillRect(0, 0, width, height);
                    this.hitDetectionImage_ = context.canvas;
                  } else {
                    this.hitDetectionImage_ = this.image_;
                  }
                }
                return this.hitDetectionImage_;
              };
              IconImage.prototype.getSize = function() {
                return this.size_;
              };
              IconImage.prototype.getSrc = function() {
                return this.src_;
              };
              IconImage.prototype.load = function() {
                if (this.imageState_ == ImageState.IDLE) {
                  this.imageState_ = ImageState.LOADING;
                  try {
                    this.image_.src = this.src_;
                  } catch (e) {
                    this.handleImageError_();
                  }
                  this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
                }
              };
              IconImage.prototype.replaceColor_ = function(pixelRatio) {
                if (!this.color_ || this.canvas_[pixelRatio]) {
                  return;
                }
                var canvas = document.createElement("canvas");
                this.canvas_[pixelRatio] = canvas;
                canvas.width = Math.ceil(this.image_.width * pixelRatio);
                canvas.height = Math.ceil(this.image_.height * pixelRatio);
                var ctx = canvas.getContext("2d");
                ctx.scale(pixelRatio, pixelRatio);
                ctx.drawImage(this.image_, 0, 0);
                ctx.globalCompositeOperation = "multiply";
                if (ctx.globalCompositeOperation === "multiply" || this.isTainted_()) {
                  ctx.fillStyle = asString(this.color_);
                  ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
                  ctx.globalCompositeOperation = "destination-in";
                  ctx.drawImage(this.image_, 0, 0);
                } else {
                  var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                  var data = imgData.data;
                  var r = this.color_[0] / 255;
                  var g = this.color_[1] / 255;
                  var b = this.color_[2] / 255;
                  var a = this.color_[3];
                  for (var i = 0, ii = data.length; i < ii; i += 4) {
                    data[i] *= r;
                    data[i + 1] *= g;
                    data[i + 2] *= b;
                    data[i + 3] *= a;
                  }
                  ctx.putImageData(imgData, 0, 0);
                }
              };
              IconImage.prototype.unlistenImage_ = function() {
                if (this.unlisten_) {
                  this.unlisten_();
                  this.unlisten_ = null;
                }
              };
              return IconImage;
            }(Target[
              "a"
              /* default */
            ])
          );
          function IconImage_get(image, src, size, crossOrigin, imageState, color) {
            var iconImage = shared.get(src, crossOrigin, color);
            if (!iconImage) {
              iconImage = new IconImage_IconImage(image, src, size, crossOrigin, imageState, color);
              shared.set(src, crossOrigin, color, iconImage);
            }
            return iconImage;
          }
          var style_IconImage = IconImage_IconImage;
          var Icon_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Icon_Icon = (
            /** @class */
            function(_super) {
              Icon_extends(Icon, _super);
              function Icon(opt_options) {
                var _this = this;
                var options = opt_options || {};
                var opacity = options.opacity !== void 0 ? options.opacity : 1;
                var rotation = options.rotation !== void 0 ? options.rotation : 0;
                var scale = options.scale !== void 0 ? options.scale : 1;
                var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
                _this = _super.call(this, {
                  opacity,
                  rotation,
                  scale,
                  displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
                  rotateWithView
                }) || this;
                _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
                _this.normalizedAnchor_ = null;
                _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;
                _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;
                _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;
                _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
                var image = options.img !== void 0 ? options.img : null;
                var imgSize = options.imgSize !== void 0 ? options.imgSize : null;
                var src = options.src;
                assert2(!(src !== void 0 && image), 4);
                assert2(!image || image && imgSize, 5);
                if ((src === void 0 || src.length === 0) && image) {
                  src = /** @type {HTMLImageElement} */
                  image.src || Object(util[
                    "c"
                    /* getUid */
                  ])(image);
                }
                assert2(src !== void 0 && src.length > 0, 6);
                var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
                _this.color_ = options.color !== void 0 ? asArray(options.color) : null;
                _this.iconImage_ = IconImage_get(
                  image,
                  /** @type {string} */
                  src,
                  imgSize,
                  _this.crossOrigin_,
                  imageState,
                  _this.color_
                );
                _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
                _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;
                _this.origin_ = null;
                _this.size_ = options.size !== void 0 ? options.size : null;
                return _this;
              }
              Icon.prototype.clone = function() {
                var scale = this.getScale();
                return new Icon({
                  anchor: this.anchor_.slice(),
                  anchorOrigin: this.anchorOrigin_,
                  anchorXUnits: this.anchorXUnits_,
                  anchorYUnits: this.anchorYUnits_,
                  crossOrigin: this.crossOrigin_,
                  color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
                  src: this.getSrc(),
                  offset: this.offset_.slice(),
                  offsetOrigin: this.offsetOrigin_,
                  size: this.size_ !== null ? this.size_.slice() : void 0,
                  opacity: this.getOpacity(),
                  scale: Array.isArray(scale) ? scale.slice() : scale,
                  rotation: this.getRotation(),
                  rotateWithView: this.getRotateWithView()
                });
              };
              Icon.prototype.getAnchor = function() {
                if (this.normalizedAnchor_) {
                  return this.normalizedAnchor_;
                }
                var anchor = this.anchor_;
                var size = this.getSize();
                if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                  if (!size) {
                    return null;
                  }
                  anchor = this.anchor_.slice();
                  if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                    anchor[0] *= size[0];
                  }
                  if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                    anchor[1] *= size[1];
                  }
                }
                if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
                  if (!size) {
                    return null;
                  }
                  if (anchor === this.anchor_) {
                    anchor = this.anchor_.slice();
                  }
                  if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    anchor[0] = -anchor[0] + size[0];
                  }
                  if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    anchor[1] = -anchor[1] + size[1];
                  }
                }
                var displacement = this.getDisplacement();
                anchor[0] -= displacement[0];
                anchor[1] += displacement[1];
                this.normalizedAnchor_ = anchor;
                return this.normalizedAnchor_;
              };
              Icon.prototype.setAnchor = function(anchor) {
                this.anchor_ = anchor;
                this.normalizedAnchor_ = null;
              };
              Icon.prototype.getColor = function() {
                return this.color_;
              };
              Icon.prototype.getImage = function(pixelRatio) {
                return this.iconImage_.getImage(pixelRatio);
              };
              Icon.prototype.getPixelRatio = function(pixelRatio) {
                return this.iconImage_.getPixelRatio(pixelRatio);
              };
              Icon.prototype.getImageSize = function() {
                return this.iconImage_.getSize();
              };
              Icon.prototype.getImageState = function() {
                return this.iconImage_.getImageState();
              };
              Icon.prototype.getHitDetectionImage = function() {
                return this.iconImage_.getHitDetectionImage();
              };
              Icon.prototype.getOrigin = function() {
                if (this.origin_) {
                  return this.origin_;
                }
                var offset = this.offset_;
                if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
                  var size = this.getSize();
                  var iconImageSize = this.iconImage_.getSize();
                  if (!size || !iconImageSize) {
                    return null;
                  }
                  offset = offset.slice();
                  if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    offset[0] = iconImageSize[0] - size[0] - offset[0];
                  }
                  if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                    offset[1] = iconImageSize[1] - size[1] - offset[1];
                  }
                }
                this.origin_ = offset;
                return this.origin_;
              };
              Icon.prototype.getSrc = function() {
                return this.iconImage_.getSrc();
              };
              Icon.prototype.getSize = function() {
                return !this.size_ ? this.iconImage_.getSize() : this.size_;
              };
              Icon.prototype.listenImageChange = function(listener) {
                this.iconImage_.addEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, listener);
              };
              Icon.prototype.load = function() {
                this.iconImage_.load();
              };
              Icon.prototype.unlistenImageChange = function(listener) {
                this.iconImage_.removeEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, listener);
              };
              return Icon;
            }(style_Image)
          );
          var style_Icon = Icon_Icon;
          var HIT_DETECT_RESOLUTION = 0.5;
          function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
            var width = size[0] * HIT_DETECT_RESOLUTION;
            var height = size[1] * HIT_DETECT_RESOLUTION;
            var context = Object(dom[
              "a"
              /* createCanvasContext2D */
            ])(width, height);
            context.imageSmoothingEnabled = false;
            var canvas = context.canvas;
            var renderer = new Immediate(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
            var featureCount = features.length;
            var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
            var featuresByZIndex = {};
            for (var i = 1; i <= featureCount; ++i) {
              var feature = features[i - 1];
              var featureStyleFunction = feature.getStyleFunction() || styleFunction;
              if (!styleFunction) {
                continue;
              }
              var styles = featureStyleFunction(feature, resolution);
              if (!styles) {
                continue;
              }
              if (!Array.isArray(styles)) {
                styles = [styles];
              }
              var index = i * indexFactor;
              var color = "#" + ("000000" + index.toString(16)).slice(-6);
              for (var j = 0, jj = styles.length; j < jj; ++j) {
                var originalStyle = styles[j];
                var geometry = originalStyle.getGeometryFunction()(feature);
                if (!geometry || !extent_intersects(extent, geometry.getExtent())) {
                  continue;
                }
                var style = originalStyle.clone();
                var fill = style.getFill();
                if (fill) {
                  fill.setColor(color);
                }
                var stroke = style.getStroke();
                if (stroke) {
                  stroke.setColor(color);
                  stroke.setLineDash(null);
                }
                style.setText(void 0);
                var image = originalStyle.getImage();
                if (image && image.getOpacity() !== 0) {
                  var imgSize = image.getImageSize();
                  if (!imgSize) {
                    continue;
                  }
                  var imgContext = Object(dom[
                    "a"
                    /* createCanvasContext2D */
                  ])(imgSize[0], imgSize[1], void 0, { alpha: false });
                  var img = imgContext.canvas;
                  imgContext.fillStyle = color;
                  imgContext.fillRect(0, 0, img.width, img.height);
                  style.setImage(new style_Icon({
                    img,
                    imgSize,
                    anchor: image.getAnchor(),
                    anchorXUnits: IconAnchorUnits.PIXELS,
                    anchorYUnits: IconAnchorUnits.PIXELS,
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView()
                  }));
                }
                var zIndex = style.getZIndex() || 0;
                var byGeometryType = featuresByZIndex[zIndex];
                if (!byGeometryType) {
                  byGeometryType = {};
                  featuresByZIndex[zIndex] = byGeometryType;
                  byGeometryType[geom_GeometryType.POLYGON] = [];
                  byGeometryType[geom_GeometryType.CIRCLE] = [];
                  byGeometryType[geom_GeometryType.LINE_STRING] = [];
                  byGeometryType[geom_GeometryType.POINT] = [];
                }
                byGeometryType[geometry.getType().replace("Multi", "")].push(geometry, style);
              }
            }
            var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ol_array[
              "i"
              /* numberSafeCompareFunction */
            ]);
            for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
              var byGeometryType = featuresByZIndex[zIndexKeys[i]];
              for (var type in byGeometryType) {
                var geomAndStyle = byGeometryType[type];
                for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                  renderer.setStyle(geomAndStyle[j + 1]);
                  for (var k = 0, kk = transforms.length; k < kk; ++k) {
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j]);
                  }
                }
              }
            }
            return context.getImageData(0, 0, canvas.width, canvas.height);
          }
          function hitDetect(pixel, features, imageData) {
            var resultFeatures = [];
            if (imageData) {
              var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
              var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
              var index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
              var r = imageData.data[index];
              var g = imageData.data[index + 1];
              var b = imageData.data[index + 2];
              var i = b + 256 * (g + 256 * r);
              var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
              if (i && i % indexFactor === 0) {
                resultFeatures.push(features[i / indexFactor - 1]);
              }
            }
            return resultFeatures;
          }
          var SIMPLIFY_TOLERANCE = 0.5;
          var GEOMETRY_RENDERERS = {
            "Point": renderPointGeometry,
            "LineString": renderLineStringGeometry,
            "Polygon": renderPolygonGeometry,
            "MultiPoint": renderMultiPointGeometry,
            "MultiLineString": renderMultiLineStringGeometry,
            "MultiPolygon": renderMultiPolygonGeometry,
            "GeometryCollection": renderGeometryCollectionGeometry,
            "Circle": renderCircleGeometry
          };
          function defaultOrder(feature1, feature2) {
            return parseInt(Object(util[
              "c"
              /* getUid */
            ])(feature1), 10) - parseInt(Object(util[
              "c"
              /* getUid */
            ])(feature2), 10);
          }
          function getSquaredTolerance(resolution, pixelRatio) {
            var tolerance = getTolerance(resolution, pixelRatio);
            return tolerance * tolerance;
          }
          function getTolerance(resolution, pixelRatio) {
            return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
          }
          function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var fillStyle = style.getFill();
            var strokeStyle = style.getStroke();
            if (fillStyle || strokeStyle) {
              var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);
              circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
              circleReplay.drawCircle(geometry, feature);
            }
            var textStyle = style.getText();
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
            var loading = false;
            var imageStyle = style.getImage();
            if (imageStyle) {
              var imageState = imageStyle.getImageState();
              if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
                imageStyle.unlistenImageChange(listener);
              } else {
                if (imageState == ImageState.IDLE) {
                  imageStyle.load();
                }
                imageState = imageStyle.getImageState();
                imageStyle.listenImageChange(listener);
                loading = true;
              }
            }
            renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
            return loading;
          }
          function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
            var geometry = style.getGeometryFunction()(feature);
            if (!geometry) {
              return;
            }
            var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
            var renderer = style.getRenderer();
            if (renderer) {
              renderGeometry(replayGroup, simplifiedGeometry, style, feature);
            } else {
              var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
              geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
            }
          }
          function renderGeometry(replayGroup, geometry, style, feature) {
            if (geometry.getType() == geom_GeometryType.GEOMETRY_COLLECTION) {
              var geometries = (
                /** @type {import("../geom/GeometryCollection.js").default} */
                geometry.getGeometries()
              );
              for (var i = 0, ii = geometries.length; i < ii; ++i) {
                renderGeometry(replayGroup, geometries[i], style, feature);
              }
              return;
            }
            var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);
            replay.drawCustom(
              /** @type {import("../geom/SimpleGeometry.js").default} */
              geometry,
              feature,
              style.getRenderer()
            );
          }
          function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var geometries = geometry.getGeometriesArray();
            var i, ii;
            for (i = 0, ii = geometries.length; i < ii; ++i) {
              var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
              geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
            }
          }
          function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var strokeStyle = style.getStroke();
            if (strokeStyle) {
              var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
              lineStringReplay.setFillStrokeStyle(null, strokeStyle);
              lineStringReplay.drawLineString(geometry, feature);
            }
            var textStyle = style.getText();
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var strokeStyle = style.getStroke();
            if (strokeStyle) {
              var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
              lineStringReplay.setFillStrokeStyle(null, strokeStyle);
              lineStringReplay.drawMultiLineString(geometry, feature);
            }
            var textStyle = style.getText();
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var fillStyle = style.getFill();
            var strokeStyle = style.getStroke();
            if (strokeStyle || fillStyle) {
              var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
              polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
              polygonReplay.drawMultiPolygon(geometry, feature);
            }
            var textStyle = style.getText();
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var imageStyle = style.getImage();
            var textStyle = style.getText();
            var declutterImageWithText;
            if (opt_declutterBuilderGroup) {
              builderGroup = opt_declutterBuilderGroup;
              declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
            }
            if (imageStyle) {
              if (imageStyle.getImageState() != ImageState.LOADED) {
                return;
              }
              var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
              imageReplay.setImageStyle(imageStyle, declutterImageWithText);
              imageReplay.drawPoint(geometry, feature);
            }
            if (textStyle && textStyle.getText()) {
              var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle, declutterImageWithText);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var imageStyle = style.getImage();
            var textStyle = style.getText();
            var declutterImageWithText;
            if (opt_declutterBuilderGroup) {
              builderGroup = opt_declutterBuilderGroup;
              declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
            }
            if (imageStyle) {
              if (imageStyle.getImageState() != ImageState.LOADED) {
                return;
              }
              var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
              imageReplay.setImageStyle(imageStyle, declutterImageWithText);
              imageReplay.drawMultiPoint(geometry, feature);
            }
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle, declutterImageWithText);
              textReplay.drawText(geometry, feature);
            }
          }
          function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
            var fillStyle = style.getFill();
            var strokeStyle = style.getStroke();
            if (fillStyle || strokeStyle) {
              var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
              polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
              polygonReplay.drawPolygon(geometry, feature);
            }
            var textStyle = style.getText();
            if (textStyle && textStyle.getText()) {
              var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
              textReplay.setTextStyle(textStyle);
              textReplay.drawText(geometry, feature);
            }
          }
          var VectorLayer_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var VectorLayer_CanvasVectorLayerRenderer = (
            /** @class */
            function(_super) {
              VectorLayer_extends(CanvasVectorLayerRenderer, _super);
              function CanvasVectorLayerRenderer(vectorLayer) {
                var _this = _super.call(this, vectorLayer) || this;
                _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
                _this.animatingOrInteracting_;
                _this.dirty_ = false;
                _this.hitDetectionImageData_ = null;
                _this.renderedFeatures_ = null;
                _this.renderedRevision_ = -1;
                _this.renderedResolution_ = NaN;
                _this.renderedExtent_ = createEmpty();
                _this.wrappedRenderedExtent_ = createEmpty();
                _this.renderedRotation_;
                _this.renderedCenter_ = null;
                _this.renderedProjection_ = null;
                _this.renderedRenderOrder_ = null;
                _this.replayGroup_ = null;
                _this.replayGroupChanged = true;
                _this.declutterExecutorGroup = null;
                _this.clipping = true;
                return _this;
              }
              CanvasVectorLayerRenderer.prototype.useContainer = function(target, transform2, opacity) {
                if (opacity < 1) {
                  target = null;
                }
                _super.prototype.useContainer.call(this, target, transform2, opacity);
              };
              CanvasVectorLayerRenderer.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {
                var extent = frameState.extent;
                var viewState = frameState.viewState;
                var center = viewState.center;
                var resolution = viewState.resolution;
                var projection = viewState.projection;
                var rotation = viewState.rotation;
                var projectionExtent = projection.getExtent();
                var vectorSource = this.getLayer().getSource();
                var pixelRatio = frameState.pixelRatio;
                var viewHints = frameState.viewHints;
                var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
                var context = this.context;
                var width = Math.round(frameState.size[0] * pixelRatio);
                var height = Math.round(frameState.size[1] * pixelRatio);
                var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
                var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
                var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
                var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
                do {
                  var transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
                  executorGroup.execute(context, 1, transform2, rotation, snapToPixel, void 0, opt_declutterTree);
                } while (++world < endWorld);
              };
              CanvasVectorLayerRenderer.prototype.renderDeclutter = function(frameState) {
                if (this.declutterExecutorGroup) {
                  this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
                }
              };
              CanvasVectorLayerRenderer.prototype.renderFrame = function(frameState, target) {
                var pixelRatio = frameState.pixelRatio;
                var layerState = frameState.layerStatesArray[frameState.layerIndex];
                makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
                makeInverse(this.inversePixelTransform, this.pixelTransform);
                var canvasTransform = transform_toString(this.pixelTransform);
                this.useContainer(target, canvasTransform, layerState.opacity);
                var context = this.context;
                var canvas = context.canvas;
                var replayGroup = this.replayGroup_;
                var declutterExecutorGroup = this.declutterExecutorGroup;
                if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
                  if (!this.containerReused && canvas.width > 0) {
                    canvas.width = 0;
                  }
                  return this.container;
                }
                var width = Math.round(frameState.size[0] * pixelRatio);
                var height = Math.round(frameState.size[1] * pixelRatio);
                if (canvas.width != width || canvas.height != height) {
                  canvas.width = width;
                  canvas.height = height;
                  if (canvas.style.transform !== canvasTransform) {
                    canvas.style.transform = canvasTransform;
                  }
                } else if (!this.containerReused) {
                  context.clearRect(0, 0, width, height);
                }
                this.preRender(context, frameState);
                var viewState = frameState.viewState;
                var projection = viewState.projection;
                var clipped = false;
                var render = true;
                if (layerState.extent && this.clipping) {
                  var layerExtent = fromUserExtent(layerState.extent, projection);
                  render = extent_intersects(layerExtent, frameState.extent);
                  clipped = render && !containsExtent(layerExtent, frameState.extent);
                  if (clipped) {
                    this.clipUnrotated(context, frameState, layerExtent);
                  }
                }
                if (render) {
                  this.renderWorlds(replayGroup, frameState);
                }
                if (clipped) {
                  context.restore();
                }
                this.postRender(context, frameState);
                var opacity = layerState.opacity;
                var container = this.container;
                if (opacity !== parseFloat(container.style.opacity)) {
                  container.style.opacity = opacity === 1 ? "" : String(opacity);
                }
                if (this.renderedRotation_ !== viewState.rotation) {
                  this.renderedRotation_ = viewState.rotation;
                  this.hitDetectionImageData_ = null;
                }
                return this.container;
              };
              CanvasVectorLayerRenderer.prototype.getFeatures = function(pixel) {
                return new Promise(
                  /**
                   * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
                   * @this {CanvasVectorLayerRenderer}
                   */
                  (function(resolve) {
                    if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                      var size = [this.context.canvas.width, this.context.canvas.height];
                      apply(this.pixelTransform, size);
                      var center = this.renderedCenter_;
                      var resolution = this.renderedResolution_;
                      var rotation = this.renderedRotation_;
                      var projection = this.renderedProjection_;
                      var extent = this.wrappedRenderedExtent_;
                      var layer = this.getLayer();
                      var transforms = [];
                      var width = size[0] * HIT_DETECT_RESOLUTION;
                      var height = size[1] * HIT_DETECT_RESOLUTION;
                      transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
                      var source = layer.getSource();
                      var projectionExtent = projection.getExtent();
                      if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
                        var startX = extent[0];
                        var worldWidth = getWidth(projectionExtent);
                        var world = 0;
                        var offsetX = void 0;
                        while (startX < projectionExtent[0]) {
                          --world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                          startX += worldWidth;
                        }
                        world = 0;
                        startX = extent[2];
                        while (startX > projectionExtent[2]) {
                          ++world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                          startX -= worldWidth;
                        }
                      }
                      this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
                    }
                    resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
                  }).bind(this)
                );
              };
              CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
                var _this = this;
                if (!this.replayGroup_) {
                  return void 0;
                }
                var resolution = frameState.viewState.resolution;
                var rotation = frameState.viewState.rotation;
                var layer = this.getLayer();
                var features = {};
                var featureCallback = function(feature, geometry, distanceSq) {
                  var key = Object(util[
                    "c"
                    /* getUid */
                  ])(feature);
                  var match = features[key];
                  if (!match) {
                    if (distanceSq === 0) {
                      features[key] = true;
                      return callback(feature, layer, geometry);
                    }
                    matches.push(features[key] = {
                      feature,
                      layer,
                      geometry,
                      distanceSq,
                      callback
                    });
                  } else if (match !== true && distanceSq < match.distanceSq) {
                    if (distanceSq === 0) {
                      features[key] = true;
                      matches.splice(matches.lastIndexOf(match), 1);
                      return callback(feature, layer, geometry);
                    }
                    match.geometry = geometry;
                    match.distanceSq = distanceSq;
                  }
                  return void 0;
                };
                var result;
                var executorGroups = [this.replayGroup_];
                if (this.declutterExecutorGroup) {
                  executorGroups.push(this.declutterExecutorGroup);
                }
                executorGroups.some(function(executorGroup) {
                  return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup ? frameState.declutterTree.all().map(function(item) {
                    return item.value;
                  }) : null);
                });
                return result;
              };
              CanvasVectorLayerRenderer.prototype.handleFontsChanged = function() {
                var layer = this.getLayer();
                if (layer.getVisible() && this.replayGroup_) {
                  layer.changed();
                }
              };
              CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function(event) {
                this.renderIfReadyAndVisible();
              };
              CanvasVectorLayerRenderer.prototype.prepareFrame = function(frameState) {
                var vectorLayer = this.getLayer();
                var vectorSource = vectorLayer.getSource();
                if (!vectorSource) {
                  return false;
                }
                var animating = frameState.viewHints[ViewHint.ANIMATING];
                var interacting = frameState.viewHints[ViewHint.INTERACTING];
                var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
                var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
                if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
                  this.animatingOrInteracting_ = true;
                  return true;
                }
                this.animatingOrInteracting_ = false;
                var frameStateExtent = frameState.extent;
                var viewState = frameState.viewState;
                var projection = viewState.projection;
                var resolution = viewState.resolution;
                var pixelRatio = frameState.pixelRatio;
                var vectorLayerRevision = vectorLayer.getRevision();
                var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
                var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
                if (vectorLayerRenderOrder === void 0) {
                  vectorLayerRenderOrder = defaultOrder;
                }
                var center = viewState.center.slice();
                var extent = extent_buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
                var renderedExtent = extent.slice();
                var loadExtents = [extent.slice()];
                var projectionExtent = projection.getExtent();
                if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
                  var worldWidth = getWidth(projectionExtent);
                  var gutter = Math.max(getWidth(extent) / 2, worldWidth);
                  extent[0] = projectionExtent[0] - gutter;
                  extent[2] = projectionExtent[2] + gutter;
                  coordinate_wrapX(center, projection);
                  var loadExtent = extent_wrapX(loadExtents[0], projection);
                  if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
                    loadExtents.push([
                      loadExtent[0] + worldWidth,
                      loadExtent[1],
                      loadExtent[2] + worldWidth,
                      loadExtent[3]
                    ]);
                  } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
                    loadExtents.push([
                      loadExtent[0] - worldWidth,
                      loadExtent[1],
                      loadExtent[2] - worldWidth,
                      loadExtent[3]
                    ]);
                  }
                }
                if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
                  if (!Object(ol_array[
                    "b"
                    /* equals */
                  ])(this.renderedExtent_, renderedExtent)) {
                    this.hitDetectionImageData_ = null;
                    this.renderedExtent_ = renderedExtent;
                  }
                  this.renderedCenter_ = center;
                  this.replayGroupChanged = false;
                  return true;
                }
                this.replayGroup_ = null;
                this.dirty_ = false;
                var replayGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
                var declutterBuilderGroup;
                if (this.getLayer().getDeclutter()) {
                  declutterBuilderGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
                }
                var userProjection = getUserProjection();
                var userTransform;
                if (userProjection) {
                  for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                    vectorSource.loadFeatures(toUserExtent(loadExtents[i], projection), resolution, userProjection);
                  }
                  userTransform = getTransformFromProjections(userProjection, projection);
                } else {
                  for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                    vectorSource.loadFeatures(loadExtents[i], resolution, projection);
                  }
                }
                var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
                var render = (
                  /**
                   * @param {import("../../Feature.js").default} feature Feature.
                   * @this {CanvasVectorLayerRenderer}
                   */
                  (function(feature) {
                    var styles;
                    var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
                    if (styleFunction) {
                      styles = styleFunction(feature, resolution);
                    }
                    if (styles) {
                      var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                      this.dirty_ = this.dirty_ || dirty;
                    }
                  }).bind(this)
                );
                var userExtent = toUserExtent(extent, projection);
                var features = vectorSource.getFeaturesInExtent(userExtent);
                if (vectorLayerRenderOrder) {
                  features.sort(vectorLayerRenderOrder);
                }
                for (var i = 0, ii = features.length; i < ii; ++i) {
                  render(features[i]);
                }
                this.renderedFeatures_ = features;
                var replayGroupInstructions = replayGroup.finish();
                var executorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
                if (declutterBuilderGroup) {
                  this.declutterExecutorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
                }
                this.renderedResolution_ = resolution;
                this.renderedRevision_ = vectorLayerRevision;
                this.renderedRenderOrder_ = vectorLayerRenderOrder;
                this.renderedExtent_ = renderedExtent;
                this.wrappedRenderedExtent_ = extent;
                this.renderedCenter_ = center;
                this.renderedProjection_ = projection;
                this.replayGroup_ = executorGroup;
                this.hitDetectionImageData_ = null;
                this.replayGroupChanged = true;
                return true;
              };
              CanvasVectorLayerRenderer.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
                if (!styles) {
                  return false;
                }
                var loading = false;
                if (Array.isArray(styles)) {
                  for (var i = 0, ii = styles.length; i < ii; ++i) {
                    loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
                  }
                } else {
                  loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
                }
                return loading;
              };
              return CanvasVectorLayerRenderer;
            }(canvas_Layer)
          );
          var canvas_VectorLayer = VectorLayer_CanvasVectorLayerRenderer;
          var Vector_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Vector_VectorLayer = (
            /** @class */
            function(_super) {
              Vector_extends(VectorLayer, _super);
              function VectorLayer(opt_options) {
                return _super.call(this, opt_options) || this;
              }
              VectorLayer.prototype.createRenderer = function() {
                return new canvas_VectorLayer(this);
              };
              return VectorLayer;
            }(BaseVector)
          );
          var Vector = Vector_VectorLayer;
          var VectorLayervue_type_script_lang_js = {
            name: "ol-vector-layer",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new Vector(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                vectorLayer.value.setProperties(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addLayer(vectorLayer.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeLayer(vectorLayer.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", vectorLayer);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", vectorLayer);
              return {
                vectorLayer
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-layer"
              },
              opacity: {
                type: Number,
                default: 1
              },
              visible: {
                type: Boolean,
                default: true
              },
              extent: {
                type: Array
              },
              zIndex: {
                type: Number
              },
              minResolution: {
                type: Number
              },
              maxResolution: {
                type: Number
              },
              minZoom: {
                type: Number
              },
              maxZoom: {
                type: Number
              },
              renderBuffer: {
                type: Number,
                default: 100
              },
              updateWhileAnimating: {
                type: Boolean,
                default: false
              },
              style: {
                type: Function
              },
              updateWhileInteracting: {
                type: Boolean,
                default: false
              }
            }
          };
          VectorLayervue_type_script_lang_js.render = VectorLayervue_type_template_id_9de2931c_lang_true_render;
          var layers_VectorLayer = VectorLayervue_type_script_lang_js;
          function AnimatedClusterLayervue_type_template_id_ab99be30_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var RBush_RBush = (
            /** @class */
            function() {
              function RBush(opt_maxEntries) {
                this.rbush_ = new rbush_min_default.a(opt_maxEntries);
                this.items_ = {};
              }
              RBush.prototype.insert = function(extent, value) {
                var item = {
                  minX: extent[0],
                  minY: extent[1],
                  maxX: extent[2],
                  maxY: extent[3],
                  value
                };
                this.rbush_.insert(item);
                this.items_[Object(util[
                  "c"
                  /* getUid */
                ])(value)] = item;
              };
              RBush.prototype.load = function(extents, values) {
                var items = new Array(values.length);
                for (var i = 0, l = values.length; i < l; i++) {
                  var extent = extents[i];
                  var value = values[i];
                  var item = {
                    minX: extent[0],
                    minY: extent[1],
                    maxX: extent[2],
                    maxY: extent[3],
                    value
                  };
                  items[i] = item;
                  this.items_[Object(util[
                    "c"
                    /* getUid */
                  ])(value)] = item;
                }
                this.rbush_.load(items);
              };
              RBush.prototype.remove = function(value) {
                var uid = Object(util[
                  "c"
                  /* getUid */
                ])(value);
                var item = this.items_[uid];
                delete this.items_[uid];
                return this.rbush_.remove(item) !== null;
              };
              RBush.prototype.update = function(extent, value) {
                var item = this.items_[Object(util[
                  "c"
                  /* getUid */
                ])(value)];
                var bbox = [item.minX, item.minY, item.maxX, item.maxY];
                if (!equals(bbox, extent)) {
                  this.remove(value);
                  this.insert(extent, value);
                }
              };
              RBush.prototype.getAll = function() {
                var items = this.rbush_.all();
                return items.map(function(item) {
                  return item.value;
                });
              };
              RBush.prototype.getInExtent = function(extent) {
                var bbox = {
                  minX: extent[0],
                  minY: extent[1],
                  maxX: extent[2],
                  maxY: extent[3]
                };
                var items = this.rbush_.search(bbox);
                return items.map(function(item) {
                  return item.value;
                });
              };
              RBush.prototype.forEach = function(callback) {
                return this.forEach_(this.getAll(), callback);
              };
              RBush.prototype.forEachInExtent = function(extent, callback) {
                return this.forEach_(this.getInExtent(extent), callback);
              };
              RBush.prototype.forEach_ = function(values, callback) {
                var result;
                for (var i = 0, l = values.length; i < l; i++) {
                  result = callback(values[i]);
                  if (result) {
                    return result;
                  }
                }
                return result;
              };
              RBush.prototype.isEmpty = function() {
                return Object(ol_obj[
                  "d"
                  /* isEmpty */
                ])(this.items_);
              };
              RBush.prototype.clear = function() {
                this.rbush_.clear();
                this.items_ = {};
              };
              RBush.prototype.getExtent = function(opt_extent) {
                var data = this.rbush_.toJSON();
                return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
              };
              RBush.prototype.concat = function(rbush) {
                this.rbush_.load(rbush.rbush_.all());
                for (var i in rbush.items_) {
                  this.items_[i] = rbush.items_[i];
                }
              };
              return RBush;
            }()
          );
          var structs_RBush = RBush_RBush;
          var Source_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Source_Source = (
            /** @class */
            function(_super) {
              Source_extends(Source, _super);
              function Source(options) {
                var _this = _super.call(this) || this;
                _this.projection = proj_get(options.projection);
                _this.attributions_ = adaptAttributions(options.attributions);
                _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
                _this.loading = false;
                _this.state_ = options.state !== void 0 ? options.state : State.READY;
                _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
                return _this;
              }
              Source.prototype.getAttributions = function() {
                return this.attributions_;
              };
              Source.prototype.getAttributionsCollapsible = function() {
                return this.attributionsCollapsible_;
              };
              Source.prototype.getProjection = function() {
                return this.projection;
              };
              Source.prototype.getResolutions = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Source.prototype.getState = function() {
                return this.state_;
              };
              Source.prototype.getWrapX = function() {
                return this.wrapX_;
              };
              Source.prototype.getContextOptions = function() {
                return void 0;
              };
              Source.prototype.refresh = function() {
                this.changed();
              };
              Source.prototype.setAttributions = function(attributions) {
                this.attributions_ = adaptAttributions(attributions);
                this.changed();
              };
              Source.prototype.setState = function(state) {
                this.state_ = state;
                this.changed();
              };
              return Source;
            }(ol_Object[
              "a"
              /* default */
            ])
          );
          function adaptAttributions(attributionLike) {
            if (!attributionLike) {
              return null;
            }
            if (Array.isArray(attributionLike)) {
              return function(frameState) {
                return attributionLike;
              };
            }
            if (typeof attributionLike === "function") {
              return attributionLike;
            }
            return function(frameState) {
              return [attributionLike];
            };
          }
          var source_Source = Source_Source;
          var VectorEventType = {
            /**
             * Triggered when a feature is added to the source.
             * @event module:ol/source/Vector.VectorSourceEvent#addfeature
             * @api
             */
            ADDFEATURE: "addfeature",
            /**
             * Triggered when a feature is updated.
             * @event module:ol/source/Vector.VectorSourceEvent#changefeature
             * @api
             */
            CHANGEFEATURE: "changefeature",
            /**
             * Triggered when the clear method is called on the source.
             * @event module:ol/source/Vector.VectorSourceEvent#clear
             * @api
             */
            CLEAR: "clear",
            /**
             * Triggered when a feature is removed from the source.
             * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
             * @event module:ol/source/Vector.VectorSourceEvent#removefeature
             * @api
             */
            REMOVEFEATURE: "removefeature",
            /**
             * Triggered when features starts loading.
             * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
             * @api
             */
            FEATURESLOADSTART: "featuresloadstart",
            /**
             * Triggered when features finishes loading.
             * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
             * @api
             */
            FEATURESLOADEND: "featuresloadend",
            /**
             * Triggered if feature loading results in an error.
             * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
             * @api
             */
            FEATURESLOADERROR: "featuresloaderror"
          };
          function loadingstrategy_all(extent, resolution) {
            return [[-Infinity, -Infinity, Infinity, Infinity]];
          }
          function loadingstrategy_bbox(extent, resolution) {
            return [extent];
          }
          function loadingstrategy_tile(tileGrid) {
            return (
              /**
               * @param {import("./extent.js").Extent} extent Extent.
               * @param {number} resolution Resolution.
               * @return {Array<import("./extent.js").Extent>} Extents.
               */
              function(extent, resolution) {
                var z = tileGrid.getZForResolution(resolution);
                var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
                var extents = [];
                var tileCoord = [z, 0, 0];
                for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
                  for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
                    extents.push(tileGrid.getTileCoordExtent(tileCoord));
                  }
                }
                return extents;
              }
            );
          }
          var FormatType = {
            ARRAY_BUFFER: "arraybuffer",
            JSON: "json",
            TEXT: "text",
            XML: "xml"
          };
          var withCredentials = false;
          function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
            if (format.getType() == FormatType.ARRAY_BUFFER) {
              xhr.responseType = "arraybuffer";
            }
            xhr.withCredentials = withCredentials;
            xhr.onload = function(event) {
              if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
                var type = format.getType();
                var source = void 0;
                if (type == FormatType.JSON || type == FormatType.TEXT) {
                  source = xhr.responseText;
                } else if (type == FormatType.XML) {
                  source = xhr.responseXML;
                  if (!source) {
                    source = new DOMParser().parseFromString(xhr.responseText, "application/xml");
                  }
                } else if (type == FormatType.ARRAY_BUFFER) {
                  source = /** @type {ArrayBuffer} */
                  xhr.response;
                }
                if (source) {
                  success(
                    /** @type {Array<import("./Feature.js").default>} */
                    format.readFeatures(source, {
                      extent,
                      featureProjection: projection
                    }),
                    format.readProjection(source)
                  );
                } else {
                  failure();
                }
              } else {
                failure();
              }
            };
            xhr.onerror = failure;
            xhr.send();
          }
          function featureloader_xhr(url, format) {
            return function(extent, resolution, projection, success, failure) {
              var source = (
                /** @type {import("./source/Vector").default} */
                this
              );
              loadFeaturesXhr(
                url,
                format,
                extent,
                resolution,
                projection,
                /**
                 * @param {Array<import("./Feature.js").default>} features The loaded features.
                 * @param {import("./proj/Projection.js").default} dataProjection Data
                 * projection.
                 */
                function(features, dataProjection) {
                  source.addFeatures(features);
                  if (success !== void 0) {
                    success(features);
                  }
                },
                /* FIXME handle error */
                failure ? failure : functions[
                  "c"
                  /* VOID */
                ]
              );
            };
          }
          function setWithCredentials(xhrWithCredentials) {
            withCredentials = xhrWithCredentials;
          }
          var source_Vector_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var VectorSourceEvent = (
            /** @class */
            function(_super) {
              source_Vector_extends(VectorSourceEvent2, _super);
              function VectorSourceEvent2(type, opt_feature, opt_features) {
                var _this = _super.call(this, type) || this;
                _this.feature = opt_feature;
                _this.features = opt_features;
                return _this;
              }
              return VectorSourceEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Vector_VectorSource = (
            /** @class */
            function(_super) {
              source_Vector_extends(VectorSource, _super);
              function VectorSource(opt_options) {
                var _this = this;
                var options = opt_options || {};
                _this = _super.call(this, {
                  attributions: options.attributions,
                  projection: void 0,
                  state: State.READY,
                  wrapX: options.wrapX !== void 0 ? options.wrapX : true
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.loader_ = functions[
                  "c"
                  /* VOID */
                ];
                _this.format_ = options.format;
                _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
                _this.url_ = options.url;
                if (options.loader !== void 0) {
                  _this.loader_ = options.loader;
                } else if (_this.url_ !== void 0) {
                  assert2(_this.format_, 7);
                  _this.loader_ = featureloader_xhr(
                    _this.url_,
                    /** @type {import("../format/Feature.js").default} */
                    _this.format_
                  );
                }
                _this.strategy_ = options.strategy !== void 0 ? options.strategy : loadingstrategy_all;
                var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
                _this.featuresRtree_ = useSpatialIndex ? new structs_RBush() : null;
                _this.loadedExtentsRtree_ = new structs_RBush();
                _this.loadingExtentsCount_ = 0;
                _this.nullGeometryFeatures_ = {};
                _this.idIndex_ = {};
                _this.uidIndex_ = {};
                _this.featureChangeKeys_ = {};
                _this.featuresCollection_ = null;
                var collection, features;
                if (Array.isArray(options.features)) {
                  features = options.features;
                } else if (options.features) {
                  collection = options.features;
                  features = collection.getArray();
                }
                if (!useSpatialIndex && collection === void 0) {
                  collection = new ol_Collection(features);
                }
                if (features !== void 0) {
                  _this.addFeaturesInternal(features);
                }
                if (collection !== void 0) {
                  _this.bindFeaturesCollection_(collection);
                }
                return _this;
              }
              VectorSource.prototype.addFeature = function(feature) {
                this.addFeatureInternal(feature);
                this.changed();
              };
              VectorSource.prototype.addFeatureInternal = function(feature) {
                var featureKey = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                if (!this.addToIndex_(featureKey, feature)) {
                  if (this.featuresCollection_) {
                    this.featuresCollection_.remove(feature);
                  }
                  return;
                }
                this.setupChangeEvents_(featureKey, feature);
                var geometry = feature.getGeometry();
                if (geometry) {
                  var extent = geometry.getExtent();
                  if (this.featuresRtree_) {
                    this.featuresRtree_.insert(extent, feature);
                  }
                } else {
                  this.nullGeometryFeatures_[featureKey] = feature;
                }
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
              };
              VectorSource.prototype.setupChangeEvents_ = function(featureKey, feature) {
                this.featureChangeKeys_[featureKey] = [
                  Object(events[
                    "a"
                    /* listen */
                  ])(feature, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleFeatureChange_, this),
                  Object(events[
                    "a"
                    /* listen */
                  ])(feature, ObjectEventType[
                    "a"
                    /* default */
                  ].PROPERTYCHANGE, this.handleFeatureChange_, this)
                ];
              };
              VectorSource.prototype.addToIndex_ = function(featureKey, feature) {
                var valid = true;
                var id = feature.getId();
                if (id !== void 0) {
                  if (!(id.toString() in this.idIndex_)) {
                    this.idIndex_[id.toString()] = feature;
                  } else {
                    valid = false;
                  }
                }
                if (valid) {
                  assert2(!(featureKey in this.uidIndex_), 30);
                  this.uidIndex_[featureKey] = feature;
                }
                return valid;
              };
              VectorSource.prototype.addFeatures = function(features) {
                this.addFeaturesInternal(features);
                this.changed();
              };
              VectorSource.prototype.addFeaturesInternal = function(features) {
                var extents = [];
                var newFeatures = [];
                var geometryFeatures = [];
                for (var i = 0, length_1 = features.length; i < length_1; i++) {
                  var feature = features[i];
                  var featureKey = Object(util[
                    "c"
                    /* getUid */
                  ])(feature);
                  if (this.addToIndex_(featureKey, feature)) {
                    newFeatures.push(feature);
                  }
                }
                for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
                  var feature = newFeatures[i];
                  var featureKey = Object(util[
                    "c"
                    /* getUid */
                  ])(feature);
                  this.setupChangeEvents_(featureKey, feature);
                  var geometry = feature.getGeometry();
                  if (geometry) {
                    var extent = geometry.getExtent();
                    extents.push(extent);
                    geometryFeatures.push(feature);
                  } else {
                    this.nullGeometryFeatures_[featureKey] = feature;
                  }
                }
                if (this.featuresRtree_) {
                  this.featuresRtree_.load(extents, geometryFeatures);
                }
                for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
                  this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
                }
              };
              VectorSource.prototype.bindFeaturesCollection_ = function(collection) {
                var modifyingCollection = false;
                this.addEventListener(
                  VectorEventType.ADDFEATURE,
                  /**
                   * @param {VectorSourceEvent<Geometry>} evt The vector source event
                   */
                  function(evt) {
                    if (!modifyingCollection) {
                      modifyingCollection = true;
                      collection.push(evt.feature);
                      modifyingCollection = false;
                    }
                  }
                );
                this.addEventListener(
                  VectorEventType.REMOVEFEATURE,
                  /**
                   * @param {VectorSourceEvent<Geometry>} evt The vector source event
                   */
                  function(evt) {
                    if (!modifyingCollection) {
                      modifyingCollection = true;
                      collection.remove(evt.feature);
                      modifyingCollection = false;
                    }
                  }
                );
                collection.addEventListener(
                  CollectionEventType.ADD,
                  /**
                   * @param {import("../Collection.js").CollectionEvent} evt The collection event
                   */
                  (function(evt) {
                    if (!modifyingCollection) {
                      modifyingCollection = true;
                      this.addFeature(
                        /** @type {import("../Feature.js").default<Geometry>} */
                        evt.element
                      );
                      modifyingCollection = false;
                    }
                  }).bind(this)
                );
                collection.addEventListener(
                  CollectionEventType.REMOVE,
                  /**
                   * @param {import("../Collection.js").CollectionEvent} evt The collection event
                   */
                  (function(evt) {
                    if (!modifyingCollection) {
                      modifyingCollection = true;
                      this.removeFeature(
                        /** @type {import("../Feature.js").default<Geometry>} */
                        evt.element
                      );
                      modifyingCollection = false;
                    }
                  }).bind(this)
                );
                this.featuresCollection_ = collection;
              };
              VectorSource.prototype.clear = function(opt_fast) {
                if (opt_fast) {
                  for (var featureId in this.featureChangeKeys_) {
                    var keys = this.featureChangeKeys_[featureId];
                    keys.forEach(events[
                      "c"
                      /* unlistenByKey */
                    ]);
                  }
                  if (!this.featuresCollection_) {
                    this.featureChangeKeys_ = {};
                    this.idIndex_ = {};
                    this.uidIndex_ = {};
                  }
                } else {
                  if (this.featuresRtree_) {
                    this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
                    for (var id in this.nullGeometryFeatures_) {
                      this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                    }
                  }
                }
                if (this.featuresCollection_) {
                  this.featuresCollection_.clear();
                }
                if (this.featuresRtree_) {
                  this.featuresRtree_.clear();
                }
                this.nullGeometryFeatures_ = {};
                var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
                this.dispatchEvent(clearEvent);
                this.changed();
              };
              VectorSource.prototype.forEachFeature = function(callback) {
                if (this.featuresRtree_) {
                  return this.featuresRtree_.forEach(callback);
                } else if (this.featuresCollection_) {
                  this.featuresCollection_.forEach(callback);
                }
              };
              VectorSource.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
                var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
                return this.forEachFeatureInExtent(extent, function(feature) {
                  var geometry = feature.getGeometry();
                  if (geometry.intersectsCoordinate(coordinate)) {
                    return callback(feature);
                  } else {
                    return void 0;
                  }
                });
              };
              VectorSource.prototype.forEachFeatureInExtent = function(extent, callback) {
                if (this.featuresRtree_) {
                  return this.featuresRtree_.forEachInExtent(extent, callback);
                } else if (this.featuresCollection_) {
                  this.featuresCollection_.forEach(callback);
                }
              };
              VectorSource.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
                return this.forEachFeatureInExtent(
                  extent,
                  /**
                   * @param {import("../Feature.js").default<Geometry>} feature Feature.
                   * @return {T|undefined} The return value from the last call to the callback.
                   */
                  function(feature) {
                    var geometry = feature.getGeometry();
                    if (geometry.intersectsExtent(extent)) {
                      var result = callback(feature);
                      if (result) {
                        return result;
                      }
                    }
                  }
                );
              };
              VectorSource.prototype.getFeaturesCollection = function() {
                return this.featuresCollection_;
              };
              VectorSource.prototype.getFeatures = function() {
                var features;
                if (this.featuresCollection_) {
                  features = this.featuresCollection_.getArray().slice(0);
                } else if (this.featuresRtree_) {
                  features = this.featuresRtree_.getAll();
                  if (!Object(ol_obj[
                    "d"
                    /* isEmpty */
                  ])(this.nullGeometryFeatures_)) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(features, Object(ol_obj[
                      "c"
                      /* getValues */
                    ])(this.nullGeometryFeatures_));
                  }
                }
                return (
                  /** @type {Array<import("../Feature.js").default<Geometry>>} */
                  features
                );
              };
              VectorSource.prototype.getFeaturesAtCoordinate = function(coordinate) {
                var features = [];
                this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
                  features.push(feature);
                });
                return features;
              };
              VectorSource.prototype.getFeaturesInExtent = function(extent) {
                if (this.featuresRtree_) {
                  return this.featuresRtree_.getInExtent(extent);
                } else if (this.featuresCollection_) {
                  return this.featuresCollection_.getArray().slice(0);
                } else {
                  return [];
                }
              };
              VectorSource.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
                var x = coordinate[0];
                var y = coordinate[1];
                var closestFeature = null;
                var closestPoint = [NaN, NaN];
                var minSquaredDistance = Infinity;
                var extent = [-Infinity, -Infinity, Infinity, Infinity];
                var filter = opt_filter ? opt_filter : functions[
                  "b"
                  /* TRUE */
                ];
                this.featuresRtree_.forEachInExtent(
                  extent,
                  /**
                   * @param {import("../Feature.js").default<Geometry>} feature Feature.
                   */
                  function(feature) {
                    if (filter(feature)) {
                      var geometry = feature.getGeometry();
                      var previousMinSquaredDistance = minSquaredDistance;
                      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                      if (minSquaredDistance < previousMinSquaredDistance) {
                        closestFeature = feature;
                        var minDistance = Math.sqrt(minSquaredDistance);
                        extent[0] = x - minDistance;
                        extent[1] = y - minDistance;
                        extent[2] = x + minDistance;
                        extent[3] = y + minDistance;
                      }
                    }
                  }
                );
                return closestFeature;
              };
              VectorSource.prototype.getExtent = function(opt_extent) {
                return this.featuresRtree_.getExtent(opt_extent);
              };
              VectorSource.prototype.getFeatureById = function(id) {
                var feature = this.idIndex_[id.toString()];
                return feature !== void 0 ? feature : null;
              };
              VectorSource.prototype.getFeatureByUid = function(uid) {
                var feature = this.uidIndex_[uid];
                return feature !== void 0 ? feature : null;
              };
              VectorSource.prototype.getFormat = function() {
                return this.format_;
              };
              VectorSource.prototype.getOverlaps = function() {
                return this.overlaps_;
              };
              VectorSource.prototype.getUrl = function() {
                return this.url_;
              };
              VectorSource.prototype.handleFeatureChange_ = function(event) {
                var feature = (
                  /** @type {import("../Feature.js").default<Geometry>} */
                  event.target
                );
                var featureKey = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                var geometry = feature.getGeometry();
                if (!geometry) {
                  if (!(featureKey in this.nullGeometryFeatures_)) {
                    if (this.featuresRtree_) {
                      this.featuresRtree_.remove(feature);
                    }
                    this.nullGeometryFeatures_[featureKey] = feature;
                  }
                } else {
                  var extent = geometry.getExtent();
                  if (featureKey in this.nullGeometryFeatures_) {
                    delete this.nullGeometryFeatures_[featureKey];
                    if (this.featuresRtree_) {
                      this.featuresRtree_.insert(extent, feature);
                    }
                  } else {
                    if (this.featuresRtree_) {
                      this.featuresRtree_.update(extent, feature);
                    }
                  }
                }
                var id = feature.getId();
                if (id !== void 0) {
                  var sid = id.toString();
                  if (this.idIndex_[sid] !== feature) {
                    this.removeFromIdIndex_(feature);
                    this.idIndex_[sid] = feature;
                  }
                } else {
                  this.removeFromIdIndex_(feature);
                  this.uidIndex_[featureKey] = feature;
                }
                this.changed();
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
              };
              VectorSource.prototype.hasFeature = function(feature) {
                var id = feature.getId();
                if (id !== void 0) {
                  return id in this.idIndex_;
                } else {
                  return Object(util[
                    "c"
                    /* getUid */
                  ])(feature) in this.uidIndex_;
                }
              };
              VectorSource.prototype.isEmpty = function() {
                return this.featuresRtree_.isEmpty() && Object(ol_obj[
                  "d"
                  /* isEmpty */
                ])(this.nullGeometryFeatures_);
              };
              VectorSource.prototype.loadFeatures = function(extent, resolution, projection) {
                var loadedExtentsRtree = this.loadedExtentsRtree_;
                var extentsToLoad = this.strategy_(extent, resolution);
                var _loop_1 = function(i2, ii2) {
                  var extentToLoad = extentsToLoad[i2];
                  var alreadyLoaded = loadedExtentsRtree.forEachInExtent(
                    extentToLoad,
                    /**
                     * @param {{extent: import("../extent.js").Extent}} object Object.
                     * @return {boolean} Contains.
                     */
                    function(object) {
                      return containsExtent(object.extent, extentToLoad);
                    }
                  );
                  if (!alreadyLoaded) {
                    ++this_1.loadingExtentsCount_;
                    this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
                    this_1.loader_.call(this_1, extentToLoad, resolution, projection, (function(features) {
                      --this.loadingExtentsCount_;
                      this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
                    }).bind(this_1), (function() {
                      --this.loadingExtentsCount_;
                      this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
                    }).bind(this_1));
                    loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
                  }
                };
                var this_1 = this;
                for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
                  _loop_1(i, ii);
                }
                this.loading = this.loader_ === functions[
                  "c"
                  /* VOID */
                ] ? false : this.loadingExtentsCount_ > 0;
              };
              VectorSource.prototype.refresh = function() {
                this.clear(true);
                this.loadedExtentsRtree_.clear();
                _super.prototype.refresh.call(this);
              };
              VectorSource.prototype.removeLoadedExtent = function(extent) {
                var loadedExtentsRtree = this.loadedExtentsRtree_;
                var obj;
                loadedExtentsRtree.forEachInExtent(extent, function(object) {
                  if (equals(object.extent, extent)) {
                    obj = object;
                    return true;
                  }
                });
                if (obj) {
                  loadedExtentsRtree.remove(obj);
                }
              };
              VectorSource.prototype.removeFeature = function(feature) {
                var featureKey = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                if (featureKey in this.nullGeometryFeatures_) {
                  delete this.nullGeometryFeatures_[featureKey];
                } else {
                  if (this.featuresRtree_) {
                    this.featuresRtree_.remove(feature);
                  }
                }
                this.removeFeatureInternal(feature);
                this.changed();
              };
              VectorSource.prototype.removeFeatureInternal = function(feature) {
                var featureKey = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                this.featureChangeKeys_[featureKey].forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                delete this.featureChangeKeys_[featureKey];
                var id = feature.getId();
                if (id !== void 0) {
                  delete this.idIndex_[id.toString()];
                }
                delete this.uidIndex_[featureKey];
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
              };
              VectorSource.prototype.removeFromIdIndex_ = function(feature) {
                var removed = false;
                for (var id in this.idIndex_) {
                  if (this.idIndex_[id] === feature) {
                    delete this.idIndex_[id];
                    removed = true;
                    break;
                  }
                }
                return removed;
              };
              VectorSource.prototype.setLoader = function(loader) {
                this.loader_ = loader;
              };
              VectorSource.prototype.setUrl = function(url) {
                assert2(this.format_, 7);
                this.url_ = url;
                this.setLoader(featureloader_xhr(url, this.format_));
              };
              return VectorSource;
            }(source_Source)
          );
          var source_Vector = Vector_VectorSource;
          var Cluster_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Cluster_Cluster = (
            /** @class */
            function(_super) {
              Cluster_extends(Cluster, _super);
              function Cluster(options) {
                var _this = _super.call(this, {
                  attributions: options.attributions,
                  wrapX: options.wrapX
                }) || this;
                _this.resolution = void 0;
                _this.distance = options.distance !== void 0 ? options.distance : 20;
                _this.minDistance = options.minDistance || 0;
                _this.interpolationRatio = 0;
                _this.features = [];
                _this.geometryFunction = options.geometryFunction || function(feature) {
                  var geometry = feature.getGeometry();
                  assert2(geometry.getType() == geom_GeometryType.POINT, 10);
                  return geometry;
                };
                _this.source = null;
                _this.boundRefresh_ = _this.refresh.bind(_this);
                _this.updateDistance(_this.distance, _this.minDistance);
                _this.setSource(options.source || null);
                return _this;
              }
              Cluster.prototype.clear = function(opt_fast) {
                this.features.length = 0;
                _super.prototype.clear.call(this, opt_fast);
              };
              Cluster.prototype.getDistance = function() {
                return this.distance;
              };
              Cluster.prototype.getSource = function() {
                return this.source;
              };
              Cluster.prototype.loadFeatures = function(extent, resolution, projection) {
                this.source.loadFeatures(extent, resolution, projection);
                if (resolution !== this.resolution) {
                  this.resolution = resolution;
                  this.refresh();
                }
              };
              Cluster.prototype.setDistance = function(distance) {
                this.updateDistance(distance, this.minDistance);
              };
              Cluster.prototype.setMinDistance = function(minDistance) {
                this.updateDistance(this.distance, minDistance);
              };
              Cluster.prototype.getMinDistance = function() {
                return this.minDistance;
              };
              Cluster.prototype.setSource = function(source) {
                if (this.source) {
                  this.source.removeEventListener(EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.boundRefresh_);
                }
                this.source = source;
                if (source) {
                  source.addEventListener(EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.boundRefresh_);
                }
                this.refresh();
              };
              Cluster.prototype.refresh = function() {
                this.clear();
                this.cluster();
                this.addFeatures(this.features);
              };
              Cluster.prototype.updateDistance = function(distance, minDistance) {
                var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
                var changed = distance !== this.distance || this.interpolationRatio !== ratio;
                this.distance = distance;
                this.minDistance = minDistance;
                this.interpolationRatio = ratio;
                if (changed) {
                  this.refresh();
                }
              };
              Cluster.prototype.cluster = function() {
                if (this.resolution === void 0 || !this.source) {
                  return;
                }
                var extent = createEmpty();
                var mapDistance = this.distance * this.resolution;
                var features = this.source.getFeatures();
                var clustered = {};
                for (var i = 0, ii = features.length; i < ii; i++) {
                  var feature = features[i];
                  if (!(Object(util[
                    "c"
                    /* getUid */
                  ])(feature) in clustered)) {
                    var geometry = this.geometryFunction(feature);
                    if (geometry) {
                      var coordinates = geometry.getCoordinates();
                      createOrUpdateFromCoordinate(coordinates, extent);
                      extent_buffer(extent, mapDistance, extent);
                      var neighbors = this.source.getFeaturesInExtent(extent).filter(function(neighbor) {
                        var uid = Object(util[
                          "c"
                          /* getUid */
                        ])(neighbor);
                        if (uid in clustered) {
                          return false;
                        }
                        clustered[uid] = true;
                        return true;
                      });
                      this.features.push(this.createCluster(neighbors, extent));
                    }
                  }
                }
              };
              Cluster.prototype.createCluster = function(features, extent) {
                var centroid = [0, 0];
                for (var i = features.length - 1; i >= 0; --i) {
                  var geometry_1 = this.geometryFunction(features[i]);
                  if (geometry_1) {
                    coordinate_add(centroid, geometry_1.getCoordinates());
                  } else {
                    features.splice(i, 1);
                  }
                }
                coordinate_scale(centroid, 1 / features.length);
                var searchCenter = extent_getCenter(extent);
                var ratio = this.interpolationRatio;
                var geometry = new geom_Point([
                  centroid[0] * (1 - ratio) + searchCenter[0] * ratio,
                  centroid[1] * (1 - ratio) + searchCenter[1] * ratio
                ]);
                var cluster = new ol_Feature(geometry);
                cluster.set("features", features, true);
                return cluster;
              };
              return Cluster;
            }(source_Vector)
          );
          var source_Cluster = Cluster_Cluster;
          if (window.ol && !ol.ext) {
            ol.ext = {};
          }
          var ol_ext_inherits = function(child, parent) {
            child.prototype = Object.create(parent.prototype);
            child.prototype.constructor = child;
          };
          if (window.ol) {
            if (!ol.inherits) ol.inherits = ol_ext_inherits;
          }
          if (window.NodeList && !NodeList.prototype.forEach) {
            NodeList.prototype.forEach = Array.prototype.forEach;
          }
          if (window.Element && !Element.prototype.remove) {
            Element.prototype.remove = function() {
              if (this.parentNode) this.parentNode.removeChild(this);
            };
          }
          var util_ext = ol_ext_inherits;
          function getVectorContext(event) {
            const frameState = event.frameState;
            const transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
            return new Immediate(
              event.context,
              frameState.pixelRatio,
              frameState.extent,
              transform2,
              frameState.viewState.rotation
            );
          }
          var util_getVectorContext = getVectorContext;
          var ol_layer_AnimatedCluster = function(opt_options) {
            var options = opt_options || {};
            Vector.call(this, options);
            this.oldcluster = new source_Vector();
            this.clusters = [];
            this.animation = { start: false };
            this.set("animationDuration", typeof options.animationDuration == "number" ? options.animationDuration : 700);
            this.set("animationMethod", options.animationMethod || easeOut);
            this.getSource().on("change", this.saveCluster.bind(this));
            this.on(["precompose", "prerender"], this.animate.bind(this));
            this.on(["postcompose", "postrender"], this.postanimate.bind(this));
          };
          util_ext(ol_layer_AnimatedCluster, Vector);
          ol_layer_AnimatedCluster.prototype.saveCluster = function() {
            if (this.oldcluster) {
              this.oldcluster.clear();
              if (!this.get("animationDuration")) return;
              var features = this.getSource().getFeatures();
              if (features.length && features[0].get("features")) {
                this.oldcluster.addFeatures(this.clusters);
                this.clusters = features.slice(0);
                this.sourceChanged = true;
              }
            }
          };
          ol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f, cluster) {
            for (var j = 0, c; c = cluster[j]; j++) {
              var features = c.get("features");
              if (features && features.length) {
                for (var k = 0, f2; f2 = features[k]; k++) {
                  if (f === f2) {
                    return c;
                  }
                }
              }
            }
            return false;
          };
          ol_layer_AnimatedCluster.prototype.stopAnimation = function() {
            this.animation.start = false;
            this.animation.cA = [];
            this.animation.cB = [];
          };
          ol_layer_AnimatedCluster.prototype.animate = function(e) {
            var duration = this.get("animationDuration");
            if (!duration) return;
            var resolution = e.frameState.viewState.resolution;
            var i, c0, a = this.animation;
            var time = e.frameState.time;
            if (a.resolution != resolution && this.sourceChanged) {
              var extent = e.frameState.extent;
              if (a.resolution < resolution) {
                extent = extent_buffer(extent, 100 * resolution);
                a.cA = this.oldcluster.getFeaturesInExtent(extent);
                a.cB = this.getSource().getFeaturesInExtent(extent);
                a.revers = false;
              } else {
                extent = extent_buffer(extent, 100 * resolution);
                a.cA = this.getSource().getFeaturesInExtent(extent);
                a.cB = this.oldcluster.getFeaturesInExtent(extent);
                a.revers = true;
              }
              a.clusters = [];
              for (i = 0, c0; c0 = a.cA[i]; i++) {
                var f = c0.get("features");
                if (f && f.length) {
                  var c = this.getClusterForFeature(f[0], a.cB);
                  if (c) a.clusters.push({ f: c0, pt: c.getGeometry().getCoordinates() });
                }
              }
              a.resolution = resolution;
              this.sourceChanged = false;
              if (!a.clusters.length || a.clusters.length > 1e3) {
                this.stopAnimation();
                return;
              }
              time = a.start = (/* @__PURE__ */ new Date()).getTime();
            }
            if (a.start) {
              var vectorContext = e.vectorContext || util_getVectorContext(e);
              var d = (time - a.start) / duration;
              if (d > 1) {
                this.stopAnimation();
                d = 1;
              }
              d = this.get("animationMethod")(d);
              var style = this.getStyle();
              var stylefn = typeof style == "function" ? style : style.length ? function() {
                return style;
              } : function() {
                return [style];
              };
              e.context.save();
              e.context.globalAlpha = this.getOpacity();
              for (i = 0, c; c = a.clusters[i]; i++) {
                var pt = c.f.getGeometry().getCoordinates();
                var dx = pt[0] - c.pt[0];
                var dy = pt[1] - c.pt[1];
                if (a.revers) {
                  pt[0] = c.pt[0] + d * dx;
                  pt[1] = c.pt[1] + d * dy;
                } else {
                  pt[0] = pt[0] - d * dx;
                  pt[1] = pt[1] - d * dy;
                }
                var st = stylefn(c.f, resolution, true);
                if (!st.length) st = [st];
                if (c.f.get("features").length === 1 && !dx && !dy) {
                  f = c.f.get("features")[0];
                } else {
                  var geo = new geom_Point(pt);
                  f = new ol_Feature(geo);
                }
                for (var k = 0, s; s = st[k]; k++) {
                  if (s.getText() && /\n/.test(s.getText().getText())) {
                    var offsetX = s.getText().getOffsetX();
                    var offsetY = s.getText().getOffsetY();
                    var rot = s.getText().getRotation() || 0;
                    var fontSize = Number((s.getText().getFont() || "10px").match(/\d+/)) * 1.2;
                    var str = s.getText().getText().split("\n");
                    var dl, nb = str.length - 1;
                    var s2 = s.clone();
                    str.forEach(function(t, i2) {
                      if (i2 == 1) {
                        s2.setImage();
                        s2.setFill();
                        s2.setStroke();
                      }
                      switch (s.getText().getTextBaseline()) {
                        case "alphabetic":
                        case "ideographic":
                        case "bottom": {
                          dl = nb;
                          break;
                        }
                        case "hanging":
                        case "top": {
                          dl = 0;
                          break;
                        }
                        default: {
                          dl = nb / 2;
                          break;
                        }
                      }
                      s2.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize * (i2 - dl));
                      s2.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize * (i2 - dl));
                      s2.getText().setText(t);
                      vectorContext.drawFeature(f, s2);
                    });
                  } else {
                    vectorContext.drawFeature(f, s);
                  }
                }
              }
              e.context.restore();
              e.frameState.animate = true;
              e.context.save();
              e.context.beginPath();
              e.context.rect(0, 0, 0, 0);
              e.context.clip();
              this.clip_ = true;
            }
            return;
          };
          ol_layer_AnimatedCluster.prototype.postanimate = function(e) {
            if (this.clip_) {
              e.context.restore();
              this.clip_ = false;
            }
          };
          var AnimatedCluster = ol_layer_AnimatedCluster;
          var AnimatedClusterLayervue_type_script_lang_js = {
            name: "ol-animated-clusterlayer",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var ac = new AnimatedCluster(_objectSpread2(_objectSpread2({}, properties), {}, {
                  source: new source_Cluster({
                    distance: properties.distance
                  })
                }));
                return ac;
              });
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return vectorLayer.value.getSource();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                vectorLayer.value.setProperties(properties);
                vectorLayer.value.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addLayer(vectorLayer.value);
                vectorLayer.value.changed();
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeLayer(vectorLayer.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", source);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", vectorLayer);
              return {
                vectorLayer,
                map
              };
            },
            props: {
              animationDuration: {
                type: Number,
                default: 700
              },
              distance: {
                type: Number,
                default: 20
              },
              animationMethod: {
                type: Function,
                default: easeOut
              },
              updateWhileAnimating: {
                type: Boolean,
                default: false
              },
              updateWhileInteracting: {
                type: Boolean,
                default: false
              }
            }
          };
          AnimatedClusterLayervue_type_script_lang_js.render = AnimatedClusterLayervue_type_template_id_ab99be30_lang_true_render;
          var AnimatedClusterLayer = AnimatedClusterLayervue_type_script_lang_js;
          function layers_install(app) {
            if (layers_install.installed) {
              return;
            }
            layers_install.installed = true;
            app.component(layers_TileLayer.name, layers_TileLayer);
            app.component(layers_ImageLayer.name, layers_ImageLayer);
            app.component(layers_VectorLayer.name, layers_VectorLayer);
            app.component(AnimatedClusterLayer.name, AnimatedClusterLayer);
          }
          var components_layers = layers_install;
          var SourceXYZvue_type_template_id_1b98d695_hoisted_1 = {
            key: 0
          };
          function SourceXYZvue_type_template_id_1b98d695_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ol_Tile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Tile_Tile = (
            /** @class */
            function(_super) {
              ol_Tile_extends(Tile, _super);
              function Tile(tileCoord, state, opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.tileCoord = tileCoord;
                _this.state = state;
                _this.interimTile = null;
                _this.key = "";
                _this.transition_ = options.transition === void 0 ? 250 : options.transition;
                _this.transitionStarts_ = {};
                return _this;
              }
              Tile.prototype.changed = function() {
                this.dispatchEvent(EventType[
                  "a"
                  /* default */
                ].CHANGE);
              };
              Tile.prototype.release = function() {
              };
              Tile.prototype.getKey = function() {
                return this.key + "/" + this.tileCoord;
              };
              Tile.prototype.getInterimTile = function() {
                if (!this.interimTile) {
                  return this;
                }
                var tile = this.interimTile;
                do {
                  if (tile.getState() == TileState.LOADED) {
                    this.transition_ = 0;
                    return tile;
                  }
                  tile = tile.interimTile;
                } while (tile);
                return this;
              };
              Tile.prototype.refreshInterimChain = function() {
                if (!this.interimTile) {
                  return;
                }
                var tile = this.interimTile;
                var prev = (
                  /** @type {Tile} */
                  this
                );
                do {
                  if (tile.getState() == TileState.LOADED) {
                    tile.interimTile = null;
                    break;
                  } else if (tile.getState() == TileState.LOADING) {
                    prev = tile;
                  } else if (tile.getState() == TileState.IDLE) {
                    prev.interimTile = tile.interimTile;
                  } else {
                    prev = tile;
                  }
                  tile = prev.interimTile;
                } while (tile);
              };
              Tile.prototype.getTileCoord = function() {
                return this.tileCoord;
              };
              Tile.prototype.getState = function() {
                return this.state;
              };
              Tile.prototype.setState = function(state) {
                if (this.state !== TileState.ERROR && this.state > state) {
                  throw new Error("Tile load sequence violation");
                }
                this.state = state;
                this.changed();
              };
              Tile.prototype.load = function() {
                Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              Tile.prototype.getAlpha = function(id, time) {
                if (!this.transition_) {
                  return 1;
                }
                var start = this.transitionStarts_[id];
                if (!start) {
                  start = time;
                  this.transitionStarts_[id] = start;
                } else if (start === -1) {
                  return 1;
                }
                var delta = time - start + 1e3 / 60;
                if (delta >= this.transition_) {
                  return 1;
                }
                return easeIn(delta / this.transition_);
              };
              Tile.prototype.inTransition = function(id) {
                if (!this.transition_) {
                  return false;
                }
                return this.transitionStarts_[id] !== -1;
              };
              Tile.prototype.endTransition = function(id) {
                if (this.transition_) {
                  this.transitionStarts_[id] = -1;
                }
              };
              return Tile;
            }(Target[
              "a"
              /* default */
            ])
          );
          var ol_Tile = Tile_Tile;
          var ImageTile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageTile_ImageTile = (
            /** @class */
            function(_super) {
              ImageTile_extends(ImageTile, _super);
              function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
                var _this = _super.call(this, tileCoord, state, opt_options) || this;
                _this.crossOrigin_ = crossOrigin;
                _this.src_ = src;
                _this.key = src;
                _this.image_ = new Image();
                if (crossOrigin !== null) {
                  _this.image_.crossOrigin = crossOrigin;
                }
                _this.unlisten_ = null;
                _this.tileLoadFunction_ = tileLoadFunction;
                return _this;
              }
              ImageTile.prototype.getImage = function() {
                return this.image_;
              };
              ImageTile.prototype.setImage = function(element) {
                this.image_ = element;
                this.state = TileState.LOADED;
                this.unlistenImage_();
                this.changed();
              };
              ImageTile.prototype.handleImageError_ = function() {
                this.state = TileState.ERROR;
                this.unlistenImage_();
                this.image_ = getBlankImage();
                this.changed();
              };
              ImageTile.prototype.handleImageLoad_ = function() {
                var image = (
                  /** @type {HTMLImageElement} */
                  this.image_
                );
                if (image.naturalWidth && image.naturalHeight) {
                  this.state = TileState.LOADED;
                } else {
                  this.state = TileState.EMPTY;
                }
                this.unlistenImage_();
                this.changed();
              };
              ImageTile.prototype.load = function() {
                if (this.state == TileState.ERROR) {
                  this.state = TileState.IDLE;
                  this.image_ = new Image();
                  if (this.crossOrigin_ !== null) {
                    this.image_.crossOrigin = this.crossOrigin_;
                  }
                }
                if (this.state == TileState.IDLE) {
                  this.state = TileState.LOADING;
                  this.changed();
                  this.tileLoadFunction_(this, this.src_);
                  this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
                }
              };
              ImageTile.prototype.unlistenImage_ = function() {
                if (this.unlisten_) {
                  this.unlisten_();
                  this.unlisten_ = null;
                }
              };
              return ImageTile;
            }(ol_Tile)
          );
          function getBlankImage() {
            var ctx = Object(dom[
              "a"
              /* createCanvasContext2D */
            ])(1, 1);
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0, 0, 1, 1);
            return ctx.canvas;
          }
          var ol_ImageTile = ImageTile_ImageTile;
          var MAX_SUBDIVISION = 10;
          var MAX_TRIANGLE_WIDTH = 0.25;
          var Triangulation_Triangulation = (
            /** @class */
            function() {
              function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
                this.sourceProj_ = sourceProj;
                this.targetProj_ = targetProj;
                var transformInvCache = {};
                var transformInv = getTransform(this.targetProj_, this.sourceProj_);
                this.transformInv_ = function(c) {
                  var key = c[0] + "/" + c[1];
                  if (!transformInvCache[key]) {
                    transformInvCache[key] = transformInv(c);
                  }
                  return transformInvCache[key];
                };
                this.maxSourceExtent_ = maxSourceExtent;
                this.errorThresholdSquared_ = errorThreshold * errorThreshold;
                this.triangles_ = [];
                this.wrapsXInSource_ = false;
                this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
                this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
                this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
                var destinationTopLeft = getTopLeft(targetExtent);
                var destinationTopRight = getTopRight(targetExtent);
                var destinationBottomRight = getBottomRight(targetExtent);
                var destinationBottomLeft = getBottomLeft(targetExtent);
                var sourceTopLeft = this.transformInv_(destinationTopLeft);
                var sourceTopRight = this.transformInv_(destinationTopRight);
                var sourceBottomRight = this.transformInv_(destinationBottomRight);
                var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
                var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
                this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
                if (this.wrapsXInSource_) {
                  var leftBound_1 = Infinity;
                  this.triangles_.forEach(function(triangle, i, arr) {
                    leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
                  });
                  this.triangles_.forEach((function(triangle) {
                    if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
                      var newTriangle = [
                        [triangle.source[0][0], triangle.source[0][1]],
                        [triangle.source[1][0], triangle.source[1][1]],
                        [triangle.source[2][0], triangle.source[2][1]]
                      ];
                      if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[0][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[1][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[2][0] -= this.sourceWorldWidth_;
                      }
                      var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      if (maxX - minX < this.sourceWorldWidth_ / 2) {
                        triangle.source = newTriangle;
                      }
                    }
                  }).bind(this));
                }
                transformInvCache = {};
              }
              Triangulation.prototype.addTriangle_ = function(a, b, c, aSrc, bSrc, cSrc) {
                this.triangles_.push({
                  source: [aSrc, bSrc, cSrc],
                  target: [a, b, c]
                });
              };
              Triangulation.prototype.addQuad_ = function(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
                var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
                var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
                var sourceWorldWidth = (
                  /** @type {number} */
                  this.sourceWorldWidth_
                );
                var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
                var needsSubdivision = false;
                if (maxSubdivision > 0) {
                  if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                    var targetQuadExtent = boundingExtent([a, b, c, d]);
                    var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
                    needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
                  }
                  if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                    needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
                  }
                }
                if (!needsSubdivision && this.maxSourceExtent_) {
                  if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
                    if (!extent_intersects(sourceQuadExtent, this.maxSourceExtent_)) {
                      return;
                    }
                  }
                }
                var isNotFinite = 0;
                if (!needsSubdivision) {
                  if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
                    if (maxSubdivision > 0) {
                      needsSubdivision = true;
                    } else {
                      isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                      if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
                        return;
                      }
                    }
                  }
                }
                if (maxSubdivision > 0) {
                  if (!needsSubdivision) {
                    var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                    var centerSrc = this.transformInv_(center);
                    var dx = void 0;
                    if (wrapsX) {
                      var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
                      dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
                    } else {
                      dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                    }
                    var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                    var centerSrcErrorSquared = dx * dx + dy * dy;
                    needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
                  }
                  if (needsSubdivision) {
                    if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                      var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                      var bcSrc = this.transformInv_(bc);
                      var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                      var daSrc = this.transformInv_(da);
                      this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                      this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                    } else {
                      var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                      var abSrc = this.transformInv_(ab);
                      var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                      var cdSrc = this.transformInv_(cd);
                      this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                      this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                    }
                    return;
                  }
                }
                if (wrapsX) {
                  if (!this.canWrapXInSource_) {
                    return;
                  }
                  this.wrapsXInSource_ = true;
                }
                if ((isNotFinite & 11) == 0) {
                  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
                }
                if ((isNotFinite & 14) == 0) {
                  this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
                }
                if (isNotFinite) {
                  if ((isNotFinite & 13) == 0) {
                    this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
                  }
                  if ((isNotFinite & 7) == 0) {
                    this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
                  }
                }
              };
              Triangulation.prototype.calculateSourceExtent = function() {
                var extent = createEmpty();
                this.triangles_.forEach(function(triangle, i, arr) {
                  var src = triangle.source;
                  extendCoordinate(extent, src[0]);
                  extendCoordinate(extent, src[1]);
                  extendCoordinate(extent, src[2]);
                });
                return extent;
              };
              Triangulation.prototype.getTriangles = function() {
                return this.triangles_;
              };
              return Triangulation;
            }()
          );
          var reproj_Triangulation = Triangulation_Triangulation;
          var DEFAULT_WMS_VERSION = "1.3.0";
          var IMAGE_SMOOTHING_DISABLED = {
            imageSmoothingEnabled: false,
            msImageSmoothingEnabled: false
          };
          var brokenDiagonalRendering_;
          function drawTestTriangle(ctx, u1, v1, u2, v2) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(u1, v1);
            ctx.lineTo(u2, v2);
            ctx.closePath();
            ctx.save();
            ctx.clip();
            ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
            ctx.restore();
          }
          function verifyBrokenDiagonalRendering(data, offset) {
            return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
          }
          function isBrokenDiagonalRendering() {
            if (brokenDiagonalRendering_ === void 0) {
              var ctx = document.createElement("canvas").getContext("2d");
              ctx.globalCompositeOperation = "lighter";
              ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
              drawTestTriangle(ctx, 4, 5, 4, 0);
              drawTestTriangle(ctx, 4, 5, 0, 5);
              var data = ctx.getImageData(0, 0, 3, 3).data;
              brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
            }
            return brokenDiagonalRendering_;
          }
          function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
            var sourceCenter = proj_transform(targetCenter, targetProj, sourceProj);
            var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
            var targetMetersPerUnit = targetProj.getMetersPerUnit();
            if (targetMetersPerUnit !== void 0) {
              sourceResolution *= targetMetersPerUnit;
            }
            var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
            if (sourceMetersPerUnit !== void 0) {
              sourceResolution /= sourceMetersPerUnit;
            }
            var sourceExtent = sourceProj.getExtent();
            if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
              var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
              if (isFinite(compensationFactor) && compensationFactor > 0) {
                sourceResolution /= compensationFactor;
              }
            }
            return sourceResolution;
          }
          function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
            var targetCenter = extent_getCenter(targetExtent);
            var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
            if (!isFinite(sourceResolution) || sourceResolution <= 0) {
              forEachCorner(targetExtent, function(corner) {
                sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
                return isFinite(sourceResolution) && sourceResolution > 0;
              });
            }
            return sourceResolution;
          }
          function reproj_render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {
            var context = Object(dom[
              "a"
              /* createCanvasContext2D */
            ])(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
            Object(ol_obj[
              "a"
              /* assign */
            ])(context, opt_contextOptions);
            if (sources.length === 0) {
              return context.canvas;
            }
            context.scale(pixelRatio, pixelRatio);
            function pixelRound(value) {
              return Math.round(value * pixelRatio) / pixelRatio;
            }
            context.globalCompositeOperation = "lighter";
            var sourceDataExtent = createEmpty();
            sources.forEach(function(src, i, arr) {
              extend2(sourceDataExtent, src.extent);
            });
            var canvasWidthInUnits = getWidth(sourceDataExtent);
            var canvasHeightInUnits = getHeight(sourceDataExtent);
            var stitchContext = Object(dom[
              "a"
              /* createCanvasContext2D */
            ])(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
            Object(ol_obj[
              "a"
              /* assign */
            ])(stitchContext, opt_contextOptions);
            var stitchScale = pixelRatio / sourceResolution;
            sources.forEach(function(src, i, arr) {
              var xPos = src.extent[0] - sourceDataExtent[0];
              var yPos = -(src.extent[3] - sourceDataExtent[3]);
              var srcWidth = getWidth(src.extent);
              var srcHeight = getHeight(src.extent);
              if (src.image.width > 0 && src.image.height > 0) {
                stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
              }
            });
            var targetTopLeft = getTopLeft(targetExtent);
            triangulation.getTriangles().forEach(function(triangle, i, arr) {
              var source = triangle.source;
              var target = triangle.target;
              var x0 = source[0][0], y0 = source[0][1];
              var x1 = source[1][0], y1 = source[1][1];
              var x2 = source[2][0], y2 = source[2][1];
              var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
              var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
              var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
              var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
              var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
              var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
              var sourceNumericalShiftX = x0;
              var sourceNumericalShiftY = y0;
              x0 = 0;
              y0 = 0;
              x1 -= sourceNumericalShiftX;
              y1 -= sourceNumericalShiftY;
              x2 -= sourceNumericalShiftX;
              y2 -= sourceNumericalShiftY;
              var augmentedMatrix = [
                [x1, y1, 0, 0, u1 - u0],
                [x2, y2, 0, 0, u2 - u0],
                [0, 0, x1, y1, v1 - v0],
                [0, 0, x2, y2, v2 - v0]
              ];
              var affineCoefs = solveLinearSystem(augmentedMatrix);
              if (!affineCoefs) {
                return;
              }
              context.save();
              context.beginPath();
              if (isBrokenDiagonalRendering() || opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {
                context.moveTo(u1, v1);
                var steps = 4;
                var ud = u0 - u1;
                var vd = v0 - v1;
                for (var step = 0; step < steps; step++) {
                  context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
                  if (step != steps - 1) {
                    context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
                  }
                }
                context.lineTo(u2, v2);
              } else {
                context.moveTo(u1, v1);
                context.lineTo(u0, v0);
                context.lineTo(u2, v2);
              }
              context.clip();
              context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
              context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
              context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
              context.drawImage(stitchContext.canvas, 0, 0);
              context.restore();
            });
            if (opt_renderEdges) {
              context.save();
              context.globalCompositeOperation = "source-over";
              context.strokeStyle = "black";
              context.lineWidth = 1;
              triangulation.getTriangles().forEach(function(triangle, i, arr) {
                var target = triangle.target;
                var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
                var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
                var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
                var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
                var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
                var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
                context.beginPath();
                context.moveTo(u1, v1);
                context.lineTo(u0, v0);
                context.lineTo(u2, v2);
                context.closePath();
                context.stroke();
              });
              context.restore();
            }
            return context.canvas;
          }
          var reproj_Tile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Tile_ReprojTile = (
            /** @class */
            function(_super) {
              reproj_Tile_extends(ReprojTile, _super);
              function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {
                var _this = _super.call(this, tileCoord, TileState.IDLE) || this;
                _this.renderEdges_ = opt_renderEdges !== void 0 ? opt_renderEdges : false;
                _this.contextOptions_ = opt_contextOptions;
                _this.pixelRatio_ = pixelRatio;
                _this.gutter_ = gutter;
                _this.canvas_ = null;
                _this.sourceTileGrid_ = sourceTileGrid;
                _this.targetTileGrid_ = targetTileGrid;
                _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
                _this.sourceTiles_ = [];
                _this.sourcesListenerKeys_ = null;
                _this.sourceZ_ = 0;
                var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
                var maxTargetExtent = _this.targetTileGrid_.getExtent();
                var maxSourceExtent = _this.sourceTileGrid_.getExtent();
                var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
                if (getArea(limitedTargetExtent) === 0) {
                  _this.state = TileState.EMPTY;
                  return _this;
                }
                var sourceProjExtent = sourceProj.getExtent();
                if (sourceProjExtent) {
                  if (!maxSourceExtent) {
                    maxSourceExtent = sourceProjExtent;
                  } else {
                    maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
                  }
                }
                var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
                var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
                if (!isFinite(sourceResolution) || sourceResolution <= 0) {
                  _this.state = TileState.EMPTY;
                  return _this;
                }
                var errorThresholdInPixels = opt_errorThreshold !== void 0 ? opt_errorThreshold : ERROR_THRESHOLD;
                _this.triangulation_ = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
                if (_this.triangulation_.getTriangles().length === 0) {
                  _this.state = TileState.EMPTY;
                  return _this;
                }
                _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
                var sourceExtent = _this.triangulation_.calculateSourceExtent();
                if (maxSourceExtent) {
                  if (sourceProj.canWrapX()) {
                    sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                    sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
                  } else {
                    sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
                  }
                }
                if (!getArea(sourceExtent)) {
                  _this.state = TileState.EMPTY;
                } else {
                  var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
                  for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                    for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                      var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                      if (tile) {
                        _this.sourceTiles_.push(tile);
                      }
                    }
                  }
                  if (_this.sourceTiles_.length === 0) {
                    _this.state = TileState.EMPTY;
                  }
                }
                return _this;
              }
              ReprojTile.prototype.getImage = function() {
                return this.canvas_;
              };
              ReprojTile.prototype.reproject_ = function() {
                var sources = [];
                this.sourceTiles_.forEach((function(tile, i, arr) {
                  if (tile && tile.getState() == TileState.LOADED) {
                    sources.push({
                      extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                      image: tile.getImage()
                    });
                  }
                }).bind(this));
                this.sourceTiles_.length = 0;
                if (sources.length === 0) {
                  this.state = TileState.ERROR;
                } else {
                  var z = this.wrappedTileCoord_[0];
                  var size = this.targetTileGrid_.getTileSize(z);
                  var width = typeof size === "number" ? size : size[0];
                  var height = typeof size === "number" ? size : size[1];
                  var targetResolution = this.targetTileGrid_.getResolution(z);
                  var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
                  var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
                  this.canvas_ = reproj_render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);
                  this.state = TileState.LOADED;
                }
                this.changed();
              };
              ReprojTile.prototype.load = function() {
                if (this.state == TileState.IDLE) {
                  this.state = TileState.LOADING;
                  this.changed();
                  var leftToLoad_1 = 0;
                  this.sourcesListenerKeys_ = [];
                  this.sourceTiles_.forEach((function(tile, i, arr) {
                    var state = tile.getState();
                    if (state == TileState.IDLE || state == TileState.LOADING) {
                      leftToLoad_1++;
                      var sourceListenKey_1 = Object(events[
                        "a"
                        /* listen */
                      ])(tile, EventType[
                        "a"
                        /* default */
                      ].CHANGE, function(e) {
                        var state2 = tile.getState();
                        if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
                          Object(events[
                            "c"
                            /* unlistenByKey */
                          ])(sourceListenKey_1);
                          leftToLoad_1--;
                          if (leftToLoad_1 === 0) {
                            this.unlistenSources_();
                            this.reproject_();
                          }
                        }
                      }, this);
                      this.sourcesListenerKeys_.push(sourceListenKey_1);
                    }
                  }).bind(this));
                  if (leftToLoad_1 === 0) {
                    setTimeout(this.reproject_.bind(this), 0);
                  } else {
                    this.sourceTiles_.forEach(function(tile, i, arr) {
                      var state = tile.getState();
                      if (state == TileState.IDLE) {
                        tile.load();
                      }
                    });
                  }
                }
              };
              ReprojTile.prototype.unlistenSources_ = function() {
                this.sourcesListenerKeys_.forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                this.sourcesListenerKeys_ = null;
              };
              return ReprojTile;
            }(ol_Tile)
          );
          var reproj_Tile = Tile_ReprojTile;
          var LRUCache_LRUCache = (
            /** @class */
            function() {
              function LRUCache(opt_highWaterMark) {
                this.highWaterMark = opt_highWaterMark !== void 0 ? opt_highWaterMark : 2048;
                this.count_ = 0;
                this.entries_ = {};
                this.oldest_ = null;
                this.newest_ = null;
              }
              LRUCache.prototype.canExpireCache = function() {
                return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
              };
              LRUCache.prototype.clear = function() {
                this.count_ = 0;
                this.entries_ = {};
                this.oldest_ = null;
                this.newest_ = null;
              };
              LRUCache.prototype.containsKey = function(key) {
                return this.entries_.hasOwnProperty(key);
              };
              LRUCache.prototype.forEach = function(f) {
                var entry = this.oldest_;
                while (entry) {
                  f(entry.value_, entry.key_, this);
                  entry = entry.newer;
                }
              };
              LRUCache.prototype.get = function(key, opt_options) {
                var entry = this.entries_[key];
                assert2(entry !== void 0, 15);
                if (entry === this.newest_) {
                  return entry.value_;
                } else if (entry === this.oldest_) {
                  this.oldest_ = /** @type {Entry} */
                  this.oldest_.newer;
                  this.oldest_.older = null;
                } else {
                  entry.newer.older = entry.older;
                  entry.older.newer = entry.newer;
                }
                entry.newer = null;
                entry.older = this.newest_;
                this.newest_.newer = entry;
                this.newest_ = entry;
                return entry.value_;
              };
              LRUCache.prototype.remove = function(key) {
                var entry = this.entries_[key];
                assert2(entry !== void 0, 15);
                if (entry === this.newest_) {
                  this.newest_ = /** @type {Entry} */
                  entry.older;
                  if (this.newest_) {
                    this.newest_.newer = null;
                  }
                } else if (entry === this.oldest_) {
                  this.oldest_ = /** @type {Entry} */
                  entry.newer;
                  if (this.oldest_) {
                    this.oldest_.older = null;
                  }
                } else {
                  entry.newer.older = entry.older;
                  entry.older.newer = entry.newer;
                }
                delete this.entries_[key];
                --this.count_;
                return entry.value_;
              };
              LRUCache.prototype.getCount = function() {
                return this.count_;
              };
              LRUCache.prototype.getKeys = function() {
                var keys = new Array(this.count_);
                var i = 0;
                var entry;
                for (entry = this.newest_; entry; entry = entry.older) {
                  keys[i++] = entry.key_;
                }
                return keys;
              };
              LRUCache.prototype.getValues = function() {
                var values = new Array(this.count_);
                var i = 0;
                var entry;
                for (entry = this.newest_; entry; entry = entry.older) {
                  values[i++] = entry.value_;
                }
                return values;
              };
              LRUCache.prototype.peekLast = function() {
                return this.oldest_.value_;
              };
              LRUCache.prototype.peekLastKey = function() {
                return this.oldest_.key_;
              };
              LRUCache.prototype.peekFirstKey = function() {
                return this.newest_.key_;
              };
              LRUCache.prototype.pop = function() {
                var entry = this.oldest_;
                delete this.entries_[entry.key_];
                if (entry.newer) {
                  entry.newer.older = null;
                }
                this.oldest_ = /** @type {Entry} */
                entry.newer;
                if (!this.oldest_) {
                  this.newest_ = null;
                }
                --this.count_;
                return entry.value_;
              };
              LRUCache.prototype.replace = function(key, value) {
                this.get(key);
                this.entries_[key].value_ = value;
              };
              LRUCache.prototype.set = function(key, value) {
                assert2(!(key in this.entries_), 16);
                var entry = {
                  key_: key,
                  newer: null,
                  older: this.newest_,
                  value_: value
                };
                if (!this.newest_) {
                  this.oldest_ = entry;
                } else {
                  this.newest_.newer = entry;
                }
                this.newest_ = entry;
                this.entries_[key] = entry;
                ++this.count_;
              };
              LRUCache.prototype.setSize = function(size) {
                this.highWaterMark = size;
              };
              return LRUCache;
            }()
          );
          var structs_LRUCache = LRUCache_LRUCache;
          function tilecoord_createOrUpdate(z, x, y, opt_tileCoord) {
            if (opt_tileCoord !== void 0) {
              opt_tileCoord[0] = z;
              opt_tileCoord[1] = x;
              opt_tileCoord[2] = y;
              return opt_tileCoord;
            } else {
              return [z, x, y];
            }
          }
          function getKeyZXY(z, x, y) {
            return z + "/" + x + "/" + y;
          }
          function tilecoord_getKey(tileCoord) {
            return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
          }
          function getCacheKeyForTileKey(tileKey) {
            var _a = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number), z = _a[0], x = _a[1], y = _a[2];
            return getKeyZXY(z, x, y);
          }
          function fromKey(key) {
            return key.split("/").map(Number);
          }
          function hash(tileCoord) {
            return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
          }
          function withinExtentAndZ(tileCoord, tileGrid) {
            var z = tileCoord[0];
            var x = tileCoord[1];
            var y = tileCoord[2];
            if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
              return false;
            }
            var tileRange = tileGrid.getFullTileRange(z);
            if (!tileRange) {
              return true;
            } else {
              return tileRange.containsXY(x, y);
            }
          }
          var TileCache_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TileCache_TileCache = (
            /** @class */
            function(_super) {
              TileCache_extends(TileCache, _super);
              function TileCache() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              TileCache.prototype.expireCache = function(usedTiles) {
                while (this.canExpireCache()) {
                  var tile = this.peekLast();
                  if (tile.getKey() in usedTiles) {
                    break;
                  } else {
                    this.pop().release();
                  }
                }
              };
              TileCache.prototype.pruneExceptNewestZ = function() {
                if (this.getCount() === 0) {
                  return;
                }
                var key = this.peekFirstKey();
                var tileCoord = fromKey(key);
                var z = tileCoord[0];
                this.forEach((function(tile) {
                  if (tile.tileCoord[0] !== z) {
                    this.remove(tilecoord_getKey(tile.tileCoord));
                    tile.release();
                  }
                }).bind(this));
              };
              return TileCache;
            }(structs_LRUCache)
          );
          var ol_TileCache = TileCache_TileCache;
          var TileEventType = {
            /**
             * Triggered when a tile starts loading.
             * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
             * @api
             */
            TILELOADSTART: "tileloadstart",
            /**
             * Triggered when a tile finishes loading, either when its data is loaded,
             * or when loading was aborted because the tile is no longer needed.
             * @event module:ol/source/Tile.TileSourceEvent#tileloadend
             * @api
             */
            TILELOADEND: "tileloadend",
            /**
             * Triggered if tile loading results in an error.
             * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
             * @api
             */
            TILELOADERROR: "tileloaderror"
          };
          var tmpTileCoord = [0, 0, 0];
          var TileGrid_TileGrid = (
            /** @class */
            function() {
              function TileGrid(options) {
                this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
                this.resolutions_ = options.resolutions;
                assert2(Object(ol_array[
                  "g"
                  /* isSorted */
                ])(this.resolutions_, function(a, b) {
                  return b - a;
                }, true), 17);
                var zoomFactor;
                if (!options.origins) {
                  for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                    if (!zoomFactor) {
                      zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                    } else {
                      if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                        zoomFactor = void 0;
                        break;
                      }
                    }
                  }
                }
                this.zoomFactor_ = zoomFactor;
                this.maxZoom = this.resolutions_.length - 1;
                this.origin_ = options.origin !== void 0 ? options.origin : null;
                this.origins_ = null;
                if (options.origins !== void 0) {
                  this.origins_ = options.origins;
                  assert2(this.origins_.length == this.resolutions_.length, 20);
                }
                var extent = options.extent;
                if (extent !== void 0 && !this.origin_ && !this.origins_) {
                  this.origin_ = getTopLeft(extent);
                }
                assert2(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
                this.tileSizes_ = null;
                if (options.tileSizes !== void 0) {
                  this.tileSizes_ = options.tileSizes;
                  assert2(this.tileSizes_.length == this.resolutions_.length, 19);
                }
                this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
                assert2(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
                this.extent_ = extent !== void 0 ? extent : null;
                this.fullTileRanges_ = null;
                this.tmpSize_ = [0, 0];
                this.tmpExtent_ = [0, 0, 0, 0];
                if (options.sizes !== void 0) {
                  this.fullTileRanges_ = options.sizes.map(function(size, z) {
                    var tileRange = new ol_TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                    if (extent) {
                      var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                      tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                      tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                      tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                      tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
                    }
                    return tileRange;
                  }, this);
                } else if (extent) {
                  this.calculateTileRanges_(extent);
                }
              }
              TileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {
                var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
                for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
                  for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                    callback([zoom, i, j]);
                  }
                }
              };
              TileGrid.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {
                var tileRange, x, y;
                var tileCoordExtent = null;
                var z = tileCoord[0] - 1;
                if (this.zoomFactor_ === 2) {
                  x = tileCoord[1];
                  y = tileCoord[2];
                } else {
                  tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
                }
                while (z >= this.minZoom) {
                  if (this.zoomFactor_ === 2) {
                    x = Math.floor(x / 2);
                    y = Math.floor(y / 2);
                    tileRange = TileRange_createOrUpdate(x, x, y, y, opt_tileRange);
                  } else {
                    tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
                  }
                  if (callback(z, tileRange)) {
                    return true;
                  }
                  --z;
                }
                return false;
              };
              TileGrid.prototype.getExtent = function() {
                return this.extent_;
              };
              TileGrid.prototype.getMaxZoom = function() {
                return this.maxZoom;
              };
              TileGrid.prototype.getMinZoom = function() {
                return this.minZoom;
              };
              TileGrid.prototype.getOrigin = function(z) {
                if (this.origin_) {
                  return this.origin_;
                } else {
                  return this.origins_[z];
                }
              };
              TileGrid.prototype.getResolution = function(z) {
                return this.resolutions_[z];
              };
              TileGrid.prototype.getResolutions = function() {
                return this.resolutions_;
              };
              TileGrid.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
                if (tileCoord[0] < this.maxZoom) {
                  if (this.zoomFactor_ === 2) {
                    var minX = tileCoord[1] * 2;
                    var minY = tileCoord[2] * 2;
                    return TileRange_createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
                  }
                  var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
                  return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
                }
                return null;
              };
              TileGrid.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z, opt_tileRange) {
                if (z > this.maxZoom || z < this.minZoom) {
                  return null;
                }
                var tileCoordZ = tileCoord[0];
                var tileCoordX = tileCoord[1];
                var tileCoordY = tileCoord[2];
                if (z === tileCoordZ) {
                  return TileRange_createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
                }
                if (this.zoomFactor_) {
                  var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
                  var minX = Math.floor(tileCoordX * factor);
                  var minY = Math.floor(tileCoordY * factor);
                  if (z < tileCoordZ) {
                    return TileRange_createOrUpdate(minX, minX, minY, minY, opt_tileRange);
                  }
                  var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
                  var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
                  return TileRange_createOrUpdate(minX, maxX, minY, maxY, opt_tileRange);
                }
                var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
                return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
              };
              TileGrid.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {
                var origin = this.getOrigin(z);
                var resolution = this.getResolution(z);
                var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
                var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
                var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
                var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
                var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
                return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
              };
              TileGrid.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {
                var tileCoord = tmpTileCoord;
                this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
                var minX = tileCoord[1];
                var minY = tileCoord[2];
                this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
                return TileRange_createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
              };
              TileGrid.prototype.getTileCoordCenter = function(tileCoord) {
                var origin = this.getOrigin(tileCoord[0]);
                var resolution = this.getResolution(tileCoord[0]);
                var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
                return [
                  origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
                  origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
                ];
              };
              TileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
                var origin = this.getOrigin(tileCoord[0]);
                var resolution = this.getResolution(tileCoord[0]);
                var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
                var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
                var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
                var maxX = minX + tileSize[0] * resolution;
                var maxY = minY + tileSize[1] * resolution;
                return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
              };
              TileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
                return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
              };
              TileGrid.prototype.getTileCoordForXYAndResolution_ = function(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
                var z = this.getZForResolution(resolution);
                var scale = resolution / this.getResolution(z);
                var origin = this.getOrigin(z);
                var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
                var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
                var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
                var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
                var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
                var tileCoordX = scale * xFromOrigin / tileSize[0];
                var tileCoordY = scale * yFromOrigin / tileSize[1];
                if (reverseIntersectionPolicy) {
                  tileCoordX = Math.ceil(tileCoordX) - 1;
                  tileCoordY = Math.ceil(tileCoordY) - 1;
                } else {
                  tileCoordX = Math.floor(tileCoordX);
                  tileCoordY = Math.floor(tileCoordY);
                }
                return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
              };
              TileGrid.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
                var origin = this.getOrigin(z);
                var resolution = this.getResolution(z);
                var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
                var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
                var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
                var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
                var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
                var tileCoordX = xFromOrigin / tileSize[0];
                var tileCoordY = yFromOrigin / tileSize[1];
                if (reverseIntersectionPolicy) {
                  tileCoordX = Math.ceil(tileCoordX) - 1;
                  tileCoordY = Math.ceil(tileCoordY) - 1;
                } else {
                  tileCoordX = Math.floor(tileCoordX);
                  tileCoordY = Math.floor(tileCoordY);
                }
                return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
              };
              TileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {
                return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
              };
              TileGrid.prototype.getTileCoordResolution = function(tileCoord) {
                return this.resolutions_[tileCoord[0]];
              };
              TileGrid.prototype.getTileSize = function(z) {
                if (this.tileSize_) {
                  return this.tileSize_;
                } else {
                  return this.tileSizes_[z];
                }
              };
              TileGrid.prototype.getFullTileRange = function(z) {
                if (!this.fullTileRanges_) {
                  return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
                } else {
                  return this.fullTileRanges_[z];
                }
              };
              TileGrid.prototype.getZForResolution = function(resolution, opt_direction) {
                var z = Object(ol_array[
                  "h"
                  /* linearFindNearest */
                ])(this.resolutions_, resolution, opt_direction || 0);
                return clamp(z, this.minZoom, this.maxZoom);
              };
              TileGrid.prototype.calculateTileRanges_ = function(extent) {
                var length = this.resolutions_.length;
                var fullTileRanges = new Array(length);
                for (var z = this.minZoom; z < length; ++z) {
                  fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
                }
                this.fullTileRanges_ = fullTileRanges;
              };
              return TileGrid;
            }()
          );
          var tilegrid_TileGrid = TileGrid_TileGrid;
          function getForProjection(projection) {
            var tileGrid = projection.getDefaultTileGrid();
            if (!tileGrid) {
              tileGrid = createForProjection(projection);
              projection.setDefaultTileGrid(tileGrid);
            }
            return tileGrid;
          }
          function tilegrid_wrapX(tileGrid, tileCoord, projection) {
            var z = tileCoord[0];
            var center = tileGrid.getTileCoordCenter(tileCoord);
            var projectionExtent = extentFromProjection(projection);
            if (!containsCoordinate(projectionExtent, center)) {
              var worldWidth = getWidth(projectionExtent);
              var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
              center[0] += worldWidth * worldsAway;
              return tileGrid.getTileCoordForCoordAndZ(center, z);
            } else {
              return tileCoord;
            }
          }
          function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
            var corner = opt_corner !== void 0 ? opt_corner : Corner.TOP_LEFT;
            var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
            return new tilegrid_TileGrid({
              extent,
              origin: getCorner(extent, corner),
              resolutions,
              tileSize: opt_tileSize
            });
          }
          function createXYZ(opt_options) {
            var xyzOptions = opt_options || {};
            var extent = xyzOptions.extent || proj_get("EPSG:3857").getExtent();
            var gridOptions = {
              extent,
              minZoom: xyzOptions.minZoom,
              tileSize: xyzOptions.tileSize,
              resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
            };
            return new tilegrid_TileGrid(gridOptions);
          }
          function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
            var maxZoom = opt_maxZoom !== void 0 ? opt_maxZoom : DEFAULT_MAX_ZOOM;
            var height = getHeight(extent);
            var width = getWidth(extent);
            var tileSize = toSize(opt_tileSize !== void 0 ? opt_tileSize : DEFAULT_TILE_SIZE);
            var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
            var length = maxZoom + 1;
            var resolutions = new Array(length);
            for (var z = 0; z < length; ++z) {
              resolutions[z] = maxResolution / Math.pow(2, z);
            }
            return resolutions;
          }
          function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
            var extent = extentFromProjection(projection);
            return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
          }
          function extentFromProjection(projection) {
            projection = proj_get(projection);
            var extent = projection.getExtent();
            if (!extent) {
              var half = 180 * METERS_PER_UNIT[proj_Units.DEGREES] / projection.getMetersPerUnit();
              extent = createOrUpdate(-half, -half, half, half);
            }
            return extent;
          }
          var source_Tile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Tile_TileSource = (
            /** @class */
            function(_super) {
              source_Tile_extends(TileSource, _super);
              function TileSource(options) {
                var _this = _super.call(this, {
                  attributions: options.attributions,
                  attributionsCollapsible: options.attributionsCollapsible,
                  projection: options.projection,
                  state: options.state,
                  wrapX: options.wrapX
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
                _this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
                _this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
                var tileSize = [256, 256];
                var tileGrid = options.tileGrid;
                if (tileGrid) {
                  toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
                }
                _this.tileCache = new ol_TileCache(options.cacheSize || 0);
                _this.tmpSize = [0, 0];
                _this.key_ = options.key || "";
                _this.tileOptions = { transition: options.transition };
                _this.zDirection = options.zDirection ? options.zDirection : 0;
                return _this;
              }
              TileSource.prototype.canExpireCache = function() {
                return this.tileCache.canExpireCache();
              };
              TileSource.prototype.expireCache = function(projection, usedTiles) {
                var tileCache = this.getTileCacheForProjection(projection);
                if (tileCache) {
                  tileCache.expireCache(usedTiles);
                }
              };
              TileSource.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {
                var tileCache = this.getTileCacheForProjection(projection);
                if (!tileCache) {
                  return false;
                }
                var covered = true;
                var tile, tileCoordKey, loaded;
                for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
                  for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                    tileCoordKey = getKeyZXY(z, x, y);
                    loaded = false;
                    if (tileCache.containsKey(tileCoordKey)) {
                      tile = /** @type {!import("../Tile.js").default} */
                      tileCache.get(tileCoordKey);
                      loaded = tile.getState() === TileState.LOADED;
                      if (loaded) {
                        loaded = callback(tile) !== false;
                      }
                    }
                    if (!loaded) {
                      covered = false;
                    }
                  }
                }
                return covered;
              };
              TileSource.prototype.getGutterForProjection = function(projection) {
                return 0;
              };
              TileSource.prototype.getKey = function() {
                return this.key_;
              };
              TileSource.prototype.setKey = function(key) {
                if (this.key_ !== key) {
                  this.key_ = key;
                  this.changed();
                }
              };
              TileSource.prototype.getOpaque = function(projection) {
                return this.opaque_;
              };
              TileSource.prototype.getResolutions = function() {
                return this.tileGrid.getResolutions();
              };
              TileSource.prototype.getTile = function(z, x, y, pixelRatio, projection) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TileSource.prototype.getTileGrid = function() {
                return this.tileGrid;
              };
              TileSource.prototype.getTileGridForProjection = function(projection) {
                if (!this.tileGrid) {
                  return getForProjection(projection);
                } else {
                  return this.tileGrid;
                }
              };
              TileSource.prototype.getTileCacheForProjection = function(projection) {
                assert2(
                  equivalent(this.getProjection(), projection),
                  68
                  // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
                );
                return this.tileCache;
              };
              TileSource.prototype.getTilePixelRatio = function(pixelRatio) {
                return this.tilePixelRatio_;
              };
              TileSource.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
                var tileGrid = this.getTileGridForProjection(projection);
                var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
                var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
                if (tilePixelRatio == 1) {
                  return tileSize;
                } else {
                  return size_scale(tileSize, tilePixelRatio, this.tmpSize);
                }
              };
              TileSource.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
                var projection = opt_projection !== void 0 ? opt_projection : this.getProjection();
                var tileGrid = this.getTileGridForProjection(projection);
                if (this.getWrapX() && projection.isGlobal()) {
                  tileCoord = tilegrid_wrapX(tileGrid, tileCoord, projection);
                }
                return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
              };
              TileSource.prototype.clear = function() {
                this.tileCache.clear();
              };
              TileSource.prototype.refresh = function() {
                this.clear();
                _super.prototype.refresh.call(this);
              };
              TileSource.prototype.updateCacheSize = function(tileCount, projection) {
                var tileCache = this.getTileCacheForProjection(projection);
                if (tileCount > tileCache.highWaterMark) {
                  tileCache.highWaterMark = tileCount;
                }
              };
              TileSource.prototype.useTile = function(z, x, y, projection) {
              };
              return TileSource;
            }(source_Source)
          );
          var TileSourceEvent = (
            /** @class */
            function(_super) {
              source_Tile_extends(TileSourceEvent2, _super);
              function TileSourceEvent2(type, tile) {
                var _this = _super.call(this, type) || this;
                _this.tile = tile;
                return _this;
              }
              return TileSourceEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var source_Tile = Tile_TileSource;
          function createFromTemplate(template, tileGrid) {
            var zRegEx = /\{z\}/g;
            var xRegEx = /\{x\}/g;
            var yRegEx = /\{y\}/g;
            var dashYRegEx = /\{-y\}/g;
            return (
              /**
               * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
               * @param {number} pixelRatio Pixel ratio.
               * @param {import("./proj/Projection.js").default} projection Projection.
               * @return {string|undefined} Tile URL.
               */
              function(tileCoord, pixelRatio, projection) {
                if (!tileCoord) {
                  return void 0;
                } else {
                  return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
                    var z = tileCoord[0];
                    var range = tileGrid.getFullTileRange(z);
                    assert2(range, 55);
                    var y = range.getHeight() - tileCoord[2] - 1;
                    return y.toString();
                  });
                }
              }
            );
          }
          function createFromTemplates(templates, tileGrid) {
            var len = templates.length;
            var tileUrlFunctions = new Array(len);
            for (var i = 0; i < len; ++i) {
              tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
            }
            return createFromTileUrlFunctions(tileUrlFunctions);
          }
          function createFromTileUrlFunctions(tileUrlFunctions) {
            if (tileUrlFunctions.length === 1) {
              return tileUrlFunctions[0];
            }
            return (
              /**
               * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
               * @param {number} pixelRatio Pixel ratio.
               * @param {import("./proj/Projection.js").default} projection Projection.
               * @return {string|undefined} Tile URL.
               */
              function(tileCoord, pixelRatio, projection) {
                if (!tileCoord) {
                  return void 0;
                } else {
                  var h = hash(tileCoord);
                  var index = modulo(h, tileUrlFunctions.length);
                  return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
                }
              }
            );
          }
          function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
            return void 0;
          }
          function expandUrl(url) {
            var urls = [];
            var match = /\{([a-z])-([a-z])\}/.exec(url);
            if (match) {
              var startCharCode = match[1].charCodeAt(0);
              var stopCharCode = match[2].charCodeAt(0);
              var charCode = void 0;
              for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
                urls.push(url.replace(match[0], String.fromCharCode(charCode)));
              }
              return urls;
            }
            match = /\{(\d+)-(\d+)\}/.exec(url);
            if (match) {
              var stop_1 = parseInt(match[2], 10);
              for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
                urls.push(url.replace(match[0], i.toString()));
              }
              return urls;
            }
            urls.push(url);
            return urls;
          }
          var UrlTile_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var UrlTile_UrlTile = (
            /** @class */
            function(_super) {
              UrlTile_extends(UrlTile, _super);
              function UrlTile(options) {
                var _this = _super.call(this, {
                  attributions: options.attributions,
                  cacheSize: options.cacheSize,
                  opaque: options.opaque,
                  projection: options.projection,
                  state: options.state,
                  tileGrid: options.tileGrid,
                  tilePixelRatio: options.tilePixelRatio,
                  wrapX: options.wrapX,
                  transition: options.transition,
                  key: options.key,
                  attributionsCollapsible: options.attributionsCollapsible,
                  zDirection: options.zDirection
                }) || this;
                _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
                _this.tileLoadFunction = options.tileLoadFunction;
                if (options.tileUrlFunction) {
                  _this.tileUrlFunction = options.tileUrlFunction;
                }
                _this.urls = null;
                if (options.urls) {
                  _this.setUrls(options.urls);
                } else if (options.url) {
                  _this.setUrl(options.url);
                }
                _this.tileLoadingKeys_ = {};
                return _this;
              }
              UrlTile.prototype.getTileLoadFunction = function() {
                return this.tileLoadFunction;
              };
              UrlTile.prototype.getTileUrlFunction = function() {
                return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
              };
              UrlTile.prototype.getUrls = function() {
                return this.urls;
              };
              UrlTile.prototype.handleTileChange = function(event) {
                var tile = (
                  /** @type {import("../Tile.js").default} */
                  event.target
                );
                var uid = Object(util[
                  "c"
                  /* getUid */
                ])(tile);
                var tileState = tile.getState();
                var type;
                if (tileState == TileState.LOADING) {
                  this.tileLoadingKeys_[uid] = true;
                  type = TileEventType.TILELOADSTART;
                } else if (uid in this.tileLoadingKeys_) {
                  delete this.tileLoadingKeys_[uid];
                  type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
                }
                if (type != void 0) {
                  this.dispatchEvent(new TileSourceEvent(type, tile));
                }
              };
              UrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {
                this.tileCache.clear();
                this.tileLoadFunction = tileLoadFunction;
                this.changed();
              };
              UrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, key) {
                this.tileUrlFunction = tileUrlFunction;
                this.tileCache.pruneExceptNewestZ();
                if (typeof key !== "undefined") {
                  this.setKey(key);
                } else {
                  this.changed();
                }
              };
              UrlTile.prototype.setUrl = function(url) {
                var urls = expandUrl(url);
                this.urls = urls;
                this.setUrls(urls);
              };
              UrlTile.prototype.setUrls = function(urls) {
                this.urls = urls;
                var key = urls.join("\n");
                if (this.generateTileUrlFunction_) {
                  this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
                } else {
                  this.setKey(key);
                }
              };
              UrlTile.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
                return void 0;
              };
              UrlTile.prototype.useTile = function(z, x, y) {
                var tileCoordKey = getKeyZXY(z, x, y);
                if (this.tileCache.containsKey(tileCoordKey)) {
                  this.tileCache.get(tileCoordKey);
                }
              };
              return UrlTile;
            }(source_Tile)
          );
          var source_UrlTile = UrlTile_UrlTile;
          var TileImage_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TileImage_TileImage = (
            /** @class */
            function(_super) {
              TileImage_extends(TileImage, _super);
              function TileImage(options) {
                var _this = _super.call(this, {
                  attributions: options.attributions,
                  cacheSize: options.cacheSize,
                  opaque: options.opaque,
                  projection: options.projection,
                  state: options.state,
                  tileGrid: options.tileGrid,
                  tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
                  tilePixelRatio: options.tilePixelRatio,
                  tileUrlFunction: options.tileUrlFunction,
                  url: options.url,
                  urls: options.urls,
                  wrapX: options.wrapX,
                  transition: options.transition,
                  key: options.key,
                  attributionsCollapsible: options.attributionsCollapsible,
                  zDirection: options.zDirection
                }) || this;
                _this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
                _this.tileClass = options.tileClass !== void 0 ? options.tileClass : ol_ImageTile;
                _this.tileCacheForProjection = {};
                _this.tileGridForProjection = {};
                _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
                _this.contextOptions_ = options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : void 0;
                _this.renderReprojectionEdges_ = false;
                return _this;
              }
              TileImage.prototype.canExpireCache = function() {
                if (!ENABLE_RASTER_REPROJECTION) {
                  return _super.prototype.canExpireCache.call(this);
                }
                if (this.tileCache.canExpireCache()) {
                  return true;
                } else {
                  for (var key in this.tileCacheForProjection) {
                    if (this.tileCacheForProjection[key].canExpireCache()) {
                      return true;
                    }
                  }
                }
                return false;
              };
              TileImage.prototype.expireCache = function(projection, usedTiles) {
                if (!ENABLE_RASTER_REPROJECTION) {
                  _super.prototype.expireCache.call(this, projection, usedTiles);
                  return;
                }
                var usedTileCache = this.getTileCacheForProjection(projection);
                this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
                for (var id in this.tileCacheForProjection) {
                  var tileCache = this.tileCacheForProjection[id];
                  tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
                }
              };
              TileImage.prototype.getContextOptions = function() {
                return this.contextOptions_;
              };
              TileImage.prototype.getGutterForProjection = function(projection) {
                if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
                  return 0;
                } else {
                  return this.getGutter();
                }
              };
              TileImage.prototype.getGutter = function() {
                return 0;
              };
              TileImage.prototype.getKey = function() {
                return _super.prototype.getKey.call(this) + (this.contextOptions_ ? "\n" + JSON.stringify(this.contextOptions_) : "");
              };
              TileImage.prototype.getOpaque = function(projection) {
                if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
                  return false;
                } else {
                  return _super.prototype.getOpaque.call(this, projection);
                }
              };
              TileImage.prototype.getTileGridForProjection = function(projection) {
                if (!ENABLE_RASTER_REPROJECTION) {
                  return _super.prototype.getTileGridForProjection.call(this, projection);
                }
                var thisProj = this.getProjection();
                if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
                  return this.tileGrid;
                } else {
                  var projKey = Object(util[
                    "c"
                    /* getUid */
                  ])(projection);
                  if (!(projKey in this.tileGridForProjection)) {
                    this.tileGridForProjection[projKey] = getForProjection(projection);
                  }
                  return this.tileGridForProjection[projKey];
                }
              };
              TileImage.prototype.getTileCacheForProjection = function(projection) {
                if (!ENABLE_RASTER_REPROJECTION) {
                  return _super.prototype.getTileCacheForProjection.call(this, projection);
                }
                var thisProj = this.getProjection();
                if (!thisProj || equivalent(thisProj, projection)) {
                  return this.tileCache;
                } else {
                  var projKey = Object(util[
                    "c"
                    /* getUid */
                  ])(projection);
                  if (!(projKey in this.tileCacheForProjection)) {
                    this.tileCacheForProjection[projKey] = new ol_TileCache(this.tileCache.highWaterMark);
                  }
                  return this.tileCacheForProjection[projKey];
                }
              };
              TileImage.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {
                var tileCoord = [z, x, y];
                var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
                var tile = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
                tile.key = key;
                tile.addEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, this.handleTileChange.bind(this));
                return tile;
              };
              TileImage.prototype.getTile = function(z, x, y, pixelRatio, projection) {
                var sourceProjection = this.getProjection();
                if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
                  return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
                } else {
                  var cache = this.getTileCacheForProjection(projection);
                  var tileCoord = [z, x, y];
                  var tile = void 0;
                  var tileCoordKey = tilecoord_getKey(tileCoord);
                  if (cache.containsKey(tileCoordKey)) {
                    tile = cache.get(tileCoordKey);
                  }
                  var key = this.getKey();
                  if (tile && tile.key == key) {
                    return tile;
                  } else {
                    var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                    var targetTileGrid = this.getTileGridForProjection(projection);
                    var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                    var newTile = new reproj_Tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), (function(z2, x2, y2, pixelRatio2) {
                      return this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection);
                    }).bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);
                    newTile.key = key;
                    if (tile) {
                      newTile.interimTile = tile;
                      newTile.refreshInterimChain();
                      cache.replace(tileCoordKey, newTile);
                    } else {
                      cache.set(tileCoordKey, newTile);
                    }
                    return newTile;
                  }
                }
              };
              TileImage.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {
                var tile = null;
                var tileCoordKey = getKeyZXY(z, x, y);
                var key = this.getKey();
                if (!this.tileCache.containsKey(tileCoordKey)) {
                  tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                  this.tileCache.set(tileCoordKey, tile);
                } else {
                  tile = this.tileCache.get(tileCoordKey);
                  if (tile.key != key) {
                    var interimTile = tile;
                    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                    if (interimTile.getState() == TileState.IDLE) {
                      tile.interimTile = interimTile.interimTile;
                    } else {
                      tile.interimTile = interimTile;
                    }
                    tile.refreshInterimChain();
                    this.tileCache.replace(tileCoordKey, tile);
                  }
                }
                return tile;
              };
              TileImage.prototype.setRenderReprojectionEdges = function(render) {
                if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
                  return;
                }
                this.renderReprojectionEdges_ = render;
                for (var id in this.tileCacheForProjection) {
                  this.tileCacheForProjection[id].clear();
                }
                this.changed();
              };
              TileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {
                if (ENABLE_RASTER_REPROJECTION) {
                  var proj = proj_get(projection);
                  if (proj) {
                    var projKey = Object(util[
                      "c"
                      /* getUid */
                    ])(proj);
                    if (!(projKey in this.tileGridForProjection)) {
                      this.tileGridForProjection[projKey] = tilegrid;
                    }
                  }
                }
              };
              return TileImage;
            }(source_UrlTile)
          );
          function defaultTileLoadFunction(imageTile, src) {
            imageTile.getImage().src = src;
          }
          var source_TileImage = TileImage_TileImage;
          var XYZ_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var XYZ_XYZ = (
            /** @class */
            function(_super) {
              XYZ_extends(XYZ, _super);
              function XYZ(opt_options) {
                var _this = this;
                var options = opt_options || {};
                var projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
                var tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
                  extent: extentFromProjection(projection),
                  maxResolution: options.maxResolution,
                  maxZoom: options.maxZoom,
                  minZoom: options.minZoom,
                  tileSize: options.tileSize
                });
                _this = _super.call(this, {
                  attributions: options.attributions,
                  cacheSize: options.cacheSize,
                  crossOrigin: options.crossOrigin,
                  imageSmoothing: options.imageSmoothing,
                  opaque: options.opaque,
                  projection,
                  reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                  tileGrid,
                  tileLoadFunction: options.tileLoadFunction,
                  tilePixelRatio: options.tilePixelRatio,
                  tileUrlFunction: options.tileUrlFunction,
                  url: options.url,
                  urls: options.urls,
                  wrapX: options.wrapX !== void 0 ? options.wrapX : true,
                  transition: options.transition,
                  attributionsCollapsible: options.attributionsCollapsible,
                  zDirection: options.zDirection
                }) || this;
                return _this;
              }
              return XYZ;
            }(source_TileImage)
          );
          var source_XYZ = XYZ_XYZ;
          var SourceXYZvue_type_script_lang_js = {
            name: "ol-source-xyz",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new source_XYZ(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.value.setSource(null);
              });
              return {
                layer,
                source
              };
            },
            props: {
              url: {
                type: String
              },
              cacheSize: {
                type: Number,
                default: 2048
              },
              crossOrigin: {
                type: String
              },
              maxZoom: {
                type: Number,
                default: 28
              },
              minZoom: {
                type: Number,
                default: 0
              },
              opaque: {
                type: Boolean
              },
              projection: {
                type: String,
                default: "EPSG:3857"
              },
              reprojectionErrorThreshold: {
                type: Number,
                default: 0.5
              },
              tileSize: {
                type: Array,
                default: function _default() {
                  return [256, 256];
                }
              },
              tilePixelRatio: {
                type: Number,
                default: 1
              },
              tileKey: {
                type: String
              },
              transition: {
                type: Number
              }
            }
          };
          SourceXYZvue_type_script_lang_js.render = SourceXYZvue_type_template_id_1b98d695_render;
          var SourceXYZ = SourceXYZvue_type_script_lang_js;
          var SourceOSMvue_type_template_id_ab26ab7a_hoisted_1 = {
            key: 0
          };
          function SourceOSMvue_type_template_id_ab26ab7a_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var OSM_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
          var OSM = (
            /** @class */
            function(_super) {
              OSM_extends(OSM2, _super);
              function OSM2(opt_options) {
                var _this = this;
                var options = opt_options || {};
                var attributions;
                if (options.attributions !== void 0) {
                  attributions = options.attributions;
                } else {
                  attributions = [ATTRIBUTION];
                }
                var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
                var url = options.url !== void 0 ? options.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
                _this = _super.call(this, {
                  attributions,
                  attributionsCollapsible: false,
                  cacheSize: options.cacheSize,
                  crossOrigin,
                  imageSmoothing: options.imageSmoothing,
                  maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
                  opaque: options.opaque !== void 0 ? options.opaque : true,
                  reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                  tileLoadFunction: options.tileLoadFunction,
                  transition: options.transition,
                  url,
                  wrapX: options.wrapX,
                  zDirection: options.zDirection
                }) || this;
                return _this;
              }
              return OSM2;
            }(source_XYZ)
          );
          var source_OSM = OSM;
          var SourceOSMvue_type_script_lang_js = {
            name: "ol-source-osm",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new source_OSM(properties);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.value.setSource(null);
              });
              return {
                layer,
                source
              };
            },
            props: {
              attributions: {
                type: String
              },
              cacheSize: {
                type: Number,
                default: 2048
              },
              crossOrigin: {
                type: String,
                default: "anonymous"
              },
              imageSmoothing: {
                type: Boolean,
                default: true
              },
              minZoom: {
                type: Number,
                default: 0
              },
              maxZoom: {
                type: Number,
                default: 19
              },
              opaque: {
                type: Boolean,
                default: true
              },
              reprojectionErrorThreshold: {
                type: Number,
                default: 0.5
              },
              transition: {
                type: Number,
                default: 250
              },
              url: {
                type: String,
                default: "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              },
              wrapX: {
                type: Boolean,
                default: true
              }
            }
          };
          SourceOSMvue_type_script_lang_js.render = SourceOSMvue_type_template_id_ab26ab7a_render;
          var SourceOSM = SourceOSMvue_type_script_lang_js;
          var SourceImageStaticvue_type_template_id_80caf7c2_hoisted_1 = {
            key: 0
          };
          function SourceImageStaticvue_type_template_id_80caf7c2_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var reproj_Image_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Image_ReprojImage = (
            /** @class */
            function(_super) {
              reproj_Image_extends(ReprojImage, _super);
              function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, opt_contextOptions) {
                var _this = this;
                var maxSourceExtent = sourceProj.getExtent();
                var maxTargetExtent = targetProj.getExtent();
                var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
                var targetCenter = extent_getCenter(limitedTargetExtent);
                var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
                var errorThresholdInPixels = ERROR_THRESHOLD;
                var triangulation = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
                var sourceExtent = triangulation.calculateSourceExtent();
                var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
                var state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;
                var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
                _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
                _this.targetProj_ = targetProj;
                _this.maxSourceExtent_ = maxSourceExtent;
                _this.triangulation_ = triangulation;
                _this.targetResolution_ = targetResolution;
                _this.targetExtent_ = targetExtent;
                _this.sourceImage_ = sourceImage;
                _this.sourcePixelRatio_ = sourcePixelRatio;
                _this.contextOptions_ = opt_contextOptions;
                _this.canvas_ = null;
                _this.sourceListenerKey_ = null;
                return _this;
              }
              ReprojImage.prototype.disposeInternal = function() {
                if (this.state == ImageState.LOADING) {
                  this.unlistenSource_();
                }
                _super.prototype.disposeInternal.call(this);
              };
              ReprojImage.prototype.getImage = function() {
                return this.canvas_;
              };
              ReprojImage.prototype.getProjection = function() {
                return this.targetProj_;
              };
              ReprojImage.prototype.reproject_ = function() {
                var sourceState = this.sourceImage_.getState();
                if (sourceState == ImageState.LOADED) {
                  var width = getWidth(this.targetExtent_) / this.targetResolution_;
                  var height = getHeight(this.targetExtent_) / this.targetResolution_;
                  this.canvas_ = reproj_render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                    {
                      extent: this.sourceImage_.getExtent(),
                      image: this.sourceImage_.getImage()
                    }
                  ], 0, void 0, this.contextOptions_);
                }
                this.state = sourceState;
                this.changed();
              };
              ReprojImage.prototype.load = function() {
                if (this.state == ImageState.IDLE) {
                  this.state = ImageState.LOADING;
                  this.changed();
                  var sourceState = this.sourceImage_.getState();
                  if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
                    this.reproject_();
                  } else {
                    this.sourceListenerKey_ = Object(events[
                      "a"
                      /* listen */
                    ])(this.sourceImage_, EventType[
                      "a"
                      /* default */
                    ].CHANGE, function(e) {
                      var sourceState2 = this.sourceImage_.getState();
                      if (sourceState2 == ImageState.LOADED || sourceState2 == ImageState.ERROR) {
                        this.unlistenSource_();
                        this.reproject_();
                      }
                    }, this);
                    this.sourceImage_.load();
                  }
                }
              };
              ReprojImage.prototype.unlistenSource_ = function() {
                Object(events[
                  "c"
                  /* unlistenByKey */
                ])(
                  /** @type {!import("../events.js").EventsKey} */
                  this.sourceListenerKey_
                );
                this.sourceListenerKey_ = null;
              };
              return ReprojImage;
            }(ol_ImageBase)
          );
          var reproj_Image = Image_ReprojImage;
          var source_Image_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageSourceEventType = {
            /**
             * Triggered when an image starts loading.
             * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
             * @api
             */
            IMAGELOADSTART: "imageloadstart",
            /**
             * Triggered when an image finishes loading.
             * @event module:ol/source/Image.ImageSourceEvent#imageloadend
             * @api
             */
            IMAGELOADEND: "imageloadend",
            /**
             * Triggered if image loading results in an error.
             * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
             * @api
             */
            IMAGELOADERROR: "imageloaderror"
          };
          var ImageSourceEvent = (
            /** @class */
            function(_super) {
              source_Image_extends(ImageSourceEvent2, _super);
              function ImageSourceEvent2(type, image) {
                var _this = _super.call(this, type) || this;
                _this.image = image;
                return _this;
              }
              return ImageSourceEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Image_ImageSource = (
            /** @class */
            function(_super) {
              source_Image_extends(ImageSource, _super);
              function ImageSource(options) {
                var _this = _super.call(this, {
                  attributions: options.attributions,
                  projection: options.projection,
                  state: options.state
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
                _this.reprojectedImage_ = null;
                _this.reprojectedRevision_ = 0;
                _this.contextOptions_ = options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : void 0;
                return _this;
              }
              ImageSource.prototype.getResolutions = function() {
                return this.resolutions_;
              };
              ImageSource.prototype.getContextOptions = function() {
                return this.contextOptions_;
              };
              ImageSource.prototype.findNearestResolution = function(resolution) {
                if (this.resolutions_) {
                  var idx = Object(ol_array[
                    "h"
                    /* linearFindNearest */
                  ])(this.resolutions_, resolution, 0);
                  resolution = this.resolutions_[idx];
                }
                return resolution;
              };
              ImageSource.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
                var sourceProjection = this.getProjection();
                if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
                  if (sourceProjection) {
                    projection = sourceProjection;
                  }
                  return this.getImageInternal(extent, resolution, pixelRatio, projection);
                } else {
                  if (this.reprojectedImage_) {
                    if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals(this.reprojectedImage_.getExtent(), extent)) {
                      return this.reprojectedImage_;
                    }
                    this.reprojectedImage_.dispose();
                    this.reprojectedImage_ = null;
                  }
                  this.reprojectedImage_ = new reproj_Image(sourceProjection, projection, extent, resolution, pixelRatio, (function(extent2, resolution2, pixelRatio2) {
                    return this.getImageInternal(extent2, resolution2, pixelRatio2, sourceProjection);
                  }).bind(this), this.contextOptions_);
                  this.reprojectedRevision_ = this.getRevision();
                  return this.reprojectedImage_;
                }
              };
              ImageSource.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              ImageSource.prototype.handleImageChange = function(event) {
                var image = (
                  /** @type {import("../Image.js").default} */
                  event.target
                );
                switch (image.getState()) {
                  case ImageState.LOADING:
                    this.loading = true;
                    this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART, image));
                    break;
                  case ImageState.LOADED:
                    this.loading = false;
                    this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND, image));
                    break;
                  case ImageState.ERROR:
                    this.loading = false;
                    this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR, image));
                    break;
                  default:
                }
              };
              return ImageSource;
            }(source_Source)
          );
          function defaultImageLoadFunction(image, src) {
            image.getImage().src = src;
          }
          var source_Image = Image_ImageSource;
          var ImageStatic_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ImageStatic_Static = (
            /** @class */
            function(_super) {
              ImageStatic_extends(Static, _super);
              function Static(options) {
                var _this = this;
                var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
                var imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
                _this = _super.call(this, {
                  attributions: options.attributions,
                  imageSmoothing: options.imageSmoothing,
                  projection: proj_get(options.projection)
                }) || this;
                _this.url_ = options.url;
                _this.imageExtent_ = options.imageExtent;
                _this.image_ = new ol_Image(_this.imageExtent_, void 0, 1, _this.url_, crossOrigin, imageLoadFunction);
                _this.imageSize_ = options.imageSize ? options.imageSize : null;
                _this.image_.addEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, _this.handleImageChange.bind(_this));
                return _this;
              }
              Static.prototype.getImageExtent = function() {
                return this.imageExtent_;
              };
              Static.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
                if (extent_intersects(extent, this.image_.getExtent())) {
                  return this.image_;
                }
                return null;
              };
              Static.prototype.getUrl = function() {
                return this.url_;
              };
              Static.prototype.handleImageChange = function(evt) {
                if (this.image_.getState() == ImageState.LOADED) {
                  var imageExtent = this.image_.getExtent();
                  var image = this.image_.getImage();
                  var imageWidth = void 0, imageHeight = void 0;
                  if (this.imageSize_) {
                    imageWidth = this.imageSize_[0];
                    imageHeight = this.imageSize_[1];
                  } else {
                    imageWidth = image.width;
                    imageHeight = image.height;
                  }
                  var extentWidth = getWidth(imageExtent);
                  var extentHeight = getHeight(imageExtent);
                  var xResolution = extentWidth / imageWidth;
                  var yResolution = extentHeight / imageHeight;
                  var targetWidth = imageWidth;
                  var targetHeight = imageHeight;
                  if (xResolution > yResolution) {
                    targetWidth = Math.round(extentWidth / yResolution);
                  } else {
                    targetHeight = Math.round(extentHeight / xResolution);
                  }
                  if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
                    var context = Object(dom[
                      "a"
                      /* createCanvasContext2D */
                    ])(targetWidth, targetHeight);
                    Object(ol_obj[
                      "a"
                      /* assign */
                    ])(context, this.getContextOptions());
                    var canvas = context.canvas;
                    context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
                    this.image_.setImage(canvas);
                  }
                }
                _super.prototype.handleImageChange.call(this, evt);
              };
              return Static;
            }(source_Image)
          );
          var ImageStatic = ImageStatic_Static;
          var SourceImageStaticvue_type_script_lang_js = {
            name: "ol-source-image-static",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("imageLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var createSource = function createSource2() {
                return new ImageStatic(_objectSpread2(_objectSpread2({}, properties), {}, {
                  projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection))
                }));
              };
              var source = createSource();
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                layer.setSource(null);
                source = createSource();
                layer.setSource(source);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.setSource(source);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.setSource(null);
              });
              return {
                layer,
                source
              };
            },
            props: {
              attributions: {
                type: String
              },
              crossOrigin: {
                type: String
              },
              imageExtent: {
                type: Array
              },
              projection: {
                type: [String, Object]
              },
              imageSmoothing: {
                type: Boolean,
                default: true
              },
              imageSize: {
                type: Array
              },
              url: {
                type: String
              }
            }
          };
          SourceImageStaticvue_type_script_lang_js.render = SourceImageStaticvue_type_template_id_80caf7c2_render;
          var SourceImageStatic = SourceImageStaticvue_type_script_lang_js;
          var SourceWMTSvue_type_template_id_37493e0b_hoisted_1 = {
            key: 0
          };
          function SourceWMTSvue_type_template_id_37493e0b_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var WMTSRequestEncoding = {
            KVP: "KVP",
            REST: "REST"
            // see spec 10
          };
          function appendParams(uri, params) {
            var keyParams = [];
            Object.keys(params).forEach(function(k) {
              if (params[k] !== null && params[k] !== void 0) {
                keyParams.push(k + "=" + encodeURIComponent(params[k]));
              }
            });
            var qs = keyParams.join("&");
            uri = uri.replace(/[?&]$/, "");
            uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
            return uri + qs;
          }
          var WMTS_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var WMTSTileGrid = (
            /** @class */
            function(_super) {
              WMTS_extends(WMTSTileGrid2, _super);
              function WMTSTileGrid2(options) {
                var _this = _super.call(this, {
                  extent: options.extent,
                  origin: options.origin,
                  origins: options.origins,
                  resolutions: options.resolutions,
                  tileSize: options.tileSize,
                  tileSizes: options.tileSizes,
                  sizes: options.sizes
                }) || this;
                _this.matrixIds_ = options.matrixIds;
                return _this;
              }
              WMTSTileGrid2.prototype.getMatrixId = function(z) {
                return this.matrixIds_[z];
              };
              WMTSTileGrid2.prototype.getMatrixIds = function() {
                return this.matrixIds_;
              };
              return WMTSTileGrid2;
            }(tilegrid_TileGrid)
          );
          var tilegrid_WMTS = WMTSTileGrid;
          function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {
            var resolutions = [];
            var matrixIds = [];
            var origins = [];
            var tileSizes = [];
            var sizes = [];
            var matrixLimits = opt_matrixLimits !== void 0 ? opt_matrixLimits : [];
            var supportedCRSPropName = "SupportedCRS";
            var matrixIdsPropName = "TileMatrix";
            var identifierPropName = "Identifier";
            var scaleDenominatorPropName = "ScaleDenominator";
            var topLeftCornerPropName = "TopLeftCorner";
            var tileWidthPropName = "TileWidth";
            var tileHeightPropName = "TileHeight";
            var code = matrixSet[supportedCRSPropName];
            var projection = proj_get(code);
            var metersPerUnit = projection.getMetersPerUnit();
            var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == "ne";
            matrixSet[matrixIdsPropName].sort(function(a, b) {
              return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
            });
            matrixSet[matrixIdsPropName].forEach(function(elt) {
              var matrixAvailable;
              if (matrixLimits.length > 0) {
                matrixAvailable = Object(ol_array[
                  "d"
                  /* find */
                ])(matrixLimits, function(elt_ml) {
                  if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
                    return true;
                  }
                  if (elt[identifierPropName].indexOf(":") === -1) {
                    return matrixSet[identifierPropName] + ":" + elt[identifierPropName] === elt_ml[matrixIdsPropName];
                  }
                  return false;
                });
              } else {
                matrixAvailable = true;
              }
              if (matrixAvailable) {
                matrixIds.push(elt[identifierPropName]);
                var resolution = elt[scaleDenominatorPropName] * 28e-5 / metersPerUnit;
                var tileWidth = elt[tileWidthPropName];
                var tileHeight = elt[tileHeightPropName];
                if (switchOriginXY) {
                  origins.push([
                    elt[topLeftCornerPropName][1],
                    elt[topLeftCornerPropName][0]
                  ]);
                } else {
                  origins.push(elt[topLeftCornerPropName]);
                }
                resolutions.push(resolution);
                tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
                sizes.push([elt["MatrixWidth"], elt["MatrixHeight"]]);
              }
            });
            return new WMTSTileGrid({
              extent: opt_extent,
              origins,
              resolutions,
              matrixIds,
              tileSizes,
              sizes
            });
          }
          var source_WMTS_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var WMTS_WMTS = (
            /** @class */
            function(_super) {
              source_WMTS_extends(WMTS, _super);
              function WMTS(options) {
                var _this = this;
                var requestEncoding = options.requestEncoding !== void 0 ? (
                  /** @type {import("./WMTSRequestEncoding.js").default} */
                  options.requestEncoding
                ) : WMTSRequestEncoding.KVP;
                var tileGrid = options.tileGrid;
                var urls = options.urls;
                if (urls === void 0 && options.url !== void 0) {
                  urls = expandUrl(options.url);
                }
                _this = _super.call(this, {
                  attributions: options.attributions,
                  attributionsCollapsible: options.attributionsCollapsible,
                  cacheSize: options.cacheSize,
                  crossOrigin: options.crossOrigin,
                  imageSmoothing: options.imageSmoothing,
                  projection: options.projection,
                  reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                  tileClass: options.tileClass,
                  tileGrid,
                  tileLoadFunction: options.tileLoadFunction,
                  tilePixelRatio: options.tilePixelRatio,
                  urls,
                  wrapX: options.wrapX !== void 0 ? options.wrapX : false,
                  transition: options.transition,
                  zDirection: options.zDirection
                }) || this;
                _this.version_ = options.version !== void 0 ? options.version : "1.0.0";
                _this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
                _this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
                _this.layer_ = options.layer;
                _this.matrixSet_ = options.matrixSet;
                _this.style_ = options.style;
                _this.requestEncoding_ = requestEncoding;
                _this.setKey(_this.getKeyForDimensions_());
                if (urls && urls.length > 0) {
                  _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));
                }
                return _this;
              }
              WMTS.prototype.setUrls = function(urls) {
                this.urls = urls;
                var key = urls.join("\n");
                this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
              };
              WMTS.prototype.getDimensions = function() {
                return this.dimensions_;
              };
              WMTS.prototype.getFormat = function() {
                return this.format_;
              };
              WMTS.prototype.getLayer = function() {
                return this.layer_;
              };
              WMTS.prototype.getMatrixSet = function() {
                return this.matrixSet_;
              };
              WMTS.prototype.getRequestEncoding = function() {
                return this.requestEncoding_;
              };
              WMTS.prototype.getStyle = function() {
                return this.style_;
              };
              WMTS.prototype.getVersion = function() {
                return this.version_;
              };
              WMTS.prototype.getKeyForDimensions_ = function() {
                var i = 0;
                var res = [];
                for (var key in this.dimensions_) {
                  res[i++] = key + "-" + this.dimensions_[key];
                }
                return res.join("/");
              };
              WMTS.prototype.updateDimensions = function(dimensions) {
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(this.dimensions_, dimensions);
                this.setKey(this.getKeyForDimensions_());
              };
              WMTS.prototype.createFromWMTSTemplate = function(template) {
                var requestEncoding = this.requestEncoding_;
                var context = {
                  "layer": this.layer_,
                  "style": this.style_,
                  "tilematrixset": this.matrixSet_
                };
                if (requestEncoding == WMTSRequestEncoding.KVP) {
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(context, {
                    "Service": "WMTS",
                    "Request": "GetTile",
                    "Version": this.version_,
                    "Format": this.format_
                  });
                }
                template = requestEncoding == WMTSRequestEncoding.KVP ? appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
                  return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
                });
                var tileGrid = (
                  /** @type {import("../tilegrid/WMTS.js").default} */
                  this.tileGrid
                );
                var dimensions = this.dimensions_;
                return (
                  /**
                   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
                   * @param {number} pixelRatio Pixel ratio.
                   * @param {import("../proj/Projection.js").default} projection Projection.
                   * @return {string|undefined} Tile URL.
                   */
                  function(tileCoord, pixelRatio, projection) {
                    if (!tileCoord) {
                      return void 0;
                    } else {
                      var localContext_1 = {
                        "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
                        "TileCol": tileCoord[1],
                        "TileRow": tileCoord[2]
                      };
                      Object(ol_obj[
                        "a"
                        /* assign */
                      ])(localContext_1, dimensions);
                      var url = template;
                      if (requestEncoding == WMTSRequestEncoding.KVP) {
                        url = appendParams(url, localContext_1);
                      } else {
                        url = url.replace(/\{(\w+?)\}/g, function(m, p) {
                          return localContext_1[p];
                        });
                      }
                      return url;
                    }
                  }
                );
              };
              return WMTS;
            }(source_TileImage)
          );
          var source_WMTS = WMTS_WMTS;
          function optionsFromCapabilities(wmtsCap, config) {
            var layers = wmtsCap["Contents"]["Layer"];
            var l = Object(ol_array[
              "d"
              /* find */
            ])(layers, function(elt, index, array) {
              return elt["Identifier"] == config["layer"];
            });
            if (l === null) {
              return null;
            }
            var tileMatrixSets = wmtsCap["Contents"]["TileMatrixSet"];
            var idx;
            if (l["TileMatrixSetLink"].length > 1) {
              if ("projection" in config) {
                idx = Object(ol_array[
                  "e"
                  /* findIndex */
                ])(l["TileMatrixSetLink"], function(elt, index, array) {
                  var tileMatrixSet = Object(ol_array[
                    "d"
                    /* find */
                  ])(tileMatrixSets, function(el) {
                    return el["Identifier"] == elt["TileMatrixSet"];
                  });
                  var supportedCRS = tileMatrixSet["SupportedCRS"];
                  var proj1 = proj_get(supportedCRS);
                  var proj2 = proj_get(config["projection"]);
                  if (proj1 && proj2) {
                    return equivalent(proj1, proj2);
                  } else {
                    return supportedCRS == config["projection"];
                  }
                });
              } else {
                idx = Object(ol_array[
                  "e"
                  /* findIndex */
                ])(l["TileMatrixSetLink"], function(elt, index, array) {
                  return elt["TileMatrixSet"] == config["matrixSet"];
                });
              }
            } else {
              idx = 0;
            }
            if (idx < 0) {
              idx = 0;
            }
            var matrixSet = (
              /** @type {string} */
              l["TileMatrixSetLink"][idx]["TileMatrixSet"]
            );
            var matrixLimits = (
              /** @type {Array<Object>} */
              l["TileMatrixSetLink"][idx]["TileMatrixSetLimits"]
            );
            var format = (
              /** @type {string} */
              l["Format"][0]
            );
            if ("format" in config) {
              format = config["format"];
            }
            idx = Object(ol_array[
              "e"
              /* findIndex */
            ])(l["Style"], function(elt, index, array) {
              if ("style" in config) {
                return elt["Title"] == config["style"];
              } else {
                return elt["isDefault"];
              }
            });
            if (idx < 0) {
              idx = 0;
            }
            var style = (
              /** @type {string} */
              l["Style"][idx]["Identifier"]
            );
            var dimensions = {};
            if ("Dimension" in l) {
              l["Dimension"].forEach(function(elt, index, array) {
                var key = elt["Identifier"];
                var value = elt["Default"];
                if (value === void 0) {
                  value = elt["Value"][0];
                }
                dimensions[key] = value;
              });
            }
            var matrixSets = wmtsCap["Contents"]["TileMatrixSet"];
            var matrixSetObj = Object(ol_array[
              "d"
              /* find */
            ])(matrixSets, function(elt, index, array) {
              return elt["Identifier"] == matrixSet;
            });
            var projection;
            var code = matrixSetObj["SupportedCRS"];
            if (code) {
              projection = proj_get(code);
            }
            if ("projection" in config) {
              var projConfig = proj_get(config["projection"]);
              if (projConfig) {
                if (!projection || equivalent(projConfig, projection)) {
                  projection = projConfig;
                }
              }
            }
            var wrapX = false;
            var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == "ne";
            var matrix = matrixSetObj.TileMatrix[0];
            var selectedMatrixLimit = {
              MinTileCol: 0,
              MinTileRow: 0,
              // subtract one to end up at tile top left
              MaxTileCol: matrix.MatrixWidth - 1,
              MaxTileRow: matrix.MatrixHeight - 1
            };
            if (matrixLimits) {
              selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
              var m = Object(ol_array[
                "d"
                /* find */
              ])(matrixSetObj.TileMatrix, function(tileMatrixValue) {
                return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ":" + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;
              });
              if (m) {
                matrix = m;
              }
            }
            var resolution = matrix.ScaleDenominator * 28e-5 / projection.getMetersPerUnit();
            var origin = switchOriginXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;
            var tileSpanX = matrix.TileWidth * resolution;
            var tileSpanY = matrix.TileHeight * resolution;
            var matrixSetExtent = matrixSetObj["BoundingBox"];
            var extent = [
              origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,
              // add one to get proper bottom/right coordinate
              origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),
              origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),
              origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow
            ];
            if (matrixSetExtent !== void 0 && !containsExtent(matrixSetExtent, extent)) {
              var wgs84BoundingBox = l["WGS84BoundingBox"];
              var wgs84ProjectionExtent = proj_get("EPSG:4326").getExtent();
              extent = matrixSetExtent;
              if (wgs84BoundingBox) {
                wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];
              } else {
                var wgs84MatrixSetExtent = transformExtent(matrixSetExtent, matrixSetObj["SupportedCRS"], "EPSG:4326");
                wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];
              }
            }
            var tileGrid = createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
            var urls = [];
            var requestEncoding = config["requestEncoding"];
            requestEncoding = requestEncoding !== void 0 ? requestEncoding : "";
            if ("OperationsMetadata" in wmtsCap && "GetTile" in wmtsCap["OperationsMetadata"]) {
              var gets = wmtsCap["OperationsMetadata"]["GetTile"]["DCP"]["HTTP"]["Get"];
              for (var i = 0, ii = gets.length; i < ii; ++i) {
                if (gets[i]["Constraint"]) {
                  var constraint = Object(ol_array[
                    "d"
                    /* find */
                  ])(gets[i]["Constraint"], function(element) {
                    return element["name"] == "GetEncoding";
                  });
                  var encodings = constraint["AllowedValues"]["Value"];
                  if (requestEncoding === "") {
                    requestEncoding = encodings[0];
                  }
                  if (requestEncoding === WMTSRequestEncoding.KVP) {
                    if (Object(ol_array[
                      "f"
                      /* includes */
                    ])(encodings, WMTSRequestEncoding.KVP)) {
                      urls.push(
                        /** @type {string} */
                        gets[i]["href"]
                      );
                    }
                  } else {
                    break;
                  }
                } else if (gets[i]["href"]) {
                  requestEncoding = WMTSRequestEncoding.KVP;
                  urls.push(
                    /** @type {string} */
                    gets[i]["href"]
                  );
                }
              }
            }
            if (urls.length === 0) {
              requestEncoding = WMTSRequestEncoding.REST;
              l["ResourceURL"].forEach(function(element) {
                if (element["resourceType"] === "tile") {
                  format = element["format"];
                  urls.push(
                    /** @type {string} */
                    element["template"]
                  );
                }
              });
            }
            return {
              urls,
              layer: config["layer"],
              matrixSet,
              format,
              projection,
              requestEncoding,
              tileGrid,
              style,
              dimensions,
              wrapX,
              crossOrigin: config["crossOrigin"]
            };
          }
          var SourceWMTSvue_type_script_lang_js = {
            name: "ol-source-wmts",
            setup: function setup(props) {
              var tileLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var extent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return proj_get(properties.projection).getExtent();
              });
              var origin = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return getTopLeft(extent.value);
              });
              var size = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return getWidth(extent.value) / 256;
              });
              var getTileGrid = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var resolutions = new Array(14);
                var matrixIds = new Array(14);
                for (var z = 0; z < 14; ++z) {
                  resolutions[z] = size.value / Math.pow(2, z);
                  matrixIds[z] = z;
                }
                return new tilegrid_WMTS({
                  origin: origin.value,
                  resolutions,
                  matrixIds
                });
              });
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new source_WMTS(_objectSpread2(_objectSpread2({}, properties), {}, {
                  projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection)),
                  tileGrid: getTileGrid.value
                }));
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
                tileLayer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(tileLayer, function() {
                tileLayer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                tileLayer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                tileLayer.value.setSource(null);
              });
              return {
                tileLayer,
                source
              };
            },
            props: {
              attributions: {
                type: String
              },
              cacheSize: {
                type: Number
              },
              crossOrigin: {
                type: String
              },
              imageSmoothing: {
                type: Boolean,
                default: true
              },
              projection: {
                type: [String, Object],
                default: "EPSG:3857"
              },
              reprojectionErrorThreshold: {
                type: Number,
                default: 0.5
              },
              tilePixelRatio: {
                type: Number,
                default: 1
              },
              format: {
                type: String,
                default: "image/jpeg"
              },
              version: {
                type: String,
                default: "1.0.0"
              },
              matrixSet: {
                type: String
              },
              dimensions: {
                type: Object
              },
              url: {
                type: String
              },
              urls: {
                type: Array
              },
              wrapX: {
                type: Boolean,
                default: false
              },
              transition: {
                type: Number
              },
              layer: {
                type: String
              },
              style: {
                type: String
              }
            }
          };
          SourceWMTSvue_type_script_lang_js.render = SourceWMTSvue_type_template_id_37493e0b_render;
          var SourceWMTS = SourceWMTSvue_type_script_lang_js;
          function SourceVectorvue_type_template_id_352acc0f_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var SourceVectorvue_type_script_lang_js = {
            name: "ol-source-vector",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new source_Vector(properties);
              });
              var applySource = function applySource2() {
                layer.value.setSource(null);
                layer.value.setSource(source.value);
                layer.value.changed();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applySource();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
                applySource();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.value.setSource(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorSource", source);
              return {
                layer,
                source
              };
            },
            props: {
              attributions: {
                type: [String, Array]
              },
              features: {
                type: Array,
                default: function _default() {
                  return [];
                }
              },
              format: {
                type: Object
              },
              loader: {
                type: Function
              },
              overlaps: {
                type: Boolean,
                default: true
              },
              projection: {
                type: String,
                default: "EPSG:3857"
              },
              strategy: {
                type: Function
              },
              url: {
                type: [String, Function]
              },
              useSpatialIndex: {
                type: Boolean,
                default: true
              },
              wrapX: {
                type: Boolean,
                default: true
              }
            }
          };
          SourceVectorvue_type_script_lang_js.render = SourceVectorvue_type_template_id_352acc0f_render;
          var SourceVector = SourceVectorvue_type_script_lang_js;
          function SourceClustervue_type_template_id_0b7aeaa6_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var SourceClustervue_type_script_lang_js = {
            name: "ol-source-cluster",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var c = new source_Cluster(properties);
                return c;
              });
              var applySource = function applySource2() {
                layer.value.setSource(null);
                layer.value.setSource(source.value);
                layer.value.changed();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applySource();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
                applySource();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.value.setSource(source.value);
                layer.value.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.value.setSource(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", source);
              return {
                layer,
                source
              };
            },
            props: {
              attributions: {
                type: [String, Array]
              },
              distance: {
                type: Number,
                default: 20
              },
              geometryFunction: {
                type: Function,
                default: function _default(feature) {
                  return feature.getGeometry();
                }
              },
              wrapX: {
                type: Boolean,
                default: true
              }
            }
          };
          SourceClustervue_type_script_lang_js.render = SourceClustervue_type_template_id_0b7aeaa6_render;
          var SourceCluster = SourceClustervue_type_script_lang_js;
          var SourceBingMapsvue_type_template_id_25b5d337_hoisted_1 = {
            key: 0
          };
          function SourceBingMapsvue_type_template_id_25b5d337_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          function jsonp(url, callback, opt_errback, opt_callbackParam) {
            var script = document.createElement("script");
            var key = "olc_" + Object(util[
              "c"
              /* getUid */
            ])(callback);
            function cleanup() {
              delete window[key];
              script.parentNode.removeChild(script);
            }
            script.async = true;
            script.src = url + (url.indexOf("?") == -1 ? "?" : "&") + (opt_callbackParam || "callback") + "=" + key;
            var timer = setTimeout(function() {
              cleanup();
              if (opt_errback) {
                opt_errback();
              }
            }, 1e4);
            window[key] = function(data) {
              clearTimeout(timer);
              cleanup();
              callback(data);
            };
            document.getElementsByTagName("head")[0].appendChild(script);
          }
          var BingMaps_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          function quadKey(tileCoord) {
            var z = tileCoord[0];
            var digits = new Array(z);
            var mask = 1 << z - 1;
            var i, charCode;
            for (i = 0; i < z; ++i) {
              charCode = 48;
              if (tileCoord[1] & mask) {
                charCode += 1;
              }
              if (tileCoord[2] & mask) {
                charCode += 2;
              }
              digits[i] = String.fromCharCode(charCode);
              mask >>= 1;
            }
            return digits.join("");
          }
          var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
          var BingMaps_BingMaps = (
            /** @class */
            function(_super) {
              BingMaps_extends(BingMaps, _super);
              function BingMaps(options) {
                var _this = this;
                var hidpi = options.hidpi !== void 0 ? options.hidpi : false;
                _this = _super.call(this, {
                  cacheSize: options.cacheSize,
                  crossOrigin: "anonymous",
                  imageSmoothing: options.imageSmoothing,
                  opaque: true,
                  projection: proj_get("EPSG:3857"),
                  reprojectionErrorThreshold: options.reprojectionErrorThreshold,
                  state: State.LOADING,
                  tileLoadFunction: options.tileLoadFunction,
                  tilePixelRatio: hidpi ? 2 : 1,
                  wrapX: options.wrapX !== void 0 ? options.wrapX : true,
                  transition: options.transition,
                  zDirection: options.zDirection
                }) || this;
                _this.hidpi_ = hidpi;
                _this.culture_ = options.culture !== void 0 ? options.culture : "en-us";
                _this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;
                _this.apiKey_ = options.key;
                _this.imagerySet_ = options.imagerySet;
                var url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + _this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + _this.apiKey_ + "&c=" + _this.culture_;
                jsonp(url, _this.handleImageryMetadataResponse.bind(_this), void 0, "jsonp");
                return _this;
              }
              BingMaps.prototype.getApiKey = function() {
                return this.apiKey_;
              };
              BingMaps.prototype.getImagerySet = function() {
                return this.imagerySet_;
              };
              BingMaps.prototype.handleImageryMetadataResponse = function(response) {
                if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
                  this.setState(State.ERROR);
                  return;
                }
                var resource = response.resourceSets[0].resources[0];
                var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
                var sourceProjection = this.getProjection();
                var extent = extentFromProjection(sourceProjection);
                var scale = this.hidpi_ ? 2 : 1;
                var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale : [resource.imageWidth / scale, resource.imageHeight / scale];
                var tileGrid = createXYZ({
                  extent,
                  minZoom: resource.zoomMin,
                  maxZoom,
                  tileSize
                });
                this.tileGrid = tileGrid;
                var culture = this.culture_;
                var hidpi = this.hidpi_;
                this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
                  var quadKeyTileCoord = [0, 0, 0];
                  var imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
                  return (
                    /**
                     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
                     * @param {number} pixelRatio Pixel ratio.
                     * @param {import("../proj/Projection.js").default} projection Projection.
                     * @return {string|undefined} Tile URL.
                     */
                    function(tileCoord, pixelRatio, projection) {
                      if (!tileCoord) {
                        return void 0;
                      } else {
                        tilecoord_createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
                        var url = imageUrl;
                        if (hidpi) {
                          url += "&dpi=d1&device=mobile";
                        }
                        return url.replace("{quadkey}", quadKey(quadKeyTileCoord));
                      }
                    }
                  );
                }));
                if (resource.imageryProviders) {
                  var transform_1 = getTransformFromProjections(proj_get("EPSG:4326"), this.getProjection());
                  this.setAttributions((function(frameState) {
                    var attributions = [];
                    var viewState = frameState.viewState;
                    var tileGrid2 = this.getTileGrid();
                    var z = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);
                    var tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z);
                    var zoom = tileCoord[0];
                    resource.imageryProviders.map(function(imageryProvider) {
                      var intersecting = false;
                      var coverageAreas = imageryProvider.coverageAreas;
                      for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
                        var coverageArea = coverageAreas[i];
                        if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
                          var bbox = coverageArea.bbox;
                          var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
                          var extent_1 = applyTransform(epsg4326Extent, transform_1);
                          if (extent_intersects(extent_1, frameState.extent)) {
                            intersecting = true;
                            break;
                          }
                        }
                      }
                      if (intersecting) {
                        attributions.push(imageryProvider.attribution);
                      }
                    });
                    attributions.push(TOS_ATTRIBUTION);
                    return attributions;
                  }).bind(this));
                }
                this.setState(State.READY);
              };
              return BingMaps;
            }(source_TileImage)
          );
          var source_BingMaps = BingMaps_BingMaps;
          var SourceBingMapsvue_type_script_lang_js = {
            name: "ol-source-bingmaps",
            setup: function setup(props) {
              var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new source_BingMaps(_objectSpread2(_objectSpread2({}, properties), {}, {
                  key: properties.apiKey
                }));
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                layer.value.setSource(source.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                layer.value.setSource(null);
              });
              return {
                layer,
                source
              };
            },
            props: {
              cacheSize: {
                type: Number
              },
              hidpi: {
                type: Boolean,
                default: false
              },
              culture: {
                type: String,
                default: "en-us"
              },
              apiKey: {
                type: String
              },
              imagerySet: {
                type: String
              },
              imageSmoothing: {
                type: Boolean,
                default: true
              },
              maxZoom: {
                type: Number,
                default: 21
              },
              reprojectionErrorThreshold: {
                type: Number,
                default: 0.5
              },
              tileLoadFunction: {
                type: Function,
                default: function _default(imageTile, src) {
                  return imageTile.getImage().src = src;
                }
              },
              wrapX: {
                type: Boolean,
                default: true
              },
              transition: {
                type: Number
              }
            }
          };
          SourceBingMapsvue_type_script_lang_js.render = SourceBingMapsvue_type_template_id_25b5d337_render;
          var SourceBingMaps = SourceBingMapsvue_type_script_lang_js;
          function sources_install(app) {
            if (sources_install.installed) {
              return;
            }
            sources_install.installed = true;
            app.component(SourceXYZ.name, SourceXYZ);
            app.component(SourceOSM.name, SourceOSM);
            app.component(SourceImageStatic.name, SourceImageStatic);
            app.component(SourceWMTS.name, SourceWMTS);
            app.component(SourceVector.name, SourceVector);
            app.component(SourceCluster.name, SourceCluster);
            app.component(SourceBingMaps.name, SourceBingMaps);
          }
          var components_sources = sources_install;
          var FullScreenControlvue_type_template_id_6e08cc6a_lang_true_hoisted_1 = {
            key: 0
          };
          function FullScreenControlvue_type_template_id_6e08cc6a_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var FullScreen_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var FullScreen_events = [
            "fullscreenchange",
            "webkitfullscreenchange",
            "MSFullscreenChange"
          ];
          var FullScreenEventType = {
            /**
             * Triggered after the map entered fullscreen.
             * @event FullScreenEventType#enterfullscreen
             * @api
             */
            ENTERFULLSCREEN: "enterfullscreen",
            /**
             * Triggered after the map leave fullscreen.
             * @event FullScreenEventType#leavefullscreen
             * @api
             */
            LEAVEFULLSCREEN: "leavefullscreen"
          };
          var FullScreen_FullScreen = (
            /** @class */
            function(_super) {
              FullScreen_extends(FullScreen, _super);
              function FullScreen(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  target: options.target
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
                _this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [_this.cssClassName_ + "-true"];
                _this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [_this.cssClassName_ + "-false"];
                var label = options.label !== void 0 ? options.label : "";
                _this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
                var labelActive = options.labelActive !== void 0 ? options.labelActive : "";
                _this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
                _this.button_ = document.createElement("button");
                var tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
                _this.setClassName_(_this.button_, isFullScreen());
                _this.button_.setAttribute("type", "button");
                _this.button_.title = tipLabel;
                _this.button_.appendChild(_this.labelNode_);
                _this.button_.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this), false);
                var cssClasses = _this.cssClassName_ + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + " " + (!isFullScreenSupported() ? CLASS_UNSUPPORTED : "");
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(_this.button_);
                _this.keys_ = options.keys !== void 0 ? options.keys : false;
                _this.source_ = options.source;
                return _this;
              }
              FullScreen.prototype.handleClick_ = function(event) {
                event.preventDefault();
                this.handleFullScreen_();
              };
              FullScreen.prototype.handleFullScreen_ = function() {
                if (!isFullScreenSupported()) {
                  return;
                }
                var map = this.getMap();
                if (!map) {
                  return;
                }
                if (isFullScreen()) {
                  exitFullScreen();
                } else {
                  var element = void 0;
                  if (this.source_) {
                    element = typeof this.source_ === "string" ? document.getElementById(this.source_) : this.source_;
                  } else {
                    element = map.getTargetElement();
                  }
                  if (this.keys_) {
                    requestFullScreenWithKeys(element);
                  } else {
                    requestFullScreen(element);
                  }
                }
              };
              FullScreen.prototype.handleFullScreenChange_ = function() {
                var map = this.getMap();
                if (isFullScreen()) {
                  this.setClassName_(this.button_, true);
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.labelActiveNode_, this.labelNode_);
                  this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
                } else {
                  this.setClassName_(this.button_, false);
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.labelNode_, this.labelActiveNode_);
                  this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
                }
                if (map) {
                  map.updateSize();
                }
              };
              FullScreen.prototype.setClassName_ = function(element, fullscreen) {
                var _a, _b, _c;
                var activeClassName = this.activeClassName_;
                var inactiveClassName = this.inactiveClassName_;
                var nextClassName = fullscreen ? activeClassName : inactiveClassName;
                (_a = element.classList).remove.apply(_a, activeClassName);
                (_b = element.classList).remove.apply(_b, inactiveClassName);
                (_c = element.classList).add.apply(_c, nextClassName);
              };
              FullScreen.prototype.setMap = function(map) {
                _super.prototype.setMap.call(this, map);
                if (map) {
                  for (var i = 0, ii = FullScreen_events.length; i < ii; ++i) {
                    this.listenerKeys.push(Object(events[
                      "a"
                      /* listen */
                    ])(document, FullScreen_events[i], this.handleFullScreenChange_, this));
                  }
                }
              };
              return FullScreen;
            }(Control["default"])
          );
          function isFullScreenSupported() {
            var body = document.body;
            return !!(body["webkitRequestFullscreen"] || body["msRequestFullscreen"] && document["msFullscreenEnabled"] || body.requestFullscreen && document.fullscreenEnabled);
          }
          function isFullScreen() {
            return !!(document["webkitIsFullScreen"] || document["msFullscreenElement"] || document.fullscreenElement);
          }
          function requestFullScreen(element) {
            if (element.requestFullscreen) {
              element.requestFullscreen();
            } else if (element["msRequestFullscreen"]) {
              element["msRequestFullscreen"]();
            } else if (element["webkitRequestFullscreen"]) {
              element["webkitRequestFullscreen"]();
            }
          }
          function requestFullScreenWithKeys(element) {
            if (element["webkitRequestFullscreen"]) {
              element["webkitRequestFullscreen"]();
            } else {
              requestFullScreen(element);
            }
          }
          function exitFullScreen() {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document["msExitFullscreen"]) {
              document["msExitFullscreen"]();
            } else if (document["webkitExitFullscreen"]) {
              document["webkitExitFullscreen"]();
            }
          }
          var control_FullScreen = FullScreen_FullScreen;
          function useControl(ControlType, props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var control = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new ControlType(_objectSpread2({}, properties));
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(control, function(newVal, oldVal) {
              map.removeControl(oldVal);
              map.addControl(newVal);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addControl(control.value);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeControl(control.value);
              map.changed();
            });
            return {
              map,
              control
            };
          }
          var FullScreenControlvue_type_script_lang_js = {
            name: "ol-fullscreen-control",
            setup: function setup(props) {
              var _useControl = useControl(control_FullScreen, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-full-screen"
              },
              label: {
                type: String,
                default: ""
              },
              labelActive: {
                type: String,
                default: ""
              },
              activeClassName: {
                type: String,
                default: "ol-full-screen-true"
              },
              inactiveClassName: {
                type: String,
                default: "ol-full-screen-false"
              },
              tipLabel: {
                type: String,
                default: "Toggle full-screen"
              },
              keys: {
                type: Boolean,
                default: false
              },
              target: {
                type: Object,
                default: void 0
              },
              source: {
                type: Object,
                default: void 0
              }
            }
          };
          FullScreenControlvue_type_script_lang_js.render = FullScreenControlvue_type_template_id_6e08cc6a_lang_true_render;
          var FullScreenControl = FullScreenControlvue_type_script_lang_js;
          var MousePositionControlvue_type_template_id_51d08958_lang_true_hoisted_1 = {
            key: 0
          };
          function MousePositionControlvue_type_template_id_51d08958_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var MousePosition_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var PROJECTION = "projection";
          var COORDINATE_FORMAT = "coordinateFormat";
          var MousePosition_MousePosition = (
            /** @class */
            function(_super) {
              MousePosition_extends(MousePosition, _super);
              function MousePosition(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var element = document.createElement("div");
                element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
                _this = _super.call(this, {
                  element,
                  render: options.render,
                  target: options.target
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);
                if (options.coordinateFormat) {
                  _this.setCoordinateFormat(options.coordinateFormat);
                }
                if (options.projection) {
                  _this.setProjection(options.projection);
                }
                var renderOnMouseOut = true;
                var placeholder = "&#160;";
                if ("undefinedHTML" in options) {
                  if (options.undefinedHTML !== void 0) {
                    placeholder = options.undefinedHTML;
                  }
                  renderOnMouseOut = !!placeholder;
                } else if ("placeholder" in options) {
                  if (options.placeholder === false) {
                    renderOnMouseOut = false;
                  } else {
                    placeholder = String(options.placeholder);
                  }
                }
                _this.placeholder_ = placeholder;
                _this.renderOnMouseOut_ = renderOnMouseOut;
                _this.renderedHTML_ = element.innerHTML;
                _this.mapProjection_ = null;
                _this.transform_ = null;
                return _this;
              }
              MousePosition.prototype.handleProjectionChanged_ = function() {
                this.transform_ = null;
              };
              MousePosition.prototype.getCoordinateFormat = function() {
                return (
                  /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
                  this.get(COORDINATE_FORMAT)
                );
              };
              MousePosition.prototype.getProjection = function() {
                return (
                  /** @type {import("../proj/Projection.js").default|undefined} */
                  this.get(PROJECTION)
                );
              };
              MousePosition.prototype.handleMouseMove = function(event) {
                var map = this.getMap();
                this.updateHTML_(map.getEventPixel(event));
              };
              MousePosition.prototype.handleMouseOut = function(event) {
                this.updateHTML_(null);
              };
              MousePosition.prototype.setMap = function(map) {
                _super.prototype.setMap.call(this, map);
                if (map) {
                  var viewport = map.getViewport();
                  this.listenerKeys.push(Object(events[
                    "a"
                    /* listen */
                  ])(viewport, pointer_EventType.POINTERMOVE, this.handleMouseMove, this));
                  if (this.renderOnMouseOut_) {
                    this.listenerKeys.push(Object(events[
                      "a"
                      /* listen */
                    ])(viewport, pointer_EventType.POINTEROUT, this.handleMouseOut, this));
                  }
                  this.updateHTML_(null);
                }
              };
              MousePosition.prototype.setCoordinateFormat = function(format) {
                this.set(COORDINATE_FORMAT, format);
              };
              MousePosition.prototype.setProjection = function(projection) {
                this.set(PROJECTION, proj_get(projection));
              };
              MousePosition.prototype.updateHTML_ = function(pixel) {
                var html = this.placeholder_;
                if (pixel && this.mapProjection_) {
                  if (!this.transform_) {
                    var projection = this.getProjection();
                    if (projection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
                    } else {
                      this.transform_ = identityTransform;
                    }
                  }
                  var map = this.getMap();
                  var coordinate = map.getCoordinateFromPixelInternal(pixel);
                  if (coordinate) {
                    var userProjection = getUserProjection();
                    if (userProjection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
                    }
                    this.transform_(coordinate, coordinate);
                    var coordinateFormat = this.getCoordinateFormat();
                    if (coordinateFormat) {
                      html = coordinateFormat(coordinate);
                    } else {
                      html = coordinate.toString();
                    }
                  }
                }
                if (!this.renderedHTML_ || html !== this.renderedHTML_) {
                  this.element.innerHTML = html;
                  this.renderedHTML_ = html;
                }
              };
              MousePosition.prototype.render = function(mapEvent) {
                var frameState = mapEvent.frameState;
                if (!frameState) {
                  this.mapProjection_ = null;
                } else {
                  if (this.mapProjection_ != frameState.viewState.projection) {
                    this.mapProjection_ = frameState.viewState.projection;
                    this.transform_ = null;
                  }
                }
              };
              return MousePosition;
            }(Control["default"])
          );
          var control_MousePosition = MousePosition_MousePosition;
          var MousePositionControlvue_type_script_lang_js = {
            name: "ol-mouseposition-control",
            setup: function setup(props) {
              var _useControl = useControl(control_MousePosition, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-mouse-position"
              },
              coordinateFormat: {
                type: String
              },
              projection: {
                type: String
              },
              render: {
                type: Function
              },
              target: {
                type: HTMLElement
              },
              undefinedHTML: {
                type: String,
                default: "&#160;"
              }
            }
          };
          MousePositionControlvue_type_script_lang_js.render = MousePositionControlvue_type_template_id_51d08958_lang_true_render;
          var MousePositionControl = MousePositionControlvue_type_script_lang_js;
          var AttributionControlvue_type_template_id_76fef498_lang_true_hoisted_1 = {
            key: 0
          };
          function AttributionControlvue_type_template_id_76fef498_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var AttributionControlvue_type_script_lang_js = {
            name: "ol-attribution-control",
            setup: function setup(props) {
              var _useControl = useControl(control_Attribution, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-attribution"
              },
              target: {
                type: HTMLElement
              },
              collapsible: {
                type: Boolean
              },
              collapsed: {
                type: Boolean,
                default: true
              },
              tipLabel: {
                type: String,
                default: "Attributions"
              },
              label: {
                type: String,
                default: "i"
              },
              expandClassName: {
                type: String,
                default: "ol-attribution-expand"
              },
              collapseLabel: {
                type: String,
                default: ""
              },
              collapseClassName: {
                type: String,
                default: "ol-attribution-collapse"
              },
              render: {
                type: Function
              }
            }
          };
          AttributionControlvue_type_script_lang_js.render = AttributionControlvue_type_template_id_76fef498_lang_true_render;
          var AttributionControl = AttributionControlvue_type_script_lang_js;
          function OverviewMapControlvue_type_template_id_7b327316_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var OverviewMap_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MAX_RATIO = 0.75;
          var MIN_RATIO = 0.1;
          var OverviewMap_ControlledMap = (
            /** @class */
            function(_super) {
              OverviewMap_extends(ControlledMap, _super);
              function ControlledMap() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              ControlledMap.prototype.createRenderer = function() {
                return new Composite(this);
              };
              return ControlledMap;
            }(ol_PluggableMap)
          );
          var OverviewMap_OverviewMap = (
            /** @class */
            function(_super) {
              OverviewMap_extends(OverviewMap, _super);
              function OverviewMap(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  render: options.render,
                  target: options.target
                }) || this;
                _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
                _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
                _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
                if (!_this.collapsible_) {
                  _this.collapsed_ = false;
                }
                _this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
                _this.viewExtent_ = void 0;
                var className = options.className !== void 0 ? options.className : "ol-overviewmap";
                var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
                var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "";
                if (typeof collapseLabel === "string") {
                  _this.collapseLabel_ = document.createElement("span");
                  _this.collapseLabel_.textContent = collapseLabel;
                } else {
                  _this.collapseLabel_ = collapseLabel;
                }
                var label = options.label !== void 0 ? options.label : "";
                if (typeof label === "string") {
                  _this.label_ = document.createElement("span");
                  _this.label_.textContent = label;
                } else {
                  _this.label_ = label;
                }
                var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
                var button = document.createElement("button");
                button.setAttribute("type", "button");
                button.title = tipLabel;
                button.appendChild(activeLabel);
                button.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this), false);
                _this.ovmapDiv_ = document.createElement("div");
                _this.ovmapDiv_.className = "ol-overviewmap-map";
                _this.view_ = options.view;
                _this.ovmap_ = new OverviewMap_ControlledMap({
                  view: options.view
                });
                var ovmap = _this.ovmap_;
                if (options.layers) {
                  options.layers.forEach(function(layer) {
                    ovmap.addLayer(layer);
                  });
                }
                var box = document.createElement("div");
                box.className = "ol-overviewmap-box";
                box.style.boxSizing = "border-box";
                _this.boxOverlay_ = new ol_Overlay({
                  position: [0, 0],
                  positioning: OverlayPositioning.CENTER_CENTER,
                  element: box
                });
                _this.ovmap_.addOverlay(_this.boxOverlay_);
                var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(_this.ovmapDiv_);
                element.appendChild(button);
                var scope = _this;
                var overlay = _this.boxOverlay_;
                var overlayBox = _this.boxOverlay_.getElement();
                var computeDesiredMousePosition = function(mousePosition) {
                  return {
                    clientX: mousePosition.clientX,
                    clientY: mousePosition.clientY
                  };
                };
                var move = function(event) {
                  var position = (
                    /** @type {?} */
                    computeDesiredMousePosition(event)
                  );
                  var coordinates = ovmap.getEventCoordinateInternal(
                    /** @type {MouseEvent} */
                    position
                  );
                  overlay.setPosition(coordinates);
                };
                var endMoving = function(event) {
                  var coordinates = ovmap.getEventCoordinateInternal(event);
                  scope.getMap().getView().setCenterInternal(coordinates);
                  window.removeEventListener("mousemove", move);
                  window.removeEventListener("mouseup", endMoving);
                };
                overlayBox.addEventListener("mousedown", function() {
                  window.addEventListener("mousemove", move);
                  window.addEventListener("mouseup", endMoving);
                });
                return _this;
              }
              OverviewMap.prototype.setMap = function(map) {
                var oldMap = this.getMap();
                if (map === oldMap) {
                  return;
                }
                if (oldMap) {
                  var oldView = oldMap.getView();
                  if (oldView) {
                    this.unbindView_(oldView);
                  }
                  this.ovmap_.setTarget(null);
                }
                _super.prototype.setMap.call(this, map);
                if (map) {
                  this.ovmap_.setTarget(this.ovmapDiv_);
                  this.listenerKeys.push(Object(events[
                    "a"
                    /* listen */
                  ])(map, ObjectEventType[
                    "a"
                    /* default */
                  ].PROPERTYCHANGE, this.handleMapPropertyChange_, this));
                  var view = map.getView();
                  if (view) {
                    this.bindView_(view);
                    if (view.isDef()) {
                      this.ovmap_.updateSize();
                      this.resetExtent_();
                    }
                  }
                  if (!this.ovmap_.isRendered()) {
                    this.updateBoxAfterOvmapIsRendered_();
                  }
                }
              };
              OverviewMap.prototype.handleMapPropertyChange_ = function(event) {
                if (event.key === MapProperty.VIEW) {
                  var oldView = (
                    /** @type {import("../View.js").default} */
                    event.oldValue
                  );
                  if (oldView) {
                    this.unbindView_(oldView);
                  }
                  var newView = this.getMap().getView();
                  this.bindView_(newView);
                } else if (!this.ovmap_.isRendered() && (event.key === MapProperty.TARGET || event.key === MapProperty.SIZE)) {
                  this.ovmap_.updateSize();
                }
              };
              OverviewMap.prototype.bindView_ = function(view) {
                if (!this.view_) {
                  var newView = new ol_View({
                    projection: view.getProjection()
                  });
                  this.ovmap_.setView(newView);
                }
                view.addChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
                this.handleRotationChanged_();
              };
              OverviewMap.prototype.unbindView_ = function(view) {
                view.removeChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
              };
              OverviewMap.prototype.handleRotationChanged_ = function() {
                if (this.rotateWithView_) {
                  this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
                }
              };
              OverviewMap.prototype.validateExtent_ = function() {
                var map = this.getMap();
                var ovmap = this.ovmap_;
                if (!map.isRendered() || !ovmap.isRendered()) {
                  return;
                }
                var mapSize = (
                  /** @type {import("../size.js").Size} */
                  map.getSize()
                );
                var view = map.getView();
                var extent = view.calculateExtentInternal(mapSize);
                if (this.viewExtent_ && equals(extent, this.viewExtent_)) {
                  return;
                }
                this.viewExtent_ = extent;
                var ovmapSize = (
                  /** @type {import("../size.js").Size} */
                  ovmap.getSize()
                );
                var ovview = ovmap.getView();
                var ovextent = ovview.calculateExtentInternal(ovmapSize);
                var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
                var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
                var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
                var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
                var ovmapWidth = ovmapSize[0];
                var ovmapHeight = ovmapSize[1];
                if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
                  this.resetExtent_();
                } else if (!containsExtent(ovextent, extent)) {
                  this.recenter_();
                }
              };
              OverviewMap.prototype.resetExtent_ = function() {
                if (MAX_RATIO === 0 || MIN_RATIO === 0) {
                  return;
                }
                var map = this.getMap();
                var ovmap = this.ovmap_;
                var mapSize = (
                  /** @type {import("../size.js").Size} */
                  map.getSize()
                );
                var view = map.getView();
                var extent = view.calculateExtentInternal(mapSize);
                var ovview = ovmap.getView();
                var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
                var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
                scaleFromCenter(extent, ratio);
                ovview.fitInternal(fromExtent(extent));
              };
              OverviewMap.prototype.recenter_ = function() {
                var map = this.getMap();
                var ovmap = this.ovmap_;
                var view = map.getView();
                var ovview = ovmap.getView();
                ovview.setCenterInternal(view.getCenterInternal());
              };
              OverviewMap.prototype.updateBox_ = function() {
                var map = this.getMap();
                var ovmap = this.ovmap_;
                if (!map.isRendered() || !ovmap.isRendered()) {
                  return;
                }
                var mapSize = (
                  /** @type {import("../size.js").Size} */
                  map.getSize()
                );
                var view = map.getView();
                var ovview = ovmap.getView();
                var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
                var overlay = this.boxOverlay_;
                var box = this.boxOverlay_.getElement();
                var center = view.getCenterInternal();
                var resolution = view.getResolution();
                var ovresolution = ovview.getResolution();
                var width = mapSize[0] * resolution / ovresolution;
                var height = mapSize[1] * resolution / ovresolution;
                overlay.setPosition(center);
                if (box) {
                  box.style.width = width + "px";
                  box.style.height = height + "px";
                  var transform2 = "rotate(" + rotation + "rad)";
                  box.style.transform = transform2;
                }
              };
              OverviewMap.prototype.updateBoxAfterOvmapIsRendered_ = function() {
                if (this.ovmapPostrenderKey_) {
                  return;
                }
                this.ovmapPostrenderKey_ = Object(events[
                  "b"
                  /* listenOnce */
                ])(this.ovmap_, MapEventType[
                  "a"
                  /* default */
                ].POSTRENDER, function(event) {
                  delete this.ovmapPostrenderKey_;
                  this.updateBox_();
                }, this);
              };
              OverviewMap.prototype.handleClick_ = function(event) {
                event.preventDefault();
                this.handleToggle_();
              };
              OverviewMap.prototype.handleToggle_ = function() {
                this.element.classList.toggle(CLASS_COLLAPSED);
                if (this.collapsed_) {
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.collapseLabel_, this.label_);
                } else {
                  Object(dom[
                    "g"
                    /* replaceNode */
                  ])(this.label_, this.collapseLabel_);
                }
                this.collapsed_ = !this.collapsed_;
                var ovmap = this.ovmap_;
                if (!this.collapsed_) {
                  if (ovmap.isRendered()) {
                    this.viewExtent_ = void 0;
                    ovmap.render();
                    return;
                  }
                  ovmap.updateSize();
                  this.resetExtent_();
                  this.updateBoxAfterOvmapIsRendered_();
                }
              };
              OverviewMap.prototype.getCollapsible = function() {
                return this.collapsible_;
              };
              OverviewMap.prototype.setCollapsible = function(collapsible) {
                if (this.collapsible_ === collapsible) {
                  return;
                }
                this.collapsible_ = collapsible;
                this.element.classList.toggle("ol-uncollapsible");
                if (!collapsible && this.collapsed_) {
                  this.handleToggle_();
                }
              };
              OverviewMap.prototype.setCollapsed = function(collapsed) {
                if (!this.collapsible_ || this.collapsed_ === collapsed) {
                  return;
                }
                this.handleToggle_();
              };
              OverviewMap.prototype.getCollapsed = function() {
                return this.collapsed_;
              };
              OverviewMap.prototype.getRotateWithView = function() {
                return this.rotateWithView_;
              };
              OverviewMap.prototype.setRotateWithView = function(rotateWithView) {
                if (this.rotateWithView_ === rotateWithView) {
                  return;
                }
                this.rotateWithView_ = rotateWithView;
                if (this.getMap().getView().getRotation() !== 0) {
                  if (this.rotateWithView_) {
                    this.handleRotationChanged_();
                  } else {
                    this.ovmap_.getView().setRotation(0);
                  }
                  this.viewExtent_ = void 0;
                  this.validateExtent_();
                  this.updateBox_();
                }
              };
              OverviewMap.prototype.getOverviewMap = function() {
                return this.ovmap_;
              };
              OverviewMap.prototype.render = function(mapEvent) {
                this.validateExtent_();
                this.updateBox_();
              };
              return OverviewMap;
            }(Control["default"])
          );
          var control_OverviewMap = OverviewMap_OverviewMap;
          var OverviewMapControlvue_type_script_lang_js = {
            name: "ol-overviewmap-control",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _useControl = useControl(control_OverviewMap, props), control = _useControl.control;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                control.value.setMap(map);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                control.value.setMap(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("overviewMap", control);
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-overviewmap"
              },
              collapsed: {
                type: Boolean,
                default: true
              },
              collapseLabel: {
                type: String,
                default: ""
              },
              collapsible: {
                type: Boolean,
                default: true
              },
              label: {
                type: String,
                default: ""
              },
              render: {
                type: Function
              },
              rotateWithView: {
                type: Boolean,
                default: false
              },
              target: {
                type: HTMLElement
              },
              tipLabel: {
                type: String,
                default: "Overview map"
              }
            }
          };
          OverviewMapControlvue_type_script_lang_js.render = OverviewMapControlvue_type_template_id_7b327316_lang_true_render;
          var OverviewMapControl = OverviewMapControlvue_type_script_lang_js;
          var ScaleLineControlvue_type_template_id_99e20026_lang_true_hoisted_1 = {
            key: 0
          };
          function ScaleLineControlvue_type_template_id_99e20026_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ScaleLine_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var UNITS_PROP = "units";
          var ScaleLine_Units = {
            DEGREES: "degrees",
            IMPERIAL: "imperial",
            NAUTICAL: "nautical",
            METRIC: "metric",
            US: "us"
          };
          var LEADING_DIGITS = [1, 2, 5];
          var DEFAULT_DPI = 25.4 / 0.28;
          var ScaleLine_ScaleLine = (
            /** @class */
            function(_super) {
              ScaleLine_extends(ScaleLine, _super);
              function ScaleLine(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  render: options.render,
                  target: options.target
                }) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.innerElement_ = document.createElement("div");
                _this.innerElement_.className = className + "-inner";
                _this.element.className = className + " " + CLASS_UNSELECTABLE;
                _this.element.appendChild(_this.innerElement_);
                _this.viewState_ = null;
                _this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
                _this.renderedVisible_ = false;
                _this.renderedWidth_ = void 0;
                _this.renderedHTML_ = "";
                _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);
                _this.setUnits(options.units || ScaleLine_Units.METRIC);
                _this.scaleBar_ = options.bar || false;
                _this.scaleBarSteps_ = options.steps || 4;
                _this.scaleBarText_ = options.text || false;
                _this.dpi_ = options.dpi || void 0;
                return _this;
              }
              ScaleLine.prototype.getUnits = function() {
                return this.get(UNITS_PROP);
              };
              ScaleLine.prototype.handleUnitsChanged_ = function() {
                this.updateElement_();
              };
              ScaleLine.prototype.setUnits = function(units) {
                this.set(UNITS_PROP, units);
              };
              ScaleLine.prototype.setDpi = function(dpi) {
                this.dpi_ = dpi;
              };
              ScaleLine.prototype.updateElement_ = function() {
                var viewState = this.viewState_;
                if (!viewState) {
                  if (this.renderedVisible_) {
                    this.element.style.display = "none";
                    this.renderedVisible_ = false;
                  }
                  return;
                }
                var center = viewState.center;
                var projection = viewState.projection;
                var units = this.getUnits();
                var pointResolutionUnits = units == ScaleLine_Units.DEGREES ? proj_Units.DEGREES : proj_Units.METERS;
                var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
                var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
                var nominalCount = minWidth * pointResolution;
                var suffix = "";
                if (units == ScaleLine_Units.DEGREES) {
                  var metersPerDegree = METERS_PER_UNIT[proj_Units.DEGREES];
                  nominalCount *= metersPerDegree;
                  if (nominalCount < metersPerDegree / 60) {
                    suffix = "";
                    pointResolution *= 3600;
                  } else if (nominalCount < metersPerDegree) {
                    suffix = "";
                    pointResolution *= 60;
                  } else {
                    suffix = "";
                  }
                } else if (units == ScaleLine_Units.IMPERIAL) {
                  if (nominalCount < 0.9144) {
                    suffix = "in";
                    pointResolution /= 0.0254;
                  } else if (nominalCount < 1609.344) {
                    suffix = "ft";
                    pointResolution /= 0.3048;
                  } else {
                    suffix = "mi";
                    pointResolution /= 1609.344;
                  }
                } else if (units == ScaleLine_Units.NAUTICAL) {
                  pointResolution /= 1852;
                  suffix = "nm";
                } else if (units == ScaleLine_Units.METRIC) {
                  if (nominalCount < 1e-3) {
                    suffix = "m";
                    pointResolution *= 1e6;
                  } else if (nominalCount < 1) {
                    suffix = "mm";
                    pointResolution *= 1e3;
                  } else if (nominalCount < 1e3) {
                    suffix = "m";
                  } else {
                    suffix = "km";
                    pointResolution /= 1e3;
                  }
                } else if (units == ScaleLine_Units.US) {
                  if (nominalCount < 0.9144) {
                    suffix = "in";
                    pointResolution *= 39.37;
                  } else if (nominalCount < 1609.344) {
                    suffix = "ft";
                    pointResolution /= 0.30480061;
                  } else {
                    suffix = "mi";
                    pointResolution /= 1609.3472;
                  }
                } else {
                  assert2(false, 33);
                }
                var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
                var count, width, decimalCount;
                while (true) {
                  decimalCount = Math.floor(i / 3);
                  var decimal = Math.pow(10, decimalCount);
                  count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
                  width = Math.round(count / pointResolution);
                  if (isNaN(width)) {
                    this.element.style.display = "none";
                    this.renderedVisible_ = false;
                    return;
                  } else if (width >= minWidth) {
                    break;
                  }
                  ++i;
                }
                var html;
                if (this.scaleBar_) {
                  html = this.createScaleBar(width, count, suffix);
                } else {
                  html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
                }
                if (this.renderedHTML_ != html) {
                  this.innerElement_.innerHTML = html;
                  this.renderedHTML_ = html;
                }
                if (this.renderedWidth_ != width) {
                  this.innerElement_.style.width = width + "px";
                  this.renderedWidth_ = width;
                }
                if (!this.renderedVisible_) {
                  this.element.style.display = "";
                  this.renderedVisible_ = true;
                }
              };
              ScaleLine.prototype.createScaleBar = function(width, scale, suffix) {
                var mapScale = "1 : " + Math.round(this.getScaleForResolution()).toLocaleString();
                var scaleSteps = [];
                var stepWidth = width / this.scaleBarSteps_;
                var backgroundColor = "#ffffff";
                for (var i = 0; i < this.scaleBarSteps_; i++) {
                  if (i === 0) {
                    scaleSteps.push(this.createMarker("absolute", i));
                  }
                  scaleSteps.push('<div><div class="ol-scale-singlebar" style="width: ' + stepWidth + "px;background-color: " + backgroundColor + ';"></div>' + this.createMarker("relative", i) + /*render text every second step, except when only 2 steps */
                  (i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : "") + "</div>");
                  if (i === this.scaleBarSteps_ - 1) {
                    {
                    }
                    scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
                  }
                  if (backgroundColor === "#ffffff") {
                    backgroundColor = "#000000";
                  } else {
                    backgroundColor = "#ffffff";
                  }
                }
                var scaleBarText;
                if (this.scaleBarText_) {
                  scaleBarText = '<div class="ol-scale-text" style="width: ' + width + 'px;">' + mapScale + "</div>";
                } else {
                  scaleBarText = "";
                }
                var container = '<div style="display: flex;">' + scaleBarText + scaleSteps.join("") + "</div>";
                return container;
              };
              ScaleLine.prototype.createMarker = function(position, i) {
                var top = position === "absolute" ? 3 : -10;
                return '<div class="ol-scale-step-marker" style="position: ' + position + ";top: " + top + 'px;"></div>';
              };
              ScaleLine.prototype.createStepText = function(i, width, isLast, scale, suffix) {
                var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
                var lengthString = length + (i === 0 ? "" : " " + suffix);
                var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
                var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
                return '<div class="ol-scale-step-text" style="margin-left: ' + margin + "px;text-align: " + (i === 0 ? "left" : "center") + "; min-width: " + minWidth + "px;left: " + (isLast ? width + "px" : "unset") + ';">' + lengthString + "</div>";
              };
              ScaleLine.prototype.getScaleForResolution = function() {
                var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center);
                var dpi = this.dpi_ || DEFAULT_DPI;
                var mpu = this.viewState_.projection.getMetersPerUnit();
                var inchesPerMeter = 1e3 / 25.4;
                return parseFloat(resolution.toString()) * mpu * inchesPerMeter * dpi;
              };
              ScaleLine.prototype.render = function(mapEvent) {
                var frameState = mapEvent.frameState;
                if (!frameState) {
                  this.viewState_ = null;
                } else {
                  this.viewState_ = frameState.viewState;
                }
                this.updateElement_();
              };
              return ScaleLine;
            }(Control["default"])
          );
          var control_ScaleLine = ScaleLine_ScaleLine;
          var ScaleLineControlvue_type_script_lang_js = {
            name: "ol-scaleline-control",
            setup: function setup(props) {
              var _useControl = useControl(control_ScaleLine, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-scale-line"
              },
              minWidth: {
                type: Number,
                default: 64
              },
              render: {
                type: Function
              },
              target: {
                type: HTMLElement
              },
              units: {
                type: String,
                default: "metric"
              },
              bar: {
                type: Boolean,
                default: false
              },
              steps: {
                type: Number,
                default: 4
              },
              text: {
                type: Boolean,
                default: false
              },
              dpi: {
                type: Number,
                default: void 0
              }
            }
          };
          ScaleLineControlvue_type_script_lang_js.render = ScaleLineControlvue_type_template_id_99e20026_lang_true_render;
          var ScaleLineControl = ScaleLineControlvue_type_script_lang_js;
          var ZoomControlvue_type_template_id_482cf7da_lang_true_hoisted_1 = {
            key: 0
          };
          function ZoomControlvue_type_template_id_482cf7da_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ZoomControlvue_type_script_lang_js = {
            name: "ol-zoom-control",
            setup: function setup(props) {
              var _useControl = useControl(control_Zoom, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              duration: {
                type: Number,
                default: 250
              },
              className: {
                type: String,
                default: "ol-zoom"
              },
              zoomInClassName: {
                type: String,
                default: "ol-zoom-in"
              },
              zoomOutClassName: {
                type: String,
                default: "ol-zoom-out"
              },
              zoomInLabel: {
                type: String,
                default: "+"
              },
              zoomOutLabel: {
                type: String,
                default: "-"
              },
              zoomInTipLabel: {
                type: String,
                default: "Zoom in"
              },
              zoomOutTipLabel: {
                type: String,
                default: "Zoom Out"
              },
              delta: {
                type: Number,
                default: 1
              },
              target: {
                type: HTMLElement
              }
            }
          };
          ZoomControlvue_type_script_lang_js.render = ZoomControlvue_type_template_id_482cf7da_lang_true_render;
          var ZoomControl = ZoomControlvue_type_script_lang_js;
          var ZoomSliderControlvue_type_template_id_3c2a1e94_lang_true_hoisted_1 = {
            key: 0
          };
          function ZoomSliderControlvue_type_template_id_3c2a1e94_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ZoomSlider_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Direction = {
            VERTICAL: 0,
            HORIZONTAL: 1
          };
          var ZoomSlider_ZoomSlider = (
            /** @class */
            function(_super) {
              ZoomSlider_extends(ZoomSlider, _super);
              function ZoomSlider(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  render: options.render
                }) || this;
                _this.dragListenerKeys_ = [];
                _this.currentResolution_ = void 0;
                _this.direction_ = Direction.VERTICAL;
                _this.dragging_;
                _this.heightLimit_ = 0;
                _this.widthLimit_ = 0;
                _this.startX_;
                _this.startY_;
                _this.thumbSize_ = null;
                _this.sliderInitialized_ = false;
                _this.duration_ = options.duration !== void 0 ? options.duration : 200;
                var className = options.className !== void 0 ? options.className : "ol-zoomslider";
                var thumbElement = document.createElement("button");
                thumbElement.setAttribute("type", "button");
                thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
                var containerElement = _this.element;
                containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
                containerElement.appendChild(thumbElement);
                containerElement.addEventListener(pointer_EventType.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
                containerElement.addEventListener(pointer_EventType.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
                containerElement.addEventListener(pointer_EventType.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
                containerElement.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleContainerClick_.bind(_this), false);
                thumbElement.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, Event[
                  "b"
                  /* stopPropagation */
                ], false);
                return _this;
              }
              ZoomSlider.prototype.setMap = function(map) {
                _super.prototype.setMap.call(this, map);
                if (map) {
                  map.render();
                }
              };
              ZoomSlider.prototype.initSlider_ = function() {
                var container = this.element;
                var containerWidth = container.offsetWidth;
                var containerHeight = container.offsetHeight;
                if (containerWidth === 0 && containerHeight === 0) {
                  return this.sliderInitialized_ = false;
                }
                var containerStyle = getComputedStyle(container);
                containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
                containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
                var thumb = (
                  /** @type {HTMLElement} */
                  container.firstElementChild
                );
                var thumbStyle = getComputedStyle(thumb);
                var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
                var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
                this.thumbSize_ = [thumbWidth, thumbHeight];
                if (containerWidth > containerHeight) {
                  this.direction_ = Direction.HORIZONTAL;
                  this.widthLimit_ = containerWidth - thumbWidth;
                } else {
                  this.direction_ = Direction.VERTICAL;
                  this.heightLimit_ = containerHeight - thumbHeight;
                }
                return this.sliderInitialized_ = true;
              };
              ZoomSlider.prototype.handleContainerClick_ = function(event) {
                var view = this.getMap().getView();
                var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
                var resolution = this.getResolutionForPosition_(relativePosition);
                var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
                view.animateInternal({
                  zoom,
                  duration: this.duration_,
                  easing: easeOut
                });
              };
              ZoomSlider.prototype.handleDraggerStart_ = function(event) {
                if (!this.dragging_ && event.target === this.element.firstElementChild) {
                  var element = (
                    /** @type {HTMLElement} */
                    this.element.firstElementChild
                  );
                  this.getMap().getView().beginInteraction();
                  this.startX_ = event.clientX - parseFloat(element.style.left);
                  this.startY_ = event.clientY - parseFloat(element.style.top);
                  this.dragging_ = true;
                  if (this.dragListenerKeys_.length === 0) {
                    var drag = this.handleDraggerDrag_;
                    var end = this.handleDraggerEnd_;
                    var doc = this.getMap().getOwnerDocument();
                    this.dragListenerKeys_.push(Object(events[
                      "a"
                      /* listen */
                    ])(doc, pointer_EventType.POINTERMOVE, drag, this), Object(events[
                      "a"
                      /* listen */
                    ])(doc, pointer_EventType.POINTERUP, end, this));
                  }
                }
              };
              ZoomSlider.prototype.handleDraggerDrag_ = function(event) {
                if (this.dragging_) {
                  var deltaX = event.clientX - this.startX_;
                  var deltaY = event.clientY - this.startY_;
                  var relativePosition = this.getRelativePosition_(deltaX, deltaY);
                  this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
                  this.getMap().getView().setResolution(this.currentResolution_);
                }
              };
              ZoomSlider.prototype.handleDraggerEnd_ = function(event) {
                if (this.dragging_) {
                  var view = this.getMap().getView();
                  view.endInteraction();
                  this.dragging_ = false;
                  this.startX_ = void 0;
                  this.startY_ = void 0;
                  this.dragListenerKeys_.forEach(events[
                    "c"
                    /* unlistenByKey */
                  ]);
                  this.dragListenerKeys_.length = 0;
                }
              };
              ZoomSlider.prototype.setThumbPosition_ = function(res) {
                var position = this.getPositionForResolution_(res);
                var thumb = (
                  /** @type {HTMLElement} */
                  this.element.firstElementChild
                );
                if (this.direction_ == Direction.HORIZONTAL) {
                  thumb.style.left = this.widthLimit_ * position + "px";
                } else {
                  thumb.style.top = this.heightLimit_ * position + "px";
                }
              };
              ZoomSlider.prototype.getRelativePosition_ = function(x, y) {
                var amount;
                if (this.direction_ === Direction.HORIZONTAL) {
                  amount = x / this.widthLimit_;
                } else {
                  amount = y / this.heightLimit_;
                }
                return clamp(amount, 0, 1);
              };
              ZoomSlider.prototype.getResolutionForPosition_ = function(position) {
                var fn = this.getMap().getView().getResolutionForValueFunction();
                return fn(1 - position);
              };
              ZoomSlider.prototype.getPositionForResolution_ = function(res) {
                var fn = this.getMap().getView().getValueForResolutionFunction();
                return clamp(1 - fn(res), 0, 1);
              };
              ZoomSlider.prototype.render = function(mapEvent) {
                if (!mapEvent.frameState) {
                  return;
                }
                if (!this.sliderInitialized_ && !this.initSlider_()) {
                  return;
                }
                var res = mapEvent.frameState.viewState.resolution;
                this.currentResolution_ = res;
                this.setThumbPosition_(res);
              };
              return ZoomSlider;
            }(Control["default"])
          );
          var control_ZoomSlider = ZoomSlider_ZoomSlider;
          var ZoomSliderControlvue_type_script_lang_js = {
            name: "ol-zoomslider-control",
            setup: function setup(props) {
              var _useControl = useControl(control_ZoomSlider, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              duration: {
                type: Number,
                default: 200
              },
              className: {
                type: String,
                default: "ol-zoomslider"
              },
              render: {
                type: Function
              }
            }
          };
          ZoomSliderControlvue_type_script_lang_js.render = ZoomSliderControlvue_type_template_id_3c2a1e94_lang_true_render;
          var ZoomSliderControl = ZoomSliderControlvue_type_script_lang_js;
          var ZoomToExtentControlvue_type_template_id_64c32a57_lang_true_hoisted_1 = {
            key: 0
          };
          function ZoomToExtentControlvue_type_template_id_64c32a57_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ZoomToExtent_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ZoomToExtent_ZoomToExtent = (
            /** @class */
            function(_super) {
              ZoomToExtent_extends(ZoomToExtent, _super);
              function ZoomToExtent(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this, {
                  element: document.createElement("div"),
                  target: options.target
                }) || this;
                _this.extent = options.extent ? options.extent : null;
                var className = options.className !== void 0 ? options.className : "ol-zoom-extent";
                var label = options.label !== void 0 ? options.label : "E";
                var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Fit to extent";
                var button = document.createElement("button");
                button.setAttribute("type", "button");
                button.title = tipLabel;
                button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
                button.addEventListener(EventType[
                  "a"
                  /* default */
                ].CLICK, _this.handleClick_.bind(_this), false);
                var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
                var element = _this.element;
                element.className = cssClasses;
                element.appendChild(button);
                return _this;
              }
              ZoomToExtent.prototype.handleClick_ = function(event) {
                event.preventDefault();
                this.handleZoomToExtent();
              };
              ZoomToExtent.prototype.handleZoomToExtent = function() {
                var map = this.getMap();
                var view = map.getView();
                var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
                view.fitInternal(fromExtent(extent));
              };
              return ZoomToExtent;
            }(Control["default"])
          );
          var control_ZoomToExtent = ZoomToExtent_ZoomToExtent;
          var ZoomToExtentControlvue_type_script_lang_js = {
            name: "ol-zoomtoextent-control",
            setup: function setup(props) {
              var _useControl = useControl(control_ZoomToExtent, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-zoom-extent"
              },
              target: {
                type: HTMLElement
              },
              label: {
                type: String,
                default: "E"
              },
              tipLabel: {
                type: String,
                default: "Fit to extent"
              },
              extent: {
                type: Array
              }
            }
          };
          ZoomToExtentControlvue_type_script_lang_js.render = ZoomToExtentControlvue_type_template_id_64c32a57_lang_true_render;
          var ZoomToExtentControl = ZoomToExtentControlvue_type_script_lang_js;
          var RotateControlvue_type_template_id_6632c718_lang_true_hoisted_1 = {
            key: 0
          };
          function RotateControlvue_type_template_id_6632c718_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var RotateControlvue_type_script_lang_js = {
            name: "ol-rotate-control",
            setup: function setup(props) {
              var _useControl = useControl(control_Rotate, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              className: {
                type: String,
                default: "ol-rotate"
              },
              label: {
                type: String,
                default: ""
              },
              tipLabel: {
                type: String,
                default: "Reset rotation"
              },
              compassClassName: {
                type: String,
                default: "ol-compass"
              },
              duration: {
                type: Number,
                default: 250
              },
              autoHide: {
                type: Boolean,
                default: false
              },
              render: {
                type: Function
              },
              resetNorth: {
                type: Function
              },
              target: {
                type: HTMLElement
              }
            }
          };
          RotateControlvue_type_script_lang_js.render = RotateControlvue_type_template_id_6632c718_lang_true_render;
          var RotateControl = RotateControlvue_type_script_lang_js;
          var ContextMenuControlvue_type_template_id_8781ee72_lang_true_hoisted_1 = {
            key: 0
          };
          function ContextMenuControlvue_type_template_id_8781ee72_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ol_contextmenu = __webpack_require__("658f");
          var ol_contextmenu_default = __webpack_require__.n(ol_contextmenu);
          var ContextMenuControlvue_type_script_lang_js = {
            name: "ol-context-menu",
            setup: function setup(props) {
              var _useControl = useControl(ol_contextmenu_default.a, props), control = _useControl.control;
              return {
                control
              };
            },
            props: {
              eventType: {
                type: String,
                default: "contextmenu"
              },
              defaultItems: {
                type: Boolean,
                default: true
              },
              width: {
                type: Number,
                default: 150
              },
              items: {
                type: Array,
                default: function _default() {
                  return [];
                }
              }
            }
          };
          ContextMenuControlvue_type_script_lang_js.render = ContextMenuControlvue_type_template_id_8781ee72_lang_true_render;
          var ContextMenuControl = ContextMenuControlvue_type_script_lang_js;
          var SwipeControlvue_type_template_id_0e9cd29c_lang_true_hoisted_1 = {
            key: 0
          };
          function SwipeControlvue_type_template_id_0e9cd29c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var ol_control_Swipe = function(options) {
            options = options || {};
            var button = document.createElement("button");
            var element = document.createElement("div");
            element.className = (options.className || "ol-swipe") + " ol-unselectable ol-control";
            element.appendChild(button);
            element.addEventListener("mousedown", this.move.bind(this));
            element.addEventListener("touchstart", this.move.bind(this));
            Control["default"].call(this, {
              element
            });
            this.precomposeRight_ = this.precomposeRight.bind(this);
            this.precomposeLeft_ = this.precomposeLeft.bind(this);
            this.postcompose_ = this.postcompose.bind(this);
            this.layers = [];
            if (options.layers) this.addLayer(options.layers, false);
            if (options.rightLayers) this.addLayer(options.rightLayers, true);
            this.on("propertychange", (function() {
              if (this.getMap()) this.getMap().renderSync();
              if (this.get("orientation") === "horizontal") {
                this.element.style.top = this.get("position") * 100 + "%";
                this.element.style.left = "";
              } else {
                if (this.get("orientation") !== "vertical") this.set("orientation", "vertical");
                this.element.style.left = this.get("position") * 100 + "%";
                this.element.style.top = "";
              }
              this.element.classList.remove("horizontal", "vertical");
              this.element.classList.add(this.get("orientation"));
            }).bind(this));
            this.set("position", options.position || 0.5);
            this.set("orientation", options.orientation || "vertical");
          };
          util_ext(ol_control_Swipe, Control["default"]);
          ol_control_Swipe.prototype.setMap = function(map) {
            var i;
            var l;
            if (this.getMap()) {
              for (i = 0; i < this.layers.length; i++) {
                l = this.layers[i];
                if (l.right) l.layer.un(["precompose", "prerender"], this.precomposeRight_);
                else l.layer.un(["precompose", "prerender"], this.precomposeLeft_);
                l.layer.un(["postcompose", "postrender"], this.postcompose_);
              }
              this.getMap().renderSync();
            }
            Control["default"].prototype.setMap.call(this, map);
            if (map) {
              this._listener = [];
              for (i = 0; i < this.layers.length; i++) {
                l = this.layers[i];
                if (l.right) l.layer.on(["precompose", "prerender"], this.precomposeRight_);
                else l.layer.on(["precompose", "prerender"], this.precomposeLeft_);
                l.layer.on(["postcompose", "postrender"], this.postcompose_);
              }
              map.renderSync();
            }
          };
          ol_control_Swipe.prototype.isLayer_ = function(layer) {
            for (var k = 0; k < this.layers.length; k++) {
              if (this.layers[k].layer === layer) return k;
            }
            return -1;
          };
          ol_control_Swipe.prototype.addLayer = function(layers, right) {
            if (!(layers instanceof Array)) layers = [layers];
            for (var i = 0; i < layers.length; i++) {
              var l = layers[i];
              if (this.isLayer_(l) < 0) {
                this.layers.push({ layer: l, right });
                if (this.getMap()) {
                  if (right) l.on(["precompose", "prerender"], this.precomposeRight_);
                  else l.on(["precompose", "prerender"], this.precomposeLeft_);
                  l.on(["postcompose", "postrender"], this.postcompose_);
                  this.getMap().renderSync();
                }
              }
            }
          };
          ol_control_Swipe.prototype.removeLayer = function(layers) {
            if (!(layers instanceof Array)) layers = [layers];
            for (var i = 0; i < layers.length; i++) {
              var k = this.isLayer_(layers[i]);
              if (k >= 0 && this.getMap()) {
                if (this.layers[k].right) layers[i].un(["precompose", "prerender"], this.precomposeRight_);
                else layers[i].un(["precompose", "prerender"], this.precomposeLeft_);
                layers[i].un(["postcompose", "postrender"], this.postcompose_);
                this.layers.splice(k, 1);
                this.getMap().renderSync();
              }
            }
          };
          ol_control_Swipe.prototype.move = function(e) {
            var self2 = this;
            var l;
            switch (e.type) {
              case "touchcancel":
              case "touchend":
              case "mouseup": {
                self2.isMoving = false;
                ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
                  document.removeEventListener(eventName, self2.move);
                });
                break;
              }
              case "mousedown":
              case "touchstart": {
                self2.isMoving = true;
                ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
                  document.addEventListener(eventName, self2.move.bind(self2));
                });
              }
              // fallthrough
              case "mousemove":
              case "touchmove": {
                if (self2.isMoving) {
                  if (self2.get("orientation") === "vertical") {
                    var pageX = e.pageX || e.touches && e.touches.length && e.touches[0].pageX || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageX;
                    if (!pageX) break;
                    pageX -= self2.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft;
                    l = self2.getMap().getSize()[0];
                    l = Math.min(Math.max(0, 1 - (l - pageX) / l), 1);
                    self2.set("position", l);
                  } else {
                    var pageY = e.pageY || e.touches && e.touches.length && e.touches[0].pageY || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageY;
                    if (!pageY) break;
                    pageY -= self2.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;
                    l = self2.getMap().getSize()[1];
                    l = Math.min(Math.max(0, 1 - (l - pageY) / l), 1);
                    self2.set("position", l);
                  }
                }
                break;
              }
              default:
                break;
            }
          };
          ol_control_Swipe.prototype._drawRect = function(e, pts) {
            var tr = e.inversePixelTransform;
            if (tr) {
              var r = [
                [pts[0][0], pts[0][1]],
                [pts[0][0], pts[1][1]],
                [pts[1][0], pts[1][1]],
                [pts[1][0], pts[0][1]],
                [pts[0][0], pts[0][1]]
              ];
              r.forEach(function(pt, i) {
                pt = [
                  pt[0] * tr[0] - pt[1] * tr[1] + tr[4],
                  -pt[0] * tr[2] + pt[1] * tr[3] + tr[5]
                ];
                if (!i) {
                  e.context.moveTo(pt[0], pt[1]);
                } else {
                  e.context.lineTo(pt[0], pt[1]);
                }
              });
            } else {
              var ratio = e.frameState.pixelRatio;
              e.context.rect(pts[0][0] * ratio, pts[0][1] * ratio, pts[1][0] * ratio, pts[1][1] * ratio);
            }
          };
          ol_control_Swipe.prototype.precomposeLeft = function(e) {
            var ctx = e.context;
            var size = e.frameState.size;
            ctx.save();
            ctx.beginPath();
            var pts = [[0, 0], [size[0], size[1]]];
            if (this.get("orientation") === "vertical") {
              pts[1] = [
                size[0] * this.get("position"),
                size[1]
              ];
            } else {
              pts[1] = [
                size[0],
                size[1] * this.get("position")
              ];
            }
            this._drawRect(e, pts);
            ctx.clip();
          };
          ol_control_Swipe.prototype.precomposeRight = function(e) {
            var ctx = e.context;
            var size = e.frameState.size;
            ctx.save();
            ctx.beginPath();
            var pts = [[0, 0], [size[0], size[1]]];
            if (this.get("orientation") === "vertical") {
              pts[0] = [
                size[0] * this.get("position"),
                0
              ];
            } else {
              pts[0] = [
                0,
                size[1] * this.get("position")
              ];
            }
            this._drawRect(e, pts);
            ctx.clip();
          };
          ol_control_Swipe.prototype.postcompose = function(e) {
            if (e.target.getClassName && e.target.getClassName() !== "ol-layer" && e.target.get("declutter")) {
              setTimeout(function() {
                e.context.restore();
              }, 0);
            } else {
              e.context.restore();
            }
          };
          var Swipe = ol_control_Swipe;
          var SwipeControlvue_type_script_lang_js = {
            name: "ol-swipe-control",
            setup: function setup(props) {
              var _useControl = useControl(Swipe, props), control = _useControl.control;
              var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), layerList = _toRefs.layerList;
              layerList.value.forEach(function(layer, index) {
                control.value.addLayer(layer, index == 1 ? true : false);
              });
              return {
                control
              };
            },
            props: {
              layerList: {
                type: Array
              },
              className: {
                type: String,
                default: "ol-swipe"
              },
              position: {
                type: Number,
                default: 0.5
              },
              orientation: {
                type: String,
                default: "vertical"
              }
            }
          };
          SwipeControlvue_type_script_lang_js.render = SwipeControlvue_type_template_id_0e9cd29c_lang_true_render;
          var SwipeControl = SwipeControlvue_type_script_lang_js;
          function mapControls_install(app) {
            if (mapControls_install.installed) {
              return;
            }
            mapControls_install.installed = true;
            app.component(FullScreenControl.name, FullScreenControl);
            app.component(MousePositionControl.name, MousePositionControl);
            app.component(AttributionControl.name, AttributionControl);
            app.component(OverviewMapControl.name, OverviewMapControl);
            app.component(ScaleLineControl.name, ScaleLineControl);
            app.component(ZoomControl.name, ZoomControl);
            app.component(ZoomSliderControl.name, ZoomSliderControl);
            app.component(ZoomToExtentControl.name, ZoomToExtentControl);
            app.component(RotateControl.name, RotateControl);
            app.component(ContextMenuControl.name, ContextMenuControl);
            app.component(SwipeControl.name, SwipeControl);
          }
          var mapControls = mapControls_install;
          var Pointvue_type_template_id_143d56c0_lang_true_hoisted_1 = {
            key: 0
          };
          function Pointvue_type_template_id_143d56c0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var es_reflect_construct = __webpack_require__("4ae1");
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === "function") return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function construct_construct(Parent, args, Class) {
            if (_isNativeReflectConstruct()) {
              construct_construct = Reflect.construct;
            } else {
              construct_construct = function _construct(Parent2, args2, Class2) {
                var a = [null];
                a.push.apply(a, args2);
                var Constructor = Function.bind.apply(Parent2, a);
                var instance = new Constructor();
                if (Class2) _setPrototypeOf(instance, Class2.prototype);
                return instance;
              };
            }
            return construct_construct.apply(null, arguments);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
          }
          var es_symbol_description = __webpack_require__("e01a");
          var es_object_to_string = __webpack_require__("d3b7");
          var es_symbol_iterator = __webpack_require__("d28b");
          var es_array_iterator = __webpack_require__("e260");
          var es_string_iterator = __webpack_require__("3ca3");
          var web_dom_collections_iterator = __webpack_require__("ddb0");
          var es_array_from = __webpack_require__("a630");
          function _iterableToArray(iter) {
            if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
          }
          var es_array_slice = __webpack_require__("fb6a");
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
          }
          var es_object_values = __webpack_require__("07ac");
          function useGeometry(GeometryType, props) {
            var feature = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("feature");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var geometry = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return construct_construct(GeometryType, _toConsumableArray(Object.values(properties)));
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              feature.value.setGeometry(geometry.value);
              feature.value.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(feature, function() {
              feature.value.setGeometry(geometry.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              feature.value.setGeometry(geometry.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              feature.value.setGeometry(null);
            });
            return {
              geometry
            };
          }
          var Pointvue_type_script_lang_js = {
            name: "ol-geom-point",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_Point, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          Pointvue_type_script_lang_js.render = Pointvue_type_template_id_143d56c0_lang_true_render;
          var geometries_Point = Pointvue_type_script_lang_js;
          var LineStringvue_type_template_id_f9d04fd0_lang_true_hoisted_1 = {
            key: 0
          };
          function LineStringvue_type_template_id_f9d04fd0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
            var o, t;
            var n = (end - offset) / stride;
            if (n === 1) {
              o = offset;
            } else if (n === 2) {
              o = offset;
              t = fraction;
            } else if (n !== 0) {
              var x1 = flatCoordinates[offset];
              var y1 = flatCoordinates[offset + 1];
              var length_1 = 0;
              var cumulativeLengths = [0];
              for (var i = offset + stride; i < end; i += stride) {
                var x2 = flatCoordinates[i];
                var y2 = flatCoordinates[i + 1];
                length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                cumulativeLengths.push(length_1);
                x1 = x2;
                y1 = y2;
              }
              var target = fraction * length_1;
              var index = Object(ol_array[
                "a"
                /* binarySearch */
              ])(cumulativeLengths, target);
              if (index < 0) {
                t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
                o = offset + (-index - 2) * stride;
              } else {
                o = offset + index * stride;
              }
            }
            var dimension = opt_dimension > 1 ? opt_dimension : 2;
            var dest = opt_dest ? opt_dest : new Array(dimension);
            for (var i = 0; i < dimension; ++i) {
              dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
            }
            return dest;
          }
          function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
            if (end == offset) {
              return null;
            }
            var coordinate;
            if (m < flatCoordinates[offset + stride - 1]) {
              if (extrapolate) {
                coordinate = flatCoordinates.slice(offset, offset + stride);
                coordinate[stride - 1] = m;
                return coordinate;
              } else {
                return null;
              }
            } else if (flatCoordinates[end - 1] < m) {
              if (extrapolate) {
                coordinate = flatCoordinates.slice(end - stride, end);
                coordinate[stride - 1] = m;
                return coordinate;
              } else {
                return null;
              }
            }
            if (m == flatCoordinates[offset + stride - 1]) {
              return flatCoordinates.slice(offset, offset + stride);
            }
            var lo = offset / stride;
            var hi = end / stride;
            while (lo < hi) {
              var mid = lo + hi >> 1;
              if (m < flatCoordinates[(mid + 1) * stride - 1]) {
                hi = mid;
              } else {
                lo = mid + 1;
              }
            }
            var m0 = flatCoordinates[lo * stride - 1];
            if (m == m0) {
              return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
            }
            var m1 = flatCoordinates[(lo + 1) * stride - 1];
            var t = (m - m0) / (m1 - m0);
            coordinate = [];
            for (var i = 0; i < stride - 1; ++i) {
              coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
            }
            coordinate.push(m);
            return coordinate;
          }
          function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
            if (interpolate) {
              return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
            }
            var coordinate;
            if (m < flatCoordinates[stride - 1]) {
              if (extrapolate) {
                coordinate = flatCoordinates.slice(0, stride);
                coordinate[stride - 1] = m;
                return coordinate;
              } else {
                return null;
              }
            }
            if (flatCoordinates[flatCoordinates.length - 1] < m) {
              if (extrapolate) {
                coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
                coordinate[stride - 1] = m;
                return coordinate;
              } else {
                return null;
              }
            }
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              if (offset == end) {
                continue;
              }
              if (m < flatCoordinates[offset + stride - 1]) {
                return null;
              } else if (m <= flatCoordinates[end - 1]) {
                return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
              }
              offset = end;
            }
            return null;
          }
          var LineString_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LineString_LineString = (
            /** @class */
            function(_super) {
              LineString_extends(LineString, _super);
              function LineString(coordinates, opt_layout) {
                var _this = _super.call(this) || this;
                _this.flatMidpoint_ = null;
                _this.flatMidpointRevision_ = -1;
                _this.maxDelta_ = -1;
                _this.maxDeltaRevision_ = -1;
                if (opt_layout !== void 0 && !Array.isArray(coordinates[0])) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                } else {
                  _this.setCoordinates(
                    /** @type {Array<import("../coordinate.js").Coordinate>} */
                    coordinates,
                    opt_layout
                  );
                }
                return _this;
              }
              LineString.prototype.appendCoordinate = function(coordinate) {
                if (!this.flatCoordinates) {
                  this.flatCoordinates = coordinate.slice();
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(this.flatCoordinates, coordinate);
                }
                this.changed();
              };
              LineString.prototype.clone = function() {
                var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
                lineString.applyProperties(this);
                return lineString;
              };
              LineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                if (this.maxDeltaRevision_ != this.getRevision()) {
                  this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
                  this.maxDeltaRevision_ = this.getRevision();
                }
                return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
              };
              LineString.prototype.forEachSegment = function(callback) {
                return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
              };
              LineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {
                if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {
                  return null;
                }
                var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
                return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
              };
              LineString.prototype.getCoordinates = function() {
                return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
              };
              LineString.prototype.getCoordinateAt = function(fraction, opt_dest) {
                return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
              };
              LineString.prototype.getLength = function() {
                return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
              };
              LineString.prototype.getFlatMidpoint = function() {
                if (this.flatMidpointRevision_ != this.getRevision()) {
                  this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
                  this.flatMidpointRevision_ = this.getRevision();
                }
                return this.flatMidpoint_;
              };
              LineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                var simplifiedFlatCoordinates = [];
                simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
                return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
              };
              LineString.prototype.getType = function() {
                return geom_GeometryType.LINE_STRING;
              };
              LineString.prototype.intersectsExtent = function(extent) {
                return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
              };
              LineString.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 1);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
                this.changed();
              };
              return LineString;
            }(geom_SimpleGeometry)
          );
          var geom_LineString = LineString_LineString;
          var LineStringvue_type_script_lang_js = {
            name: "ol-geom-line-string",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_LineString, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          LineStringvue_type_script_lang_js.render = LineStringvue_type_template_id_f9d04fd0_lang_true_render;
          var geometries_LineString = LineStringvue_type_script_lang_js;
          var Polygonvue_type_template_id_ae08142c_lang_true_hoisted_1 = {
            key: 0
          };
          function Polygonvue_type_template_id_ae08142c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var Polygonvue_type_script_lang_js = {
            name: "ol-geom-polygon",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_Polygon, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          Polygonvue_type_script_lang_js.render = Polygonvue_type_template_id_ae08142c_lang_true_render;
          var geometries_Polygon = Polygonvue_type_script_lang_js;
          var MultiPointvue_type_template_id_5f21b834_lang_true_hoisted_1 = {
            key: 0
          };
          function MultiPointvue_type_template_id_5f21b834_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var MultiPoint_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MultiPoint_MultiPoint = (
            /** @class */
            function(_super) {
              MultiPoint_extends(MultiPoint, _super);
              function MultiPoint(coordinates, opt_layout) {
                var _this = _super.call(this) || this;
                if (opt_layout && !Array.isArray(coordinates[0])) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                } else {
                  _this.setCoordinates(
                    /** @type {Array<import("../coordinate.js").Coordinate>} */
                    coordinates,
                    opt_layout
                  );
                }
                return _this;
              }
              MultiPoint.prototype.appendPoint = function(point) {
                if (!this.flatCoordinates) {
                  this.flatCoordinates = point.getFlatCoordinates().slice();
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(this.flatCoordinates, point.getFlatCoordinates());
                }
                this.changed();
              };
              MultiPoint.prototype.clone = function() {
                var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
                multiPoint.applyProperties(this);
                return multiPoint;
              };
              MultiPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                var flatCoordinates = this.flatCoordinates;
                var stride = this.stride;
                for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                  var squaredDistance = math_squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
                  if (squaredDistance < minSquaredDistance) {
                    minSquaredDistance = squaredDistance;
                    for (var j = 0; j < stride; ++j) {
                      closestPoint[j] = flatCoordinates[i + j];
                    }
                    closestPoint.length = stride;
                  }
                }
                return minSquaredDistance;
              };
              MultiPoint.prototype.getCoordinates = function() {
                return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
              };
              MultiPoint.prototype.getPoint = function(index) {
                var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
                if (index < 0 || n <= index) {
                  return null;
                }
                return new geom_Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
              };
              MultiPoint.prototype.getPoints = function() {
                var flatCoordinates = this.flatCoordinates;
                var layout = this.layout;
                var stride = this.stride;
                var points = [];
                for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                  var point = new geom_Point(flatCoordinates.slice(i, i + stride), layout);
                  points.push(point);
                }
                return points;
              };
              MultiPoint.prototype.getType = function() {
                return geom_GeometryType.MULTI_POINT;
              };
              MultiPoint.prototype.intersectsExtent = function(extent) {
                var flatCoordinates = this.flatCoordinates;
                var stride = this.stride;
                for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
                  var x = flatCoordinates[i];
                  var y = flatCoordinates[i + 1];
                  if (containsXY(extent, x, y)) {
                    return true;
                  }
                }
                return false;
              };
              MultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 1);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
                this.changed();
              };
              return MultiPoint;
            }(geom_SimpleGeometry)
          );
          var geom_MultiPoint = MultiPoint_MultiPoint;
          var MultiPointvue_type_script_lang_js = {
            name: "ol-geom-multi-point",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_MultiPoint, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          MultiPointvue_type_script_lang_js.render = MultiPointvue_type_template_id_5f21b834_lang_true_render;
          var geometries_MultiPoint = MultiPointvue_type_script_lang_js;
          var MultiLineStringvue_type_template_id_2c3e6a36_lang_true_hoisted_1 = {
            key: 0
          };
          function MultiLineStringvue_type_template_id_2c3e6a36_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var MultiLineString_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MultiLineString_MultiLineString = (
            /** @class */
            function(_super) {
              MultiLineString_extends(MultiLineString, _super);
              function MultiLineString(coordinates, opt_layout, opt_ends) {
                var _this = _super.call(this) || this;
                _this.ends_ = [];
                _this.maxDelta_ = -1;
                _this.maxDeltaRevision_ = -1;
                if (Array.isArray(coordinates[0])) {
                  _this.setCoordinates(
                    /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
                    coordinates,
                    opt_layout
                  );
                } else if (opt_layout !== void 0 && opt_ends) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                  _this.ends_ = opt_ends;
                } else {
                  var layout = _this.getLayout();
                  var lineStrings = (
                    /** @type {Array<LineString>} */
                    coordinates
                  );
                  var flatCoordinates = [];
                  var ends = [];
                  for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                    var lineString = lineStrings[i];
                    if (i === 0) {
                      layout = lineString.getLayout();
                    }
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(flatCoordinates, lineString.getFlatCoordinates());
                    ends.push(flatCoordinates.length);
                  }
                  _this.setFlatCoordinates(layout, flatCoordinates);
                  _this.ends_ = ends;
                }
                return _this;
              }
              MultiLineString.prototype.appendLineString = function(lineString) {
                if (!this.flatCoordinates) {
                  this.flatCoordinates = lineString.getFlatCoordinates().slice();
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
                }
                this.ends_.push(this.flatCoordinates.length);
                this.changed();
              };
              MultiLineString.prototype.clone = function() {
                var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
                multiLineString.applyProperties(this);
                return multiLineString;
              };
              MultiLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                if (this.maxDeltaRevision_ != this.getRevision()) {
                  this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
                  this.maxDeltaRevision_ = this.getRevision();
                }
                return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
              };
              MultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {
                if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {
                  return null;
                }
                var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
                var interpolate = opt_interpolate !== void 0 ? opt_interpolate : false;
                return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
              };
              MultiLineString.prototype.getCoordinates = function() {
                return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
              };
              MultiLineString.prototype.getEnds = function() {
                return this.ends_;
              };
              MultiLineString.prototype.getLineString = function(index) {
                if (index < 0 || this.ends_.length <= index) {
                  return null;
                }
                return new geom_LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
              };
              MultiLineString.prototype.getLineStrings = function() {
                var flatCoordinates = this.flatCoordinates;
                var ends = this.ends_;
                var layout = this.layout;
                var lineStrings = [];
                var offset = 0;
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  var end = ends[i];
                  var lineString = new geom_LineString(flatCoordinates.slice(offset, end), layout);
                  lineStrings.push(lineString);
                  offset = end;
                }
                return lineStrings;
              };
              MultiLineString.prototype.getFlatMidpoints = function() {
                var midpoints = [];
                var flatCoordinates = this.flatCoordinates;
                var offset = 0;
                var ends = this.ends_;
                var stride = this.stride;
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  var end = ends[i];
                  var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(midpoints, midpoint);
                  offset = end;
                }
                return midpoints;
              };
              MultiLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                var simplifiedFlatCoordinates = [];
                var simplifiedEnds = [];
                simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
                return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
              };
              MultiLineString.prototype.getType = function() {
                return geom_GeometryType.MULTI_LINE_STRING;
              };
              MultiLineString.prototype.intersectsExtent = function(extent) {
                return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
              };
              MultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 2);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
                this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
                this.changed();
              };
              return MultiLineString;
            }(geom_SimpleGeometry)
          );
          var geom_MultiLineString = MultiLineString_MultiLineString;
          var MultiLineStringvue_type_script_lang_js = {
            name: "ol-geom-multi-line-string",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_MultiLineString, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          MultiLineStringvue_type_script_lang_js.render = MultiLineStringvue_type_template_id_2c3e6a36_lang_true_render;
          var geometries_MultiLineString = MultiLineStringvue_type_script_lang_js;
          var MultiPolygonvue_type_template_id_abbb2b88_lang_true_hoisted_1 = {
            key: 0
          };
          function MultiPolygonvue_type_template_id_abbb2b88_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          function center_linearRingss(flatCoordinates, offset, endss, stride) {
            var flatCenters = [];
            var extent = createEmpty();
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i];
              extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
              flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
              offset = ends[ends.length - 1];
            }
            return flatCenters;
          }
          var MultiPolygon_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MultiPolygon_MultiPolygon = (
            /** @class */
            function(_super) {
              MultiPolygon_extends(MultiPolygon, _super);
              function MultiPolygon(coordinates, opt_layout, opt_endss) {
                var _this = _super.call(this) || this;
                _this.endss_ = [];
                _this.flatInteriorPointsRevision_ = -1;
                _this.flatInteriorPoints_ = null;
                _this.maxDelta_ = -1;
                _this.maxDeltaRevision_ = -1;
                _this.orientedRevision_ = -1;
                _this.orientedFlatCoordinates_ = null;
                if (!opt_endss && !Array.isArray(coordinates[0])) {
                  var layout = _this.getLayout();
                  var polygons = (
                    /** @type {Array<Polygon>} */
                    coordinates
                  );
                  var flatCoordinates = [];
                  var endss = [];
                  for (var i = 0, ii = polygons.length; i < ii; ++i) {
                    var polygon = polygons[i];
                    if (i === 0) {
                      layout = polygon.getLayout();
                    }
                    var offset = flatCoordinates.length;
                    var ends = polygon.getEnds();
                    for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] += offset;
                    }
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(flatCoordinates, polygon.getFlatCoordinates());
                    endss.push(ends);
                  }
                  opt_layout = layout;
                  coordinates = flatCoordinates;
                  opt_endss = endss;
                }
                if (opt_layout !== void 0 && opt_endss) {
                  _this.setFlatCoordinates(
                    opt_layout,
                    /** @type {Array<number>} */
                    coordinates
                  );
                  _this.endss_ = opt_endss;
                } else {
                  _this.setCoordinates(
                    /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
                    coordinates,
                    opt_layout
                  );
                }
                return _this;
              }
              MultiPolygon.prototype.appendPolygon = function(polygon) {
                var ends;
                if (!this.flatCoordinates) {
                  this.flatCoordinates = polygon.getFlatCoordinates().slice();
                  ends = polygon.getEnds().slice();
                  this.endss_.push();
                } else {
                  var offset = this.flatCoordinates.length;
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(this.flatCoordinates, polygon.getFlatCoordinates());
                  ends = polygon.getEnds().slice();
                  for (var i = 0, ii = ends.length; i < ii; ++i) {
                    ends[i] += offset;
                  }
                }
                this.endss_.push(ends);
                this.changed();
              };
              MultiPolygon.prototype.clone = function() {
                var len = this.endss_.length;
                var newEndss = new Array(len);
                for (var i = 0; i < len; ++i) {
                  newEndss[i] = this.endss_[i].slice();
                }
                var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
                multiPolygon.applyProperties(this);
                return multiPolygon;
              };
              MultiPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                if (this.maxDeltaRevision_ != this.getRevision()) {
                  this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
                  this.maxDeltaRevision_ = this.getRevision();
                }
                return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
              };
              MultiPolygon.prototype.containsXY = function(x, y) {
                return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
              };
              MultiPolygon.prototype.getArea = function() {
                return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
              };
              MultiPolygon.prototype.getCoordinates = function(opt_right) {
                var flatCoordinates;
                if (opt_right !== void 0) {
                  flatCoordinates = this.getOrientedFlatCoordinates().slice();
                  orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
                } else {
                  flatCoordinates = this.flatCoordinates;
                }
                return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
              };
              MultiPolygon.prototype.getEndss = function() {
                return this.endss_;
              };
              MultiPolygon.prototype.getFlatInteriorPoints = function() {
                if (this.flatInteriorPointsRevision_ != this.getRevision()) {
                  var flatCenters = center_linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
                  this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
                  this.flatInteriorPointsRevision_ = this.getRevision();
                }
                return this.flatInteriorPoints_;
              };
              MultiPolygon.prototype.getInteriorPoints = function() {
                return new geom_MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
              };
              MultiPolygon.prototype.getOrientedFlatCoordinates = function() {
                if (this.orientedRevision_ != this.getRevision()) {
                  var flatCoordinates = this.flatCoordinates;
                  if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                    this.orientedFlatCoordinates_ = flatCoordinates;
                  } else {
                    this.orientedFlatCoordinates_ = flatCoordinates.slice();
                    this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
                  }
                  this.orientedRevision_ = this.getRevision();
                }
                return this.orientedFlatCoordinates_;
              };
              MultiPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
                var simplifiedFlatCoordinates = [];
                var simplifiedEndss = [];
                simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
                return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
              };
              MultiPolygon.prototype.getPolygon = function(index) {
                if (index < 0 || this.endss_.length <= index) {
                  return null;
                }
                var offset;
                if (index === 0) {
                  offset = 0;
                } else {
                  var prevEnds = this.endss_[index - 1];
                  offset = prevEnds[prevEnds.length - 1];
                }
                var ends = this.endss_[index].slice();
                var end = ends[ends.length - 1];
                if (offset !== 0) {
                  for (var i = 0, ii = ends.length; i < ii; ++i) {
                    ends[i] -= offset;
                  }
                }
                return new geom_Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
              };
              MultiPolygon.prototype.getPolygons = function() {
                var layout = this.layout;
                var flatCoordinates = this.flatCoordinates;
                var endss = this.endss_;
                var polygons = [];
                var offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var ends = endss[i].slice();
                  var end = ends[ends.length - 1];
                  if (offset !== 0) {
                    for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] -= offset;
                    }
                  }
                  var polygon = new geom_Polygon(flatCoordinates.slice(offset, end), layout, ends);
                  polygons.push(polygon);
                  offset = end;
                }
                return polygons;
              };
              MultiPolygon.prototype.getType = function() {
                return geom_GeometryType.MULTI_POLYGON;
              };
              MultiPolygon.prototype.intersectsExtent = function(extent) {
                return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
              };
              MultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {
                this.setLayout(opt_layout, coordinates, 3);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
                if (endss.length === 0) {
                  this.flatCoordinates.length = 0;
                } else {
                  var lastEnds = endss[endss.length - 1];
                  this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
                }
                this.changed();
              };
              return MultiPolygon;
            }(geom_SimpleGeometry)
          );
          var geom_MultiPolygon = MultiPolygon_MultiPolygon;
          var MultiPolygonvue_type_script_lang_js = {
            name: "ol-geom-multi-polygon",
            setup: function setup(props) {
              var _useGeometry = useGeometry(geom_MultiPolygon, props), geometry = _useGeometry.geometry;
              return {
                geometry
              };
            },
            props: {
              coordinates: {
                type: Array
              },
              opt_layout: {
                type: String,
                default: "XY"
              }
            }
          };
          MultiPolygonvue_type_script_lang_js.render = MultiPolygonvue_type_template_id_abbb2b88_lang_true_render;
          var geometries_MultiPolygon = MultiPolygonvue_type_script_lang_js;
          function geometries_install(app) {
            if (geometries_install.installed) {
              return;
            }
            geometries_install.installed = true;
            app.component(geometries_Point.name, geometries_Point);
            app.component(geometries_LineString.name, geometries_LineString);
            app.component(geometries_Polygon.name, geometries_Polygon);
            app.component(geometries_MultiPoint.name, geometries_MultiPoint);
            app.component(geometries_MultiLineString.name, geometries_MultiLineString);
            app.component(geometries_MultiPolygon.name, geometries_MultiPolygon);
          }
          var components_geometries = geometries_install;
          function Stylevue_type_template_id_0040721c_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var geom_Circle_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Circle_Circle = (
            /** @class */
            function(_super) {
              geom_Circle_extends(Circle, _super);
              function Circle(center, opt_radius, opt_layout) {
                var _this = _super.call(this) || this;
                if (opt_layout !== void 0 && opt_radius === void 0) {
                  _this.setFlatCoordinates(opt_layout, center);
                } else {
                  var radius = opt_radius ? opt_radius : 0;
                  _this.setCenterAndRadius(center, radius, opt_layout);
                }
                return _this;
              }
              Circle.prototype.clone = function() {
                var circle = new Circle(this.flatCoordinates.slice(), void 0, this.layout);
                circle.applyProperties(this);
                return circle;
              };
              Circle.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                var flatCoordinates = this.flatCoordinates;
                var dx = x - flatCoordinates[0];
                var dy = y - flatCoordinates[1];
                var squaredDistance = dx * dx + dy * dy;
                if (squaredDistance < minSquaredDistance) {
                  if (squaredDistance === 0) {
                    for (var i = 0; i < this.stride; ++i) {
                      closestPoint[i] = flatCoordinates[i];
                    }
                  } else {
                    var delta = this.getRadius() / Math.sqrt(squaredDistance);
                    closestPoint[0] = flatCoordinates[0] + delta * dx;
                    closestPoint[1] = flatCoordinates[1] + delta * dy;
                    for (var i = 2; i < this.stride; ++i) {
                      closestPoint[i] = flatCoordinates[i];
                    }
                  }
                  closestPoint.length = this.stride;
                  return squaredDistance;
                } else {
                  return minSquaredDistance;
                }
              };
              Circle.prototype.containsXY = function(x, y) {
                var flatCoordinates = this.flatCoordinates;
                var dx = x - flatCoordinates[0];
                var dy = y - flatCoordinates[1];
                return dx * dx + dy * dy <= this.getRadiusSquared_();
              };
              Circle.prototype.getCenter = function() {
                return this.flatCoordinates.slice(0, this.stride);
              };
              Circle.prototype.computeExtent = function(extent) {
                var flatCoordinates = this.flatCoordinates;
                var radius = flatCoordinates[this.stride] - flatCoordinates[0];
                return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
              };
              Circle.prototype.getRadius = function() {
                return Math.sqrt(this.getRadiusSquared_());
              };
              Circle.prototype.getRadiusSquared_ = function() {
                var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
                var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
                return dx * dx + dy * dy;
              };
              Circle.prototype.getType = function() {
                return geom_GeometryType.CIRCLE;
              };
              Circle.prototype.intersectsExtent = function(extent) {
                var circleExtent = this.getExtent();
                if (extent_intersects(extent, circleExtent)) {
                  var center = this.getCenter();
                  if (extent[0] <= center[0] && extent[2] >= center[0]) {
                    return true;
                  }
                  if (extent[1] <= center[1] && extent[3] >= center[1]) {
                    return true;
                  }
                  return forEachCorner(extent, this.intersectsCoordinate.bind(this));
                }
                return false;
              };
              Circle.prototype.setCenter = function(center) {
                var stride = this.stride;
                var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
                var flatCoordinates = center.slice();
                flatCoordinates[stride] = flatCoordinates[0] + radius;
                for (var i = 1; i < stride; ++i) {
                  flatCoordinates[stride + i] = center[i];
                }
                this.setFlatCoordinates(this.layout, flatCoordinates);
                this.changed();
              };
              Circle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {
                this.setLayout(opt_layout, center, 0);
                if (!this.flatCoordinates) {
                  this.flatCoordinates = [];
                }
                var flatCoordinates = this.flatCoordinates;
                var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);
                flatCoordinates[offset++] = flatCoordinates[0] + radius;
                for (var i = 1, ii = this.stride; i < ii; ++i) {
                  flatCoordinates[offset++] = flatCoordinates[i];
                }
                flatCoordinates.length = offset;
                this.changed();
              };
              Circle.prototype.getCoordinates = function() {
                return null;
              };
              Circle.prototype.setCoordinates = function(coordinates, opt_layout) {
              };
              Circle.prototype.setRadius = function(radius) {
                this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
                this.changed();
              };
              Circle.prototype.rotate = function(angle, anchor) {
                var center = this.getCenter();
                var stride = this.getStride();
                this.setCenter(transform_rotate(center, 0, center.length, stride, angle, anchor, center));
                this.changed();
              };
              Circle.prototype.translate = function(deltaX, deltaY) {
                var center = this.getCenter();
                var stride = this.getStride();
                this.setCenter(flat_transform_translate(center, 0, center.length, stride, deltaX, deltaY, center));
                this.changed();
              };
              return Circle;
            }(geom_SimpleGeometry)
          );
          Circle_Circle.prototype.transform;
          var geom_Circle = Circle_Circle;
          var Draw_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Draw_Mode = {
            POINT: "Point",
            LINE_STRING: "LineString",
            POLYGON: "Polygon",
            CIRCLE: "Circle"
          };
          var DrawEventType = {
            /**
             * Triggered upon feature draw start
             * @event DrawEvent#drawstart
             * @api
             */
            DRAWSTART: "drawstart",
            /**
             * Triggered upon feature draw end
             * @event DrawEvent#drawend
             * @api
             */
            DRAWEND: "drawend",
            /**
             * Triggered upon feature draw abortion
             * @event DrawEvent#drawabort
             * @api
             */
            DRAWABORT: "drawabort"
          };
          var DrawEvent = (
            /** @class */
            function(_super) {
              Draw_extends(DrawEvent2, _super);
              function DrawEvent2(type, feature) {
                var _this = _super.call(this, type) || this;
                _this.feature = feature;
                return _this;
              }
              return DrawEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Draw_Draw = (
            /** @class */
            function(_super) {
              Draw_extends(Draw, _super);
              function Draw(options) {
                var _this = this;
                var pointerOptions = (
                  /** @type {import("./Pointer.js").Options} */
                  options
                );
                if (!pointerOptions.stopDown) {
                  pointerOptions.stopDown = functions[
                    "a"
                    /* FALSE */
                  ];
                }
                _this = _super.call(this, pointerOptions) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.shouldHandle_ = false;
                _this.downPx_ = null;
                _this.downTimeout_;
                _this.lastDragTime_;
                _this.pointerType_;
                _this.freehand_ = false;
                _this.source_ = options.source ? options.source : null;
                _this.features_ = options.features ? options.features : null;
                _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
                _this.type_ = /** @type {import("../geom/GeometryType.js").default} */
                options.type;
                _this.mode_ = getMode(_this.type_);
                _this.stopClick_ = !!options.stopClick;
                _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Draw_Mode.POLYGON ? 3 : 2;
                _this.maxPoints_ = _this.mode_ === Draw_Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
                _this.finishCondition_ = options.finishCondition ? options.finishCondition : functions[
                  "b"
                  /* TRUE */
                ];
                var geometryFunction = options.geometryFunction;
                if (!geometryFunction) {
                  var mode_1 = _this.mode_;
                  if (mode_1 === Draw_Mode.CIRCLE) {
                    geometryFunction = function(coordinates, geometry, projection) {
                      var circle = geometry ? (
                        /** @type {Circle} */
                        geometry
                      ) : new geom_Circle([NaN, NaN]);
                      var center = fromUserCoordinate(coordinates[0], projection);
                      var squaredLength = coordinate_squaredDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));
                      circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
                      var userProjection = getUserProjection();
                      if (userProjection) {
                        circle.transform(projection, userProjection);
                      }
                      return circle;
                    };
                  } else {
                    var Constructor_1;
                    if (mode_1 === Draw_Mode.POINT) {
                      Constructor_1 = geom_Point;
                    } else if (mode_1 === Draw_Mode.LINE_STRING) {
                      Constructor_1 = geom_LineString;
                    } else if (mode_1 === Draw_Mode.POLYGON) {
                      Constructor_1 = geom_Polygon;
                    }
                    geometryFunction = function(coordinates, geometry, projection) {
                      if (geometry) {
                        if (mode_1 === Draw_Mode.POLYGON) {
                          if (coordinates[0].length) {
                            geometry.setCoordinates([
                              coordinates[0].concat([coordinates[0][0]])
                            ]);
                          } else {
                            geometry.setCoordinates([]);
                          }
                        } else {
                          geometry.setCoordinates(coordinates);
                        }
                      } else {
                        geometry = new Constructor_1(coordinates);
                      }
                      return geometry;
                    };
                  }
                }
                _this.geometryFunction_ = geometryFunction;
                _this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;
                _this.finishCoordinate_ = null;
                _this.sketchFeature_ = null;
                _this.sketchPoint_ = null;
                _this.sketchCoords_ = null;
                _this.sketchLine_ = null;
                _this.sketchLineCoords_ = null;
                _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
                _this.overlay_ = new Vector({
                  source: new source_Vector({
                    useSpatialIndex: false,
                    wrapX: options.wrapX ? options.wrapX : false
                  }),
                  style: options.style ? options.style : getDefaultStyleFunction(),
                  updateWhileInteracting: true
                });
                _this.geometryName_ = options.geometryName;
                _this.condition_ = options.condition ? options.condition : noModifierKeys;
                _this.freehandCondition_;
                if (options.freehand) {
                  _this.freehandCondition_ = always;
                } else {
                  _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;
                }
                _this.addChangeListener(interaction_Property.ACTIVE, _this.updateState_);
                return _this;
              }
              Draw.prototype.setMap = function(map) {
                _super.prototype.setMap.call(this, map);
                this.updateState_();
              };
              Draw.prototype.getOverlay = function() {
                return this.overlay_;
              };
              Draw.prototype.handleEvent = function(event) {
                if (event.originalEvent.type === EventType[
                  "a"
                  /* default */
                ].CONTEXTMENU) {
                  event.originalEvent.preventDefault();
                }
                this.freehand_ = this.mode_ !== Draw_Mode.POINT && this.freehandCondition_(event);
                var move = event.type === MapBrowserEventType.POINTERMOVE;
                var pass = true;
                if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {
                  var now = Date.now();
                  if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                    this.downPx_ = event.pixel;
                    this.shouldHandle_ = !this.freehand_;
                    move = true;
                  } else {
                    this.lastDragTime_ = void 0;
                  }
                  if (this.shouldHandle_ && this.downTimeout_ !== void 0) {
                    clearTimeout(this.downTimeout_);
                    this.downTimeout_ = void 0;
                  }
                }
                if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {
                  this.addToDrawing_(event.coordinate);
                  pass = false;
                } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {
                  pass = false;
                } else if (move && this.getPointerCount() < 2) {
                  pass = event.type === MapBrowserEventType.POINTERMOVE;
                  if (pass && this.freehand_) {
                    this.handlePointerMove_(event);
                    if (this.shouldHandle_) {
                      event.originalEvent.preventDefault();
                    }
                  } else if (event.originalEvent.pointerType === "mouse" || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) {
                    this.handlePointerMove_(event);
                  }
                } else if (event.type === MapBrowserEventType.DBLCLICK) {
                  pass = false;
                }
                return _super.prototype.handleEvent.call(this, event) && pass;
              };
              Draw.prototype.handleDownEvent = function(event) {
                this.shouldHandle_ = !this.freehand_;
                if (this.freehand_) {
                  this.downPx_ = event.pixel;
                  if (!this.finishCoordinate_) {
                    this.startDrawing_(event.coordinate);
                  }
                  return true;
                } else if (this.condition_(event)) {
                  this.lastDragTime_ = Date.now();
                  this.downTimeout_ = setTimeout((function() {
                    this.handlePointerMove_(new ol_MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
                  }).bind(this), this.dragVertexDelay_);
                  this.downPx_ = event.pixel;
                  return true;
                } else {
                  this.lastDragTime_ = void 0;
                  return false;
                }
              };
              Draw.prototype.handleUpEvent = function(event) {
                var pass = true;
                if (this.getPointerCount() === 0) {
                  if (this.downTimeout_) {
                    clearTimeout(this.downTimeout_);
                    this.downTimeout_ = void 0;
                  }
                  this.handlePointerMove_(event);
                  if (this.shouldHandle_) {
                    var startingToDraw = !this.finishCoordinate_;
                    if (startingToDraw) {
                      this.startDrawing_(event.coordinate);
                    }
                    if (!startingToDraw && this.freehand_) {
                      this.finishDrawing();
                    } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Draw_Mode.POINT)) {
                      if (this.atFinish_(event.pixel)) {
                        if (this.finishCondition_(event)) {
                          this.finishDrawing();
                        }
                      } else {
                        this.addToDrawing_(event.coordinate);
                      }
                    }
                    pass = false;
                  } else if (this.freehand_) {
                    this.abortDrawing();
                  }
                }
                if (!pass && this.stopClick_) {
                  event.preventDefault();
                }
                return pass;
              };
              Draw.prototype.handlePointerMove_ = function(event) {
                this.pointerType_ = event.originalEvent.pointerType;
                if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
                  var downPx = this.downPx_;
                  var clickPx = event.pixel;
                  var dx = downPx[0] - clickPx[0];
                  var dy = downPx[1] - clickPx[1];
                  var squaredDistance = dx * dx + dy * dy;
                  this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
                  if (!this.shouldHandle_) {
                    return;
                  }
                }
                if (this.finishCoordinate_) {
                  this.modifyDrawing_(event.coordinate);
                } else {
                  this.createOrUpdateSketchPoint_(event.coordinate.slice());
                }
              };
              Draw.prototype.atFinish_ = function(pixel) {
                var at = false;
                if (this.sketchFeature_) {
                  var potentiallyDone = false;
                  var potentiallyFinishCoordinates = [this.finishCoordinate_];
                  var mode = this.mode_;
                  if (mode === Draw_Mode.POINT) {
                    at = true;
                  } else if (mode === Draw_Mode.CIRCLE) {
                    at = this.sketchCoords_.length === 2;
                  } else if (mode === Draw_Mode.LINE_STRING) {
                    potentiallyDone = this.sketchCoords_.length > this.minPoints_;
                  } else if (mode === Draw_Mode.POLYGON) {
                    var sketchCoords = (
                      /** @type {PolyCoordType} */
                      this.sketchCoords_
                    );
                    potentiallyDone = sketchCoords[0].length > this.minPoints_;
                    potentiallyFinishCoordinates = [
                      sketchCoords[0][0],
                      sketchCoords[0][sketchCoords[0].length - 2]
                    ];
                  }
                  if (potentiallyDone) {
                    var map = this.getMap();
                    for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
                      var finishCoordinate = potentiallyFinishCoordinates[i];
                      var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                      var dx = pixel[0] - finishPixel[0];
                      var dy = pixel[1] - finishPixel[1];
                      var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                      at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                      if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                      }
                    }
                  }
                }
                return at;
              };
              Draw.prototype.createOrUpdateSketchPoint_ = function(coordinates) {
                if (!this.sketchPoint_) {
                  this.sketchPoint_ = new ol_Feature(new geom_Point(coordinates));
                  this.updateSketchFeatures_();
                } else {
                  var sketchPointGeom = this.sketchPoint_.getGeometry();
                  sketchPointGeom.setCoordinates(coordinates);
                }
              };
              Draw.prototype.createOrUpdateCustomSketchLine_ = function(geometry) {
                if (!this.sketchLine_) {
                  this.sketchLine_ = new ol_Feature();
                }
                var ring = geometry.getLinearRing(0);
                var sketchLineGeom = this.sketchLine_.getGeometry();
                if (!sketchLineGeom) {
                  sketchLineGeom = new geom_LineString(ring.getFlatCoordinates(), ring.getLayout());
                  this.sketchLine_.setGeometry(sketchLineGeom);
                } else {
                  sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
                  sketchLineGeom.changed();
                }
              };
              Draw.prototype.startDrawing_ = function(start) {
                var projection = this.getMap().getView().getProjection();
                this.finishCoordinate_ = start;
                if (this.mode_ === Draw_Mode.POINT) {
                  this.sketchCoords_ = start.slice();
                } else if (this.mode_ === Draw_Mode.POLYGON) {
                  this.sketchCoords_ = [[start.slice(), start.slice()]];
                  this.sketchLineCoords_ = this.sketchCoords_[0];
                } else {
                  this.sketchCoords_ = [start.slice(), start.slice()];
                }
                if (this.sketchLineCoords_) {
                  this.sketchLine_ = new ol_Feature(new geom_LineString(this.sketchLineCoords_));
                }
                var geometry = this.geometryFunction_(this.sketchCoords_, void 0, projection);
                this.sketchFeature_ = new ol_Feature();
                if (this.geometryName_) {
                  this.sketchFeature_.setGeometryName(this.geometryName_);
                }
                this.sketchFeature_.setGeometry(geometry);
                this.updateSketchFeatures_();
                this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
              };
              Draw.prototype.modifyDrawing_ = function(coordinate) {
                var map = this.getMap();
                var geometry = this.sketchFeature_.getGeometry();
                var projection = map.getView().getProjection();
                var coordinates, last;
                if (this.mode_ === Draw_Mode.POINT) {
                  last = this.sketchCoords_;
                } else if (this.mode_ === Draw_Mode.POLYGON) {
                  coordinates = /** @type {PolyCoordType} */
                  this.sketchCoords_[0];
                  last = coordinates[coordinates.length - 1];
                  if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
                    coordinate = this.finishCoordinate_.slice();
                  }
                } else {
                  coordinates = this.sketchCoords_;
                  last = coordinates[coordinates.length - 1];
                }
                last[0] = coordinate[0];
                last[1] = coordinate[1];
                this.geometryFunction_(
                  /** @type {!LineCoordType} */
                  this.sketchCoords_,
                  geometry,
                  projection
                );
                if (this.sketchPoint_) {
                  var sketchPointGeom = this.sketchPoint_.getGeometry();
                  sketchPointGeom.setCoordinates(coordinate);
                }
                if (geometry.getType() === geom_GeometryType.POLYGON && this.mode_ !== Draw_Mode.POLYGON) {
                  this.createOrUpdateCustomSketchLine_(
                    /** @type {Polygon} */
                    geometry
                  );
                } else if (this.sketchLineCoords_) {
                  var sketchLineGeom = this.sketchLine_.getGeometry();
                  sketchLineGeom.setCoordinates(this.sketchLineCoords_);
                }
                this.updateSketchFeatures_();
              };
              Draw.prototype.addToDrawing_ = function(coordinate) {
                var geometry = this.sketchFeature_.getGeometry();
                var projection = this.getMap().getView().getProjection();
                var done;
                var coordinates;
                var mode = this.mode_;
                if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
                  this.finishCoordinate_ = coordinate.slice();
                  coordinates = /** @type {LineCoordType} */
                  this.sketchCoords_;
                  if (coordinates.length >= this.maxPoints_) {
                    if (this.freehand_) {
                      coordinates.pop();
                    } else {
                      done = true;
                    }
                  }
                  coordinates.push(coordinate.slice());
                  this.geometryFunction_(coordinates, geometry, projection);
                } else if (mode === Draw_Mode.POLYGON) {
                  coordinates = /** @type {PolyCoordType} */
                  this.sketchCoords_[0];
                  if (coordinates.length >= this.maxPoints_) {
                    if (this.freehand_) {
                      coordinates.pop();
                    } else {
                      done = true;
                    }
                  }
                  coordinates.push(coordinate.slice());
                  if (done) {
                    this.finishCoordinate_ = coordinates[0];
                  }
                  this.geometryFunction_(this.sketchCoords_, geometry, projection);
                }
                this.createOrUpdateSketchPoint_(coordinate.slice());
                this.updateSketchFeatures_();
                if (done) {
                  this.finishDrawing();
                }
              };
              Draw.prototype.removeLastPoint = function() {
                if (!this.sketchFeature_) {
                  return;
                }
                var geometry = this.sketchFeature_.getGeometry();
                var projection = this.getMap().getView().getProjection();
                var coordinates;
                var mode = this.mode_;
                if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
                  coordinates = /** @type {LineCoordType} */
                  this.sketchCoords_;
                  coordinates.splice(-2, 1);
                  if (coordinates.length >= 2) {
                    this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                    var finishCoordinate = this.finishCoordinate_.slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                  }
                  this.geometryFunction_(coordinates, geometry, projection);
                  if (geometry.getType() === geom_GeometryType.POLYGON && this.sketchLine_) {
                    this.createOrUpdateCustomSketchLine_(
                      /** @type {Polygon} */
                      geometry
                    );
                  }
                } else if (mode === Draw_Mode.POLYGON) {
                  coordinates = /** @type {PolyCoordType} */
                  this.sketchCoords_[0];
                  coordinates.splice(-2, 1);
                  var sketchLineGeom = this.sketchLine_.getGeometry();
                  if (coordinates.length >= 2) {
                    var finishCoordinate = coordinates[coordinates.length - 2].slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                  }
                  sketchLineGeom.setCoordinates(coordinates);
                  this.geometryFunction_(this.sketchCoords_, geometry, projection);
                }
                if (coordinates.length === 1) {
                  this.abortDrawing();
                }
                this.updateSketchFeatures_();
              };
              Draw.prototype.finishDrawing = function() {
                var sketchFeature = this.abortDrawing_();
                if (!sketchFeature) {
                  return;
                }
                var coordinates = this.sketchCoords_;
                var geometry = sketchFeature.getGeometry();
                var projection = this.getMap().getView().getProjection();
                if (this.mode_ === Draw_Mode.LINE_STRING) {
                  coordinates.pop();
                  this.geometryFunction_(coordinates, geometry, projection);
                } else if (this.mode_ === Draw_Mode.POLYGON) {
                  coordinates[0].pop();
                  this.geometryFunction_(coordinates, geometry, projection);
                  coordinates = geometry.getCoordinates();
                }
                if (this.type_ === geom_GeometryType.MULTI_POINT) {
                  sketchFeature.setGeometry(new geom_MultiPoint([
                    /** @type {PointCoordType} */
                    coordinates
                  ]));
                } else if (this.type_ === geom_GeometryType.MULTI_LINE_STRING) {
                  sketchFeature.setGeometry(new geom_MultiLineString([
                    /** @type {LineCoordType} */
                    coordinates
                  ]));
                } else if (this.type_ === geom_GeometryType.MULTI_POLYGON) {
                  sketchFeature.setGeometry(new geom_MultiPolygon([
                    /** @type {PolyCoordType} */
                    coordinates
                  ]));
                }
                this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
                if (this.features_) {
                  this.features_.push(sketchFeature);
                }
                if (this.source_) {
                  this.source_.addFeature(sketchFeature);
                }
              };
              Draw.prototype.abortDrawing_ = function() {
                this.finishCoordinate_ = null;
                var sketchFeature = this.sketchFeature_;
                this.sketchFeature_ = null;
                this.sketchPoint_ = null;
                this.sketchLine_ = null;
                this.overlay_.getSource().clear(true);
                return sketchFeature;
              };
              Draw.prototype.abortDrawing = function() {
                var sketchFeature = this.abortDrawing_();
                if (sketchFeature) {
                  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
                }
              };
              Draw.prototype.appendCoordinates = function(coordinates) {
                var mode = this.mode_;
                var newDrawing = !this.sketchFeature_;
                if (newDrawing) {
                  this.startDrawing_(coordinates[0]);
                }
                var sketchCoords;
                if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
                  sketchCoords = /** @type {LineCoordType} */
                  this.sketchCoords_;
                } else if (mode === Draw_Mode.POLYGON) {
                  sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? (
                    /** @type {PolyCoordType} */
                    this.sketchCoords_[0]
                  ) : [];
                } else {
                  return;
                }
                if (newDrawing) {
                  sketchCoords.shift();
                }
                sketchCoords.pop();
                for (var i = 0; i < coordinates.length; i++) {
                  this.addToDrawing_(coordinates[i]);
                }
                var ending = coordinates[coordinates.length - 1];
                this.addToDrawing_(ending);
                this.modifyDrawing_(ending);
              };
              Draw.prototype.extend = function(feature) {
                var geometry = feature.getGeometry();
                var lineString = geometry;
                this.sketchFeature_ = feature;
                this.sketchCoords_ = lineString.getCoordinates();
                var last = this.sketchCoords_[this.sketchCoords_.length - 1];
                this.finishCoordinate_ = last.slice();
                this.sketchCoords_.push(last.slice());
                this.sketchPoint_ = new ol_Feature(new geom_Point(last));
                this.updateSketchFeatures_();
                this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
              };
              Draw.prototype.updateSketchFeatures_ = function() {
                var sketchFeatures = [];
                if (this.sketchFeature_) {
                  sketchFeatures.push(this.sketchFeature_);
                }
                if (this.sketchLine_) {
                  sketchFeatures.push(this.sketchLine_);
                }
                if (this.sketchPoint_) {
                  sketchFeatures.push(this.sketchPoint_);
                }
                var overlaySource = this.overlay_.getSource();
                overlaySource.clear(true);
                overlaySource.addFeatures(sketchFeatures);
              };
              Draw.prototype.updateState_ = function() {
                var map = this.getMap();
                var active = this.getActive();
                if (!map || !active) {
                  this.abortDrawing();
                }
                this.overlay_.setMap(active ? map : null);
              };
              return Draw;
            }(Pointer)
          );
          function getDefaultStyleFunction() {
            var styles = createEditingStyle();
            return function(feature, resolution) {
              return styles[feature.getGeometry().getType()];
            };
          }
          function createRegularPolygon(opt_sides, opt_angle) {
            return function(coordinates, opt_geometry, projection) {
              var center = fromUserCoordinate(
                /** @type {LineCoordType} */
                coordinates[0],
                projection
              );
              var end = fromUserCoordinate(
                /** @type {LineCoordType} */
                coordinates[coordinates.length - 1],
                projection
              );
              var radius = Math.sqrt(coordinate_squaredDistance(center, end));
              var geometry = opt_geometry ? (
                /** @type {Polygon} */
                opt_geometry
              ) : fromCircle(new geom_Circle(center), opt_sides);
              var angle = opt_angle;
              if (!opt_angle && opt_angle !== 0) {
                var x = end[0] - center[0];
                var y = end[1] - center[1];
                angle = Math.atan2(y, x);
              }
              makeRegular(geometry, center, radius, angle);
              var userProjection = getUserProjection();
              if (userProjection) {
                geometry.transform(projection, userProjection);
              }
              return geometry;
            };
          }
          function createBox() {
            return function(coordinates, opt_geometry, projection) {
              var extent = boundingExtent(
                /** @type {LineCoordType} */
                [
                  coordinates[0],
                  coordinates[coordinates.length - 1]
                ].map(function(coordinate) {
                  return fromUserCoordinate(coordinate, projection);
                })
              );
              var boxCoordinates = [
                [
                  getBottomLeft(extent),
                  getBottomRight(extent),
                  getTopRight(extent),
                  getTopLeft(extent),
                  getBottomLeft(extent)
                ]
              ];
              var geometry = opt_geometry;
              if (geometry) {
                geometry.setCoordinates(boxCoordinates);
              } else {
                geometry = new geom_Polygon(boxCoordinates);
              }
              var userProjection = getUserProjection();
              if (userProjection) {
                geometry.transform(projection, userProjection);
              }
              return geometry;
            };
          }
          function getMode(type) {
            switch (type) {
              case geom_GeometryType.POINT:
              case geom_GeometryType.MULTI_POINT:
                return Draw_Mode.POINT;
              case geom_GeometryType.LINE_STRING:
              case geom_GeometryType.MULTI_LINE_STRING:
                return Draw_Mode.LINE_STRING;
              case geom_GeometryType.POLYGON:
              case geom_GeometryType.MULTI_POLYGON:
                return Draw_Mode.POLYGON;
              case geom_GeometryType.CIRCLE:
                return Draw_Mode.CIRCLE;
              default:
                throw new Error("Invalid type: " + type);
            }
          }
          var interaction_Draw = Draw_Draw;
          var Modify_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var CIRCLE_CENTER_INDEX = 0;
          var CIRCLE_CIRCUMFERENCE_INDEX = 1;
          var tempExtent = [0, 0, 0, 0];
          var tempSegment = [];
          var ModifyEventType = {
            /**
             * Triggered upon feature modification start
             * @event ModifyEvent#modifystart
             * @api
             */
            MODIFYSTART: "modifystart",
            /**
             * Triggered upon feature modification end
             * @event ModifyEvent#modifyend
             * @api
             */
            MODIFYEND: "modifyend"
          };
          var ModifyEvent = (
            /** @class */
            function(_super) {
              Modify_extends(ModifyEvent2, _super);
              function ModifyEvent2(type, features, MapBrowserEvent2) {
                var _this = _super.call(this, type) || this;
                _this.features = features;
                _this.mapBrowserEvent = MapBrowserEvent2;
                return _this;
              }
              return ModifyEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var Modify_Modify = (
            /** @class */
            function(_super) {
              Modify_extends(Modify, _super);
              function Modify(options) {
                var _this = _super.call(
                  this,
                  /** @type {import("./Pointer.js").Options} */
                  options
                ) || this;
                _this.on;
                _this.once;
                _this.un;
                _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
                _this.condition_ = options.condition ? options.condition : primaryAction;
                _this.defaultDeleteCondition_ = function(mapBrowserEvent) {
                  return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
                };
                _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
                _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;
                _this.vertexFeature_ = null;
                _this.vertexSegments_ = null;
                _this.lastPixel_ = [0, 0];
                _this.ignoreNextSingleClick_ = false;
                _this.featuresBeingModified_ = null;
                _this.rBush_ = new structs_RBush();
                _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
                _this.snappedToVertex_ = false;
                _this.changingFeature_ = false;
                _this.dragSegments_ = [];
                _this.overlay_ = new Vector({
                  source: new source_Vector({
                    useSpatialIndex: false,
                    wrapX: !!options.wrapX
                  }),
                  style: options.style ? options.style : Modify_getDefaultStyleFunction(),
                  updateWhileAnimating: true,
                  updateWhileInteracting: true
                });
                _this.SEGMENT_WRITERS_ = {
                  "Point": _this.writePointGeometry_.bind(_this),
                  "LineString": _this.writeLineStringGeometry_.bind(_this),
                  "LinearRing": _this.writeLineStringGeometry_.bind(_this),
                  "Polygon": _this.writePolygonGeometry_.bind(_this),
                  "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
                  "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
                  "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
                  "Circle": _this.writeCircleGeometry_.bind(_this),
                  "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this)
                };
                _this.source_ = null;
                _this.hitDetection_ = null;
                var features;
                if (options.features) {
                  features = options.features;
                } else if (options.source) {
                  _this.source_ = options.source;
                  features = new ol_Collection(_this.source_.getFeatures());
                  _this.source_.addEventListener(VectorEventType.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
                  _this.source_.addEventListener(VectorEventType.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
                }
                if (!features) {
                  throw new Error("The modify interaction requires features, a source or a layer");
                }
                if (options.hitDetection) {
                  _this.hitDetection_ = options.hitDetection;
                }
                _this.features_ = features;
                _this.features_.forEach(_this.addFeature_.bind(_this));
                _this.features_.addEventListener(CollectionEventType.ADD, _this.handleFeatureAdd_.bind(_this));
                _this.features_.addEventListener(CollectionEventType.REMOVE, _this.handleFeatureRemove_.bind(_this));
                _this.lastPointerEvent_ = null;
                _this.delta_ = [0, 0];
                _this.snapToPointer_ = options.snapToPointer === void 0 ? !_this.hitDetection_ : options.snapToPointer;
                return _this;
              }
              Modify.prototype.addFeature_ = function(feature) {
                var geometry = feature.getGeometry();
                if (geometry) {
                  var writer = this.SEGMENT_WRITERS_[geometry.getType()];
                  if (writer) {
                    writer(feature, geometry);
                  }
                }
                var map = this.getMap();
                if (map && map.isRendered() && this.getActive()) {
                  this.handlePointerAtPixel_(this.lastPixel_, map);
                }
                feature.addEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, this.boundHandleFeatureChange_);
              };
              Modify.prototype.willModifyFeatures_ = function(evt, segments) {
                if (!this.featuresBeingModified_) {
                  this.featuresBeingModified_ = new ol_Collection();
                  var features = this.featuresBeingModified_.getArray();
                  for (var i = 0, ii = segments.length; i < ii; ++i) {
                    var segment = segments[i];
                    for (var s = 0, ss = segment.length; s < ss; ++s) {
                      var feature = segment[s].feature;
                      if (feature && features.indexOf(feature) === -1) {
                        this.featuresBeingModified_.push(feature);
                      }
                    }
                  }
                  if (this.featuresBeingModified_.getLength() === 0) {
                    this.featuresBeingModified_ = null;
                  } else {
                    this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
                  }
                }
              };
              Modify.prototype.removeFeature_ = function(feature) {
                this.removeFeatureSegmentData_(feature);
                if (this.vertexFeature_ && this.features_.getLength() === 0) {
                  this.overlay_.getSource().removeFeature(this.vertexFeature_);
                  this.vertexFeature_ = null;
                }
                feature.removeEventListener(EventType[
                  "a"
                  /* default */
                ].CHANGE, this.boundHandleFeatureChange_);
              };
              Modify.prototype.removeFeatureSegmentData_ = function(feature) {
                var rBush = this.rBush_;
                var nodesToRemove = [];
                rBush.forEach(
                  /**
                   * @param {SegmentData} node RTree node.
                   */
                  function(node) {
                    if (feature === node.feature) {
                      nodesToRemove.push(node);
                    }
                  }
                );
                for (var i = nodesToRemove.length - 1; i >= 0; --i) {
                  var nodeToRemove = nodesToRemove[i];
                  for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
                    if (this.dragSegments_[j][0] === nodeToRemove) {
                      this.dragSegments_.splice(j, 1);
                    }
                  }
                  rBush.remove(nodeToRemove);
                }
              };
              Modify.prototype.setActive = function(active) {
                if (this.vertexFeature_ && !active) {
                  this.overlay_.getSource().removeFeature(this.vertexFeature_);
                  this.vertexFeature_ = null;
                }
                _super.prototype.setActive.call(this, active);
              };
              Modify.prototype.setMap = function(map) {
                this.overlay_.setMap(map);
                _super.prototype.setMap.call(this, map);
              };
              Modify.prototype.getOverlay = function() {
                return this.overlay_;
              };
              Modify.prototype.handleSourceAdd_ = function(event) {
                if (event.feature) {
                  this.features_.push(event.feature);
                }
              };
              Modify.prototype.handleSourceRemove_ = function(event) {
                if (event.feature) {
                  this.features_.remove(event.feature);
                }
              };
              Modify.prototype.handleFeatureAdd_ = function(evt) {
                this.addFeature_(
                  /** @type {Feature} */
                  evt.element
                );
              };
              Modify.prototype.handleFeatureChange_ = function(evt) {
                if (!this.changingFeature_) {
                  var feature = (
                    /** @type {Feature} */
                    evt.target
                  );
                  this.removeFeature_(feature);
                  this.addFeature_(feature);
                }
              };
              Modify.prototype.handleFeatureRemove_ = function(evt) {
                var feature = (
                  /** @type {Feature} */
                  evt.element
                );
                this.removeFeature_(feature);
              };
              Modify.prototype.writePointGeometry_ = function(feature, geometry) {
                var coordinates = geometry.getCoordinates();
                var segmentData = {
                  feature,
                  geometry,
                  segment: [coordinates, coordinates]
                };
                this.rBush_.insert(geometry.getExtent(), segmentData);
              };
              Modify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
                var points = geometry.getCoordinates();
                for (var i = 0, ii = points.length; i < ii; ++i) {
                  var coordinates = points[i];
                  var segmentData = {
                    feature,
                    geometry,
                    depth: [i],
                    index: i,
                    segment: [coordinates, coordinates]
                  };
                  this.rBush_.insert(geometry.getExtent(), segmentData);
                }
              };
              Modify.prototype.writeLineStringGeometry_ = function(feature, geometry) {
                var coordinates = geometry.getCoordinates();
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                    feature,
                    geometry,
                    index: i,
                    segment
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
                }
              };
              Modify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
                var lines = geometry.getCoordinates();
                for (var j = 0, jj = lines.length; j < jj; ++j) {
                  var coordinates = lines[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var segment = coordinates.slice(i, i + 2);
                    var segmentData = {
                      feature,
                      geometry,
                      depth: [j],
                      index: i,
                      segment
                    };
                    this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
                }
              };
              Modify.prototype.writePolygonGeometry_ = function(feature, geometry) {
                var rings = geometry.getCoordinates();
                for (var j = 0, jj = rings.length; j < jj; ++j) {
                  var coordinates = rings[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var segment = coordinates.slice(i, i + 2);
                    var segmentData = {
                      feature,
                      geometry,
                      depth: [j],
                      index: i,
                      segment
                    };
                    this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
                }
              };
              Modify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
                var polygons = geometry.getCoordinates();
                for (var k = 0, kk = polygons.length; k < kk; ++k) {
                  var rings = polygons[k];
                  for (var j = 0, jj = rings.length; j < jj; ++j) {
                    var coordinates = rings[j];
                    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                      var segment = coordinates.slice(i, i + 2);
                      var segmentData = {
                        feature,
                        geometry,
                        depth: [j, k],
                        index: i,
                        segment
                      };
                      this.rBush_.insert(boundingExtent(segment), segmentData);
                    }
                  }
                }
              };
              Modify.prototype.writeCircleGeometry_ = function(feature, geometry) {
                var coordinates = geometry.getCenter();
                var centerSegmentData = {
                  feature,
                  geometry,
                  index: CIRCLE_CENTER_INDEX,
                  segment: [coordinates, coordinates]
                };
                var circumferenceSegmentData = {
                  feature,
                  geometry,
                  index: CIRCLE_CIRCUMFERENCE_INDEX,
                  segment: [coordinates, coordinates]
                };
                var featureSegments = [centerSegmentData, circumferenceSegmentData];
                centerSegmentData.featureSegments = featureSegments;
                circumferenceSegmentData.featureSegments = featureSegments;
                this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
                var circleGeometry = (
                  /** @type {import("../geom/Geometry.js").default} */
                  geometry
                );
                var userProjection = getUserProjection();
                if (userProjection && this.getMap()) {
                  var projection = this.getMap().getView().getProjection();
                  circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                  circleGeometry = fromCircle(
                    /** @type {import("../geom/Circle.js").default} */
                    circleGeometry
                  ).transform(projection, userProjection);
                }
                this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
              };
              Modify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
                var geometries = geometry.getGeometriesArray();
                for (var i = 0; i < geometries.length; ++i) {
                  var geometry_1 = geometries[i];
                  var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
                  writer(feature, geometry_1);
                }
              };
              Modify.prototype.createOrUpdateVertexFeature_ = function(coordinates, features, geometries) {
                var vertexFeature = this.vertexFeature_;
                if (!vertexFeature) {
                  vertexFeature = new ol_Feature(new geom_Point(coordinates));
                  this.vertexFeature_ = vertexFeature;
                  this.overlay_.getSource().addFeature(vertexFeature);
                } else {
                  var geometry = vertexFeature.getGeometry();
                  geometry.setCoordinates(coordinates);
                }
                vertexFeature.set("features", features);
                vertexFeature.set("geometries", geometries);
                return vertexFeature;
              };
              Modify.prototype.handleEvent = function(mapBrowserEvent) {
                if (!mapBrowserEvent.originalEvent) {
                  return true;
                }
                this.lastPointerEvent_ = mapBrowserEvent;
                var handled;
                if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
                  this.handlePointerMove_(mapBrowserEvent);
                }
                if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
                  if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
                    handled = this.removePoint();
                  } else {
                    handled = true;
                  }
                }
                if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
                  this.ignoreNextSingleClick_ = false;
                }
                return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
              };
              Modify.prototype.handleDragEvent = function(evt) {
                this.ignoreNextSingleClick_ = false;
                this.willModifyFeatures_(evt, this.dragSegments_);
                var vertex = [
                  evt.coordinate[0] + this.delta_[0],
                  evt.coordinate[1] + this.delta_[1]
                ];
                var features = [];
                var geometries = [];
                for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
                  var dragSegment = this.dragSegments_[i];
                  var segmentData = dragSegment[0];
                  var feature = segmentData.feature;
                  if (features.indexOf(feature) === -1) {
                    features.push(feature);
                  }
                  var geometry = segmentData.geometry;
                  if (geometries.indexOf(geometry) === -1) {
                    geometries.push(geometry);
                  }
                  var depth = segmentData.depth;
                  var coordinates = void 0;
                  var segment = segmentData.segment;
                  var index = dragSegment[1];
                  while (vertex.length < geometry.getStride()) {
                    vertex.push(segment[index][vertex.length]);
                  }
                  switch (geometry.getType()) {
                    case geom_GeometryType.POINT:
                      coordinates = vertex;
                      segment[0] = vertex;
                      segment[1] = vertex;
                      break;
                    case geom_GeometryType.MULTI_POINT:
                      coordinates = geometry.getCoordinates();
                      coordinates[segmentData.index] = vertex;
                      segment[0] = vertex;
                      segment[1] = vertex;
                      break;
                    case geom_GeometryType.LINE_STRING:
                      coordinates = geometry.getCoordinates();
                      coordinates[segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                    case geom_GeometryType.MULTI_LINE_STRING:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                    case geom_GeometryType.POLYGON:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                    case geom_GeometryType.MULTI_POLYGON:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                    case geom_GeometryType.CIRCLE:
                      segment[0] = vertex;
                      segment[1] = vertex;
                      if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        geometry.setCenter(vertex);
                        this.changingFeature_ = false;
                      } else {
                        this.changingFeature_ = true;
                        var projection = evt.map.getView().getProjection();
                        var radius = coordinate_distance(fromUserCoordinate(geometry.getCenter(), projection), fromUserCoordinate(vertex, projection));
                        var userProjection = getUserProjection();
                        if (userProjection) {
                          var circleGeometry = geometry.clone().transform(userProjection, projection);
                          circleGeometry.setRadius(radius);
                          radius = circleGeometry.transform(projection, userProjection).getRadius();
                        }
                        geometry.setRadius(radius);
                        this.changingFeature_ = false;
                      }
                      break;
                    default:
                  }
                  if (coordinates) {
                    this.setGeometryCoordinates_(geometry, coordinates);
                  }
                }
                this.createOrUpdateVertexFeature_(vertex, features, geometries);
              };
              Modify.prototype.handleDownEvent = function(evt) {
                if (!this.condition_(evt)) {
                  return false;
                }
                var pixelCoordinate = evt.coordinate;
                this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
                this.dragSegments_.length = 0;
                this.featuresBeingModified_ = null;
                var vertexFeature = this.vertexFeature_;
                if (vertexFeature) {
                  var projection = evt.map.getView().getProjection();
                  var insertVertices = [];
                  var vertex = vertexFeature.getGeometry().getCoordinates();
                  var vertexExtent = boundingExtent([vertex]);
                  var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
                  var componentSegments = {};
                  segmentDataMatches.sort(compareIndexes);
                  for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
                    var segmentDataMatch = segmentDataMatches[i];
                    var segment = segmentDataMatch.segment;
                    var uid = Object(util[
                      "c"
                      /* getUid */
                    ])(segmentDataMatch.geometry);
                    var depth = segmentDataMatch.depth;
                    if (depth) {
                      uid += "-" + depth.join("-");
                    }
                    if (!componentSegments[uid]) {
                      componentSegments[uid] = new Array(2);
                    }
                    if (segmentDataMatch.geometry.getType() === geom_GeometryType.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                      var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                      if (coordinate_equals(closestVertex, vertex) && !componentSegments[uid][0]) {
                        this.dragSegments_.push([segmentDataMatch, 0]);
                        componentSegments[uid][0] = segmentDataMatch;
                      }
                      continue;
                    }
                    if (coordinate_equals(segment[0], vertex) && !componentSegments[uid][0]) {
                      this.dragSegments_.push([segmentDataMatch, 0]);
                      componentSegments[uid][0] = segmentDataMatch;
                      continue;
                    }
                    if (coordinate_equals(segment[1], vertex) && !componentSegments[uid][1]) {
                      if ((segmentDataMatch.geometry.getType() === geom_GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === geom_GeometryType.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
                        continue;
                      }
                      this.dragSegments_.push([segmentDataMatch, 1]);
                      componentSegments[uid][1] = segmentDataMatch;
                      continue;
                    }
                    if (Object(util[
                      "c"
                      /* getUid */
                    ])(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
                      insertVertices.push(segmentDataMatch);
                    }
                  }
                  if (insertVertices.length) {
                    this.willModifyFeatures_(evt, [insertVertices]);
                  }
                  for (var j = insertVertices.length - 1; j >= 0; --j) {
                    this.insertVertex_(insertVertices[j], vertex);
                  }
                }
                return !!this.vertexFeature_;
              };
              Modify.prototype.handleUpEvent = function(evt) {
                for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
                  var segmentData = this.dragSegments_[i][0];
                  var geometry = segmentData.geometry;
                  if (geometry.getType() === geom_GeometryType.CIRCLE) {
                    var coordinates = geometry.getCenter();
                    var centerSegmentData = segmentData.featureSegments[0];
                    var circumferenceSegmentData = segmentData.featureSegments[1];
                    centerSegmentData.segment[0] = coordinates;
                    centerSegmentData.segment[1] = coordinates;
                    circumferenceSegmentData.segment[0] = coordinates;
                    circumferenceSegmentData.segment[1] = coordinates;
                    this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
                    var circleGeometry = geometry;
                    var userProjection = getUserProjection();
                    if (userProjection) {
                      var projection = evt.map.getView().getProjection();
                      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                      circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection);
                    }
                    this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
                  } else {
                    this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
                  }
                }
                if (this.featuresBeingModified_) {
                  this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
                  this.featuresBeingModified_ = null;
                }
                return false;
              };
              Modify.prototype.handlePointerMove_ = function(evt) {
                this.lastPixel_ = evt.pixel;
                this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
              };
              Modify.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {
                var _this = this;
                var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
                var projection = map.getView().getProjection();
                var sortByDistance = function(a, b) {
                  return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
                };
                var nodes;
                var hitPointGeometry;
                if (this.hitDetection_) {
                  var layerFilter = typeof this.hitDetection_ === "object" ? function(layer) {
                    return layer === _this.hitDetection_;
                  } : void 0;
                  map.forEachFeatureAtPixel(pixel, function(feature, layer, geometry) {
                    geometry = geometry || feature.getGeometry();
                    if (geometry.getType() === geom_GeometryType.POINT && Object(ol_array[
                      "f"
                      /* includes */
                    ])(_this.features_.getArray(), feature)) {
                      hitPointGeometry = geometry;
                      var coordinate = geometry.getFlatCoordinates().slice(0, 2);
                      nodes = [
                        {
                          feature,
                          geometry,
                          segment: [coordinate, coordinate]
                        }
                      ];
                    }
                    return true;
                  }, { layerFilter });
                }
                if (!nodes) {
                  var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent), projection);
                  var buffer = map.getView().getResolution() * this.pixelTolerance_;
                  var box = toUserExtent(extent_buffer(viewExtent, buffer, tempExtent), projection);
                  nodes = this.rBush_.getInExtent(box);
                }
                if (nodes && nodes.length > 0) {
                  var node = nodes.sort(sortByDistance)[0];
                  var closestSegment = node.segment;
                  var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
                  var vertexPixel = map.getPixelFromCoordinate(vertex);
                  var dist = coordinate_distance(pixel, vertexPixel);
                  if (hitPointGeometry || dist <= this.pixelTolerance_) {
                    var vertexSegments = {};
                    vertexSegments[Object(util[
                      "c"
                      /* getUid */
                    ])(closestSegment)] = true;
                    if (!this.snapToPointer_) {
                      this.delta_[0] = vertex[0] - pixelCoordinate[0];
                      this.delta_[1] = vertex[1] - pixelCoordinate[1];
                    }
                    if (node.geometry.getType() === geom_GeometryType.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                      this.snappedToVertex_ = true;
                      this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                    } else {
                      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                      var squaredDist1 = coordinate_squaredDistance(vertexPixel, pixel1);
                      var squaredDist2 = coordinate_squaredDistance(vertexPixel, pixel2);
                      dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                      this.snappedToVertex_ = dist <= this.pixelTolerance_;
                      if (this.snappedToVertex_) {
                        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                      }
                      this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                      var geometries = {};
                      geometries[Object(util[
                        "c"
                        /* getUid */
                      ])(node.geometry)] = true;
                      for (var i = 1, ii = nodes.length; i < ii; ++i) {
                        var segment = nodes[i].segment;
                        if (coordinate_equals(closestSegment[0], segment[0]) && coordinate_equals(closestSegment[1], segment[1]) || coordinate_equals(closestSegment[0], segment[1]) && coordinate_equals(closestSegment[1], segment[0])) {
                          var geometryUid = Object(util[
                            "c"
                            /* getUid */
                          ])(nodes[i].geometry);
                          if (!(geometryUid in geometries)) {
                            geometries[geometryUid] = true;
                            vertexSegments[Object(util[
                              "c"
                              /* getUid */
                            ])(segment)] = true;
                          }
                        } else {
                          break;
                        }
                      }
                    }
                    this.vertexSegments_ = vertexSegments;
                    return;
                  }
                }
                if (this.vertexFeature_) {
                  this.overlay_.getSource().removeFeature(this.vertexFeature_);
                  this.vertexFeature_ = null;
                }
              };
              Modify.prototype.insertVertex_ = function(segmentData, vertex) {
                var segment = segmentData.segment;
                var feature = segmentData.feature;
                var geometry = segmentData.geometry;
                var depth = segmentData.depth;
                var index = segmentData.index;
                var coordinates;
                while (vertex.length < geometry.getStride()) {
                  vertex.push(0);
                }
                switch (geometry.getType()) {
                  case geom_GeometryType.MULTI_LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]].splice(index + 1, 0, vertex);
                    break;
                  case geom_GeometryType.POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]].splice(index + 1, 0, vertex);
                    break;
                  case geom_GeometryType.MULTI_POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                    break;
                  case geom_GeometryType.LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates.splice(index + 1, 0, vertex);
                    break;
                  default:
                    return;
                }
                this.setGeometryCoordinates_(geometry, coordinates);
                var rTree = this.rBush_;
                rTree.remove(segmentData);
                this.updateSegmentIndices_(geometry, index, depth, 1);
                var newSegmentData = {
                  segment: [segment[0], vertex],
                  feature,
                  geometry,
                  depth,
                  index
                };
                rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
                this.dragSegments_.push([newSegmentData, 1]);
                var newSegmentData2 = {
                  segment: [vertex, segment[1]],
                  feature,
                  geometry,
                  depth,
                  index: index + 1
                };
                rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
                this.dragSegments_.push([newSegmentData2, 0]);
                this.ignoreNextSingleClick_ = true;
              };
              Modify.prototype.removePoint = function() {
                if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
                  var evt = this.lastPointerEvent_;
                  this.willModifyFeatures_(evt, this.dragSegments_);
                  var removed = this.removeVertex_();
                  this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
                  this.featuresBeingModified_ = null;
                  return removed;
                }
                return false;
              };
              Modify.prototype.removeVertex_ = function() {
                var dragSegments = this.dragSegments_;
                var segmentsByFeature = {};
                var deleted = false;
                var component, coordinates, dragSegment, geometry, i, index, left;
                var newIndex, right, segmentData, uid;
                for (i = dragSegments.length - 1; i >= 0; --i) {
                  dragSegment = dragSegments[i];
                  segmentData = dragSegment[0];
                  uid = Object(util[
                    "c"
                    /* getUid */
                  ])(segmentData.feature);
                  if (segmentData.depth) {
                    uid += "-" + segmentData.depth.join("-");
                  }
                  if (!(uid in segmentsByFeature)) {
                    segmentsByFeature[uid] = {};
                  }
                  if (dragSegment[1] === 0) {
                    segmentsByFeature[uid].right = segmentData;
                    segmentsByFeature[uid].index = segmentData.index;
                  } else if (dragSegment[1] == 1) {
                    segmentsByFeature[uid].left = segmentData;
                    segmentsByFeature[uid].index = segmentData.index + 1;
                  }
                }
                for (uid in segmentsByFeature) {
                  right = segmentsByFeature[uid].right;
                  left = segmentsByFeature[uid].left;
                  index = segmentsByFeature[uid].index;
                  newIndex = index - 1;
                  if (left !== void 0) {
                    segmentData = left;
                  } else {
                    segmentData = right;
                  }
                  if (newIndex < 0) {
                    newIndex = 0;
                  }
                  geometry = segmentData.geometry;
                  coordinates = geometry.getCoordinates();
                  component = coordinates;
                  deleted = false;
                  switch (geometry.getType()) {
                    case geom_GeometryType.MULTI_LINE_STRING:
                      if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                      }
                      break;
                    case geom_GeometryType.LINE_STRING:
                      if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                      }
                      break;
                    case geom_GeometryType.MULTI_POLYGON:
                      component = component[segmentData.depth[1]];
                    /* falls through */
                    case geom_GeometryType.POLYGON:
                      component = component[segmentData.depth[0]];
                      if (component.length > 4) {
                        if (index == component.length - 1) {
                          index = 0;
                        }
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                          component.pop();
                          component.push(component[0]);
                          newIndex = component.length - 1;
                        }
                      }
                      break;
                    default:
                  }
                  if (deleted) {
                    this.setGeometryCoordinates_(geometry, coordinates);
                    var segments = [];
                    if (left !== void 0) {
                      this.rBush_.remove(left);
                      segments.push(left.segment[0]);
                    }
                    if (right !== void 0) {
                      this.rBush_.remove(right);
                      segments.push(right.segment[1]);
                    }
                    if (left !== void 0 && right !== void 0) {
                      var newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments
                      };
                      this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
                    }
                    this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                    if (this.vertexFeature_) {
                      this.overlay_.getSource().removeFeature(this.vertexFeature_);
                      this.vertexFeature_ = null;
                    }
                    dragSegments.length = 0;
                  }
                }
                return deleted;
              };
              Modify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {
                this.changingFeature_ = true;
                geometry.setCoordinates(coordinates);
                this.changingFeature_ = false;
              };
              Modify.prototype.updateSegmentIndices_ = function(geometry, index, depth, delta) {
                this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
                  if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || Object(ol_array[
                    "b"
                    /* equals */
                  ])(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
                    segmentDataMatch.index += delta;
                  }
                });
              };
              return Modify;
            }(Pointer)
          );
          function compareIndexes(a, b) {
            return a.index - b.index;
          }
          function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
            var geometry = segmentData.geometry;
            if (geometry.getType() === geom_GeometryType.CIRCLE) {
              var circleGeometry = (
                /** @type {import("../geom/Circle.js").default} */
                geometry
              );
              if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                var userProjection = getUserProjection();
                if (userProjection) {
                  circleGeometry = /** @type {import("../geom/Circle.js").default} */
                  circleGeometry.clone().transform(userProjection, projection);
                }
                var distanceToCenterSquared = coordinate_squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates, projection));
                var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
                return distanceToCircumference * distanceToCircumference;
              }
            }
            var coordinate = fromUserCoordinate(pointCoordinates, projection);
            tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
            tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
            return squaredDistanceToSegment(coordinate, tempSegment);
          }
          function closestOnSegmentData(pointCoordinates, segmentData, projection) {
            var geometry = segmentData.geometry;
            if (geometry.getType() === geom_GeometryType.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
              var circleGeometry = (
                /** @type {import("../geom/Circle.js").default} */
                geometry
              );
              var userProjection = getUserProjection();
              if (userProjection) {
                circleGeometry = /** @type {import("../geom/Circle.js").default} */
                circleGeometry.clone().transform(userProjection, projection);
              }
              return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates, projection)), projection);
            }
            var coordinate = fromUserCoordinate(pointCoordinates, projection);
            tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
            tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
            return toUserCoordinate(closestOnSegment(coordinate, tempSegment), projection);
          }
          function Modify_getDefaultStyleFunction() {
            var style = createEditingStyle();
            return function(feature, resolution) {
              return style[geom_GeometryType.POINT];
            };
          }
          var interaction_Modify = Modify_Modify;
          var Stylevue_type_script_lang_js = {
            name: "ol-style",
            setup: function setup(props) {
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("stylable", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return new style_Style(properties);
              });
              var setStyle = function setStyle2(val) {
                if (styledObj instanceof interaction_Draw || styledObj instanceof interaction_Modify) {
                  styledObj.getOverlay().setStyle(val);
                  styledObj.value.dispatchEvent("styleChanged");
                  return;
                }
                try {
                  styledObj.value.setStyle(val);
                  styledObj.value.changed();
                  styledObj.value.dispatchEvent("styleChanged");
                } catch (error) {
                  styledObj.value.style_ = val;
                  styledObj.value.values_.style = val;
                  styledObj.value.changed();
                  styledObj.value.dispatchEvent("styleChanged");
                }
              };
              var styleFunc = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return function(feature) {
                  if (properties.overrideStyleFunction != null) {
                    properties.overrideStyleFunction(feature, style.value);
                  }
                  return style.value;
                };
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                if (properties.overrideStyleFunction == null) {
                  setStyle(style.value);
                } else {
                  setStyle(styleFunc.value);
                }
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                if (properties.overrideStyleFunction == null) {
                  setStyle(style.value);
                } else {
                  setStyle(styleFunc.value);
                }
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                setStyle(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("style", style);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
              return {
                style
              };
            },
            props: {
              zIndex: {
                type: Number
              },
              overrideStyleFunction: {
                type: Function
              }
            }
          };
          Stylevue_type_script_lang_js.render = Stylevue_type_template_id_0040721c_render;
          var styles_Style = Stylevue_type_script_lang_js;
          function Circlevue_type_template_id_022256d8_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var Circlevue_type_script_lang_js = {
            name: "ol-style-circle",
            setup: function setup(props) {
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var createCircleStyle = function createCircleStyle2(properties2) {
                return new style_Circle(_objectSpread2(_objectSpread2({}, properties2), {}, {
                  fill: new style_Fill(),
                  stroke: new style_Stroke()
                }));
              };
              var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return createCircleStyle(properties);
              });
              var applyStyle = function applyStyle2() {
                style.value.setImage(null);
                style.value.setImage(circle.value);
                styledObj.value.changed();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                style.value.setImage(circle.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                style.value.setImage(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("circle", circle);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
            },
            props: {
              radius: {
                type: Number
              },
              scale: {
                type: Number
              }
            }
          };
          Circlevue_type_script_lang_js.render = Circlevue_type_template_id_022256d8_render;
          var styles_Circle = Circlevue_type_script_lang_js;
          var Strokevue_type_template_id_6c3eb840_hoisted_1 = {
            key: 0
          };
          function Strokevue_type_template_id_6c3eb840_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var Strokevue_type_script_lang_js = {
            name: "ol-style-stroke",
            setup: function setup(props) {
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
              var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("circle", null);
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              if (style != null && circle == null) {
                var stroke = new style_Stroke(properties);
                style.value.setStroke(stroke);
                var applyStroke = function applyStroke2() {
                  style.value.setStroke(null);
                  stroke = new style_Stroke(properties);
                  style.value.setStroke(stroke);
                };
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                  applyStroke();
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                  applyStroke();
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                  style.value.setStroke(stroke);
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                  style.value.setStroke(null);
                });
              } else if (circle != null) {
                var applyStroketoCircle = function applyStroketoCircle2(properties2) {
                  circle.value.getStroke().setColor(properties2.color);
                  circle.value.getStroke().setLineCap(properties2.lineCap);
                  circle.value.getStroke().setLineDash(properties2.lineDash);
                  circle.value.getStroke().setLineDashOffset(properties2.lineDashOffset);
                  circle.value.getStroke().setLineJoin(properties2.lineJoin);
                  circle.value.getStroke().setMiterLimit(properties2.miterLimit);
                  circle.value.getStroke().setWidth(properties2.width);
                  circle.value.setRadius(circle.value.getRadius());
                  try {
                    styledObj.value.changed();
                  } catch (error) {
                    styledObj.changed();
                  }
                };
                applyStroketoCircle(properties);
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function(newVal) {
                  applyStroketoCircle(newVal);
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(circle, function() {
                  applyStroketoCircle(properties);
                });
              }
            },
            props: {
              color: {
                type: String
              },
              lineCap: {
                type: String,
                default: "round"
              },
              lineJoin: {
                type: String,
                default: "round"
              },
              lineDash: {
                type: Array
              },
              lineDashOffset: {
                type: Number,
                default: 0
              },
              miterLimit: {
                type: Number,
                default: 10
              },
              width: {
                type: Number,
                default: 1
              }
            }
          };
          Strokevue_type_script_lang_js.render = Strokevue_type_template_id_6c3eb840_render;
          var styles_Stroke = Strokevue_type_script_lang_js;
          var Fillvue_type_template_id_e0c8222c_hoisted_1 = {
            key: 0
          };
          function Fillvue_type_template_id_e0c8222c_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var Fillvue_type_script_lang_js = {
            name: "ol-style-fill",
            setup: function setup(props) {
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
              var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("circle", null);
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              if (style != null && circle == null) {
                var fill = new style_Fill(properties);
                style.value.setFill(fill);
                var applyFill = function applyFill2() {
                  style.value.setFill(null);
                  fill = new style_Fill(properties);
                  style.value.setFill(fill);
                };
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                  applyFill();
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                  applyFill();
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                  style.value.setFill(fill);
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                  style.value.setFill(null);
                });
              } else if (circle != null) {
                var applyFilltoCircle = function applyFilltoCircle2(color) {
                  circle.value.getFill().setColor(color);
                  circle.value.setRadius(circle.value.getRadius());
                  try {
                    styledObj.value.changed();
                  } catch (error) {
                    styledObj.changed();
                  }
                };
                applyFilltoCircle(properties.color);
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                  applyFilltoCircle(properties.color);
                });
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(circle, function() {
                  applyFilltoCircle(properties.color);
                });
              }
            },
            props: {
              color: {
                type: String
              }
            }
          };
          Fillvue_type_script_lang_js.render = Fillvue_type_template_id_e0c8222c_render;
          var styles_Fill = Fillvue_type_script_lang_js;
          var Iconvue_type_template_id_9ead9dc2_hoisted_1 = {
            key: 0
          };
          function Iconvue_type_template_id_9ead9dc2_render(_ctx, _cache, $props, $setup, $data, $options) {
            return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var Iconvue_type_script_lang_js = {
            name: "ol-style-icon",
            setup: function setup(props) {
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var ic = new style_Icon(properties);
                ic.load();
                return ic;
              });
              var applyStyle = function applyStyle2() {
                style.value.setImage(null);
                style.value.setImage(icon.value);
                styledObj.value.changed();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                style.value.setImage(icon.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                style.value.setImage(null);
              });
            },
            props: {
              anchor: {
                type: Array
              },
              anchorOrigin: {
                type: String,
                default: "top-left"
              },
              anchorXUnits: {
                type: String,
                default: "fraction"
              },
              color: {
                type: String
              },
              crossOrigin: {
                type: String
              },
              img: {
                type: [HTMLImageElement, HTMLCanvasElement]
              },
              offset: {
                type: Array,
                default: function _default() {
                  return [0, 0];
                }
              },
              displacement: {
                type: Array,
                default: function _default() {
                  return [0, 0];
                }
              },
              offsetOrigin: {
                type: String,
                default: "top-left"
              },
              opacity: {
                type: Number,
                default: 1
              },
              scale: {
                type: Number,
                default: 1
              },
              rotateWithView: {
                type: Boolean,
                default: false
              },
              rotation: {
                type: Number,
                default: 0
              },
              size: {
                type: Array
              },
              imgSize: {
                type: Array
              },
              src: {
                type: String
              }
            }
          };
          Iconvue_type_script_lang_js.render = Iconvue_type_template_id_9ead9dc2_render;
          var styles_Icon = Iconvue_type_script_lang_js;
          function Textvue_type_template_id_3350a60e_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
          }
          var DEFAULT_FILL_COLOR = "#333";
          var Text_Text = (
            /** @class */
            function() {
              function Text(opt_options) {
                var options = opt_options || {};
                this.font_ = options.font;
                this.rotation_ = options.rotation;
                this.rotateWithView_ = options.rotateWithView;
                this.scale_ = options.scale;
                this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
                this.text_ = options.text;
                this.textAlign_ = options.textAlign;
                this.textBaseline_ = options.textBaseline;
                this.fill_ = options.fill !== void 0 ? options.fill : new style_Fill({ color: DEFAULT_FILL_COLOR });
                this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
                this.placement_ = options.placement !== void 0 ? options.placement : TextPlacement.POINT;
                this.overflow_ = !!options.overflow;
                this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
                this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
                this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
                this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
                this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
                this.padding_ = options.padding === void 0 ? null : options.padding;
              }
              Text.prototype.clone = function() {
                var scale = this.getScale();
                return new Text({
                  font: this.getFont(),
                  placement: this.getPlacement(),
                  maxAngle: this.getMaxAngle(),
                  overflow: this.getOverflow(),
                  rotation: this.getRotation(),
                  rotateWithView: this.getRotateWithView(),
                  scale: Array.isArray(scale) ? scale.slice() : scale,
                  text: this.getText(),
                  textAlign: this.getTextAlign(),
                  textBaseline: this.getTextBaseline(),
                  fill: this.getFill() ? this.getFill().clone() : void 0,
                  stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                  offsetX: this.getOffsetX(),
                  offsetY: this.getOffsetY(),
                  backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
                  backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
                  padding: this.getPadding()
                });
              };
              Text.prototype.getOverflow = function() {
                return this.overflow_;
              };
              Text.prototype.getFont = function() {
                return this.font_;
              };
              Text.prototype.getMaxAngle = function() {
                return this.maxAngle_;
              };
              Text.prototype.getPlacement = function() {
                return this.placement_;
              };
              Text.prototype.getOffsetX = function() {
                return this.offsetX_;
              };
              Text.prototype.getOffsetY = function() {
                return this.offsetY_;
              };
              Text.prototype.getFill = function() {
                return this.fill_;
              };
              Text.prototype.getRotateWithView = function() {
                return this.rotateWithView_;
              };
              Text.prototype.getRotation = function() {
                return this.rotation_;
              };
              Text.prototype.getScale = function() {
                return this.scale_;
              };
              Text.prototype.getScaleArray = function() {
                return this.scaleArray_;
              };
              Text.prototype.getStroke = function() {
                return this.stroke_;
              };
              Text.prototype.getText = function() {
                return this.text_;
              };
              Text.prototype.getTextAlign = function() {
                return this.textAlign_;
              };
              Text.prototype.getTextBaseline = function() {
                return this.textBaseline_;
              };
              Text.prototype.getBackgroundFill = function() {
                return this.backgroundFill_;
              };
              Text.prototype.getBackgroundStroke = function() {
                return this.backgroundStroke_;
              };
              Text.prototype.getPadding = function() {
                return this.padding_;
              };
              Text.prototype.setOverflow = function(overflow) {
                this.overflow_ = overflow;
              };
              Text.prototype.setFont = function(font) {
                this.font_ = font;
              };
              Text.prototype.setMaxAngle = function(maxAngle) {
                this.maxAngle_ = maxAngle;
              };
              Text.prototype.setOffsetX = function(offsetX) {
                this.offsetX_ = offsetX;
              };
              Text.prototype.setOffsetY = function(offsetY) {
                this.offsetY_ = offsetY;
              };
              Text.prototype.setPlacement = function(placement) {
                this.placement_ = placement;
              };
              Text.prototype.setRotateWithView = function(rotateWithView) {
                this.rotateWithView_ = rotateWithView;
              };
              Text.prototype.setFill = function(fill) {
                this.fill_ = fill;
              };
              Text.prototype.setRotation = function(rotation) {
                this.rotation_ = rotation;
              };
              Text.prototype.setScale = function(scale) {
                this.scale_ = scale;
                this.scaleArray_ = toSize(scale !== void 0 ? scale : 1);
              };
              Text.prototype.setStroke = function(stroke) {
                this.stroke_ = stroke;
              };
              Text.prototype.setText = function(text) {
                this.text_ = text;
              };
              Text.prototype.setTextAlign = function(textAlign) {
                this.textAlign_ = textAlign;
              };
              Text.prototype.setTextBaseline = function(textBaseline) {
                this.textBaseline_ = textBaseline;
              };
              Text.prototype.setBackgroundFill = function(fill) {
                this.backgroundFill_ = fill;
              };
              Text.prototype.setBackgroundStroke = function(stroke) {
                this.backgroundStroke_ = stroke;
              };
              Text.prototype.setPadding = function(padding) {
                this.padding_ = padding;
              };
              return Text;
            }()
          );
          var style_Text = Text_Text;
          var Textvue_type_script_lang_js = {
            name: "ol-style-text",
            setup: function setup(props) {
              var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
              var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var createText = function createText2(properties2) {
                return new style_Text(_objectSpread2(_objectSpread2({}, properties2), {}, {
                  fill: new style_Fill(),
                  stroke: new style_Stroke()
                }));
              };
              var text = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return createText(properties);
              });
              var applyStyle = function applyStyle2() {
                style.value.setText(null);
                style.value.setText(text.value);
                styledObj.value.changed();
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                applyStyle();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                style.value.setText(text.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                style.value.setText(null);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("style", text);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
            },
            props: {
              font: {
                type: String
              },
              maxAngle: {
                type: Number,
                default: Math.PI / 4
              },
              offsetX: {
                type: Number,
                default: 0
              },
              offsetY: {
                type: Number,
                default: 0
              },
              overflow: {
                type: Boolean,
                default: false
              },
              placement: {
                type: String,
                default: "point"
              },
              scale: {
                type: Number
              },
              rotateWithView: {
                type: Boolean,
                default: false
              },
              rotation: {
                type: Number,
                default: 0
              },
              text: {
                type: String
              },
              textAlign: {
                type: String
              },
              textBaseline: {
                type: String,
                default: "middle"
              },
              padding: {
                type: Array,
                default: function _default() {
                  return [0, 0, 0, 0];
                }
              }
            }
          };
          Textvue_type_script_lang_js.render = Textvue_type_template_id_3350a60e_render;
          var styles_Text = Textvue_type_script_lang_js;
          function styles_install(app) {
            if (styles_install.installed) {
              return;
            }
            styles_install.installed = true;
            app.component(styles_Style.name, styles_Style);
            app.component(styles_Circle.name, styles_Circle);
            app.component(styles_Stroke.name, styles_Stroke);
            app.component(styles_Fill.name, styles_Fill);
            app.component(styles_Icon.name, styles_Icon);
            app.component(styles_Text.name, styles_Text);
          }
          var components_styles = styles_install;
          function SelectInteractionvue_type_template_id_7a0923bf_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var Select_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var SelectEventType = {
            /**
             * Triggered when feature(s) has been (de)selected.
             * @event SelectEvent#select
             * @api
             */
            SELECT: "select"
          };
          var SelectEvent = (
            /** @class */
            function(_super) {
              Select_extends(SelectEvent2, _super);
              function SelectEvent2(type, selected, deselected, mapBrowserEvent) {
                var _this = _super.call(this, type) || this;
                _this.selected = selected;
                _this.deselected = deselected;
                _this.mapBrowserEvent = mapBrowserEvent;
                return _this;
              }
              return SelectEvent2;
            }(Event[
              "a"
              /* default */
            ])
          );
          var originalFeatureStyles = {};
          var Select_Select = (
            /** @class */
            function(_super) {
              Select_extends(Select, _super);
              function Select(opt_options) {
                var _this = _super.call(this) || this;
                _this.on;
                _this.once;
                _this.un;
                var options = opt_options ? opt_options : {};
                _this.boundAddFeature_ = _this.addFeature_.bind(_this);
                _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
                _this.condition_ = options.condition ? options.condition : singleClick;
                _this.addCondition_ = options.addCondition ? options.addCondition : never;
                _this.removeCondition_ = options.removeCondition ? options.removeCondition : never;
                _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;
                _this.multi_ = options.multi ? options.multi : false;
                _this.filter_ = options.filter ? options.filter : functions[
                  "b"
                  /* TRUE */
                ];
                _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
                _this.style_ = options.style !== void 0 ? options.style : Select_getDefaultStyleFunction();
                _this.features_ = options.features || new ol_Collection();
                var layerFilter;
                if (options.layers) {
                  if (typeof options.layers === "function") {
                    layerFilter = options.layers;
                  } else {
                    var layers_1 = options.layers;
                    layerFilter = function(layer) {
                      return Object(ol_array[
                        "f"
                        /* includes */
                      ])(layers_1, layer);
                    };
                  }
                } else {
                  layerFilter = functions[
                    "b"
                    /* TRUE */
                  ];
                }
                _this.layerFilter_ = layerFilter;
                _this.featureLayerAssociation_ = {};
                return _this;
              }
              Select.prototype.addFeatureLayerAssociation_ = function(feature, layer) {
                this.featureLayerAssociation_[Object(util[
                  "c"
                  /* getUid */
                ])(feature)] = layer;
              };
              Select.prototype.getFeatures = function() {
                return this.features_;
              };
              Select.prototype.getHitTolerance = function() {
                return this.hitTolerance_;
              };
              Select.prototype.getLayer = function(feature) {
                return (
                  /** @type {import('../layer/Vector.js').default} */
                  this.featureLayerAssociation_[Object(util[
                    "c"
                    /* getUid */
                  ])(feature)]
                );
              };
              Select.prototype.setHitTolerance = function(hitTolerance) {
                this.hitTolerance_ = hitTolerance;
              };
              Select.prototype.setMap = function(map) {
                var currentMap = this.getMap();
                if (currentMap && this.style_) {
                  this.features_.forEach(this.restorePreviousStyle_.bind(this));
                }
                _super.prototype.setMap.call(this, map);
                if (map) {
                  this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
                  this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
                  if (this.style_) {
                    this.features_.forEach(this.applySelectedStyle_.bind(this));
                  }
                } else {
                  this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
                  this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
                }
              };
              Select.prototype.addFeature_ = function(evt) {
                var feature = evt.element;
                if (this.style_) {
                  this.applySelectedStyle_(feature);
                }
              };
              Select.prototype.removeFeature_ = function(evt) {
                var feature = evt.element;
                if (this.style_) {
                  this.restorePreviousStyle_(feature);
                }
              };
              Select.prototype.getStyle = function() {
                return this.style_;
              };
              Select.prototype.applySelectedStyle_ = function(feature) {
                var key = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                if (!(key in originalFeatureStyles)) {
                  originalFeatureStyles[key] = feature.getStyle();
                }
                feature.setStyle(this.style_);
              };
              Select.prototype.restorePreviousStyle_ = function(feature) {
                var interactions = this.getMap().getInteractions().getArray();
                for (var i = interactions.length - 1; i >= 0; --i) {
                  var interaction = interactions[i];
                  if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
                    feature.setStyle(interaction.getStyle());
                    return;
                  }
                }
                var key = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                feature.setStyle(originalFeatureStyles[key]);
                delete originalFeatureStyles[key];
              };
              Select.prototype.removeFeatureLayerAssociation_ = function(feature) {
                delete this.featureLayerAssociation_[Object(util[
                  "c"
                  /* getUid */
                ])(feature)];
              };
              Select.prototype.handleEvent = function(mapBrowserEvent) {
                if (!this.condition_(mapBrowserEvent)) {
                  return true;
                }
                var add = this.addCondition_(mapBrowserEvent);
                var remove = this.removeCondition_(mapBrowserEvent);
                var toggle = this.toggleCondition_(mapBrowserEvent);
                var set = !add && !remove && !toggle;
                var map = mapBrowserEvent.map;
                var features = this.getFeatures();
                var deselected = [];
                var selected = [];
                if (set) {
                  Object(ol_obj[
                    "b"
                    /* clear */
                  ])(this.featureLayerAssociation_);
                  map.forEachFeatureAtPixel(
                    mapBrowserEvent.pixel,
                    /**
                     * @param {import("../Feature.js").FeatureLike} feature Feature.
                     * @param {import("../layer/Layer.js").default} layer Layer.
                     * @return {boolean|undefined} Continue to iterate over the features.
                     */
                    (function(feature2, layer) {
                      if (this.filter_(feature2, layer)) {
                        selected.push(feature2);
                        this.addFeatureLayerAssociation_(feature2, layer);
                        return !this.multi_;
                      }
                    }).bind(this),
                    {
                      layerFilter: this.layerFilter_,
                      hitTolerance: this.hitTolerance_
                    }
                  );
                  for (var i = features.getLength() - 1; i >= 0; --i) {
                    var feature = features.item(i);
                    var index = selected.indexOf(feature);
                    if (index > -1) {
                      selected.splice(index, 1);
                    } else {
                      features.remove(feature);
                      deselected.push(feature);
                    }
                  }
                  if (selected.length !== 0) {
                    features.extend(selected);
                  }
                } else {
                  map.forEachFeatureAtPixel(
                    mapBrowserEvent.pixel,
                    /**
                     * @param {import("../Feature.js").FeatureLike} feature Feature.
                     * @param {import("../layer/Layer.js").default} layer Layer.
                     * @return {boolean|undefined} Continue to iterate over the features.
                     */
                    (function(feature2, layer) {
                      if (this.filter_(feature2, layer)) {
                        if ((add || toggle) && !Object(ol_array[
                          "f"
                          /* includes */
                        ])(features.getArray(), feature2)) {
                          selected.push(feature2);
                          this.addFeatureLayerAssociation_(feature2, layer);
                        } else if ((remove || toggle) && Object(ol_array[
                          "f"
                          /* includes */
                        ])(features.getArray(), feature2)) {
                          deselected.push(feature2);
                          this.removeFeatureLayerAssociation_(feature2);
                        }
                        return !this.multi_;
                      }
                    }).bind(this),
                    {
                      layerFilter: this.layerFilter_,
                      hitTolerance: this.hitTolerance_
                    }
                  );
                  for (var j = deselected.length - 1; j >= 0; --j) {
                    features.remove(deselected[j]);
                  }
                  features.extend(selected);
                }
                if (selected.length > 0 || deselected.length > 0) {
                  this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
                }
                return true;
              };
              return Select;
            }(interaction_Interaction)
          );
          function Select_getDefaultStyleFunction() {
            var styles = createEditingStyle();
            Object(ol_array[
              "c"
              /* extend */
            ])(styles[geom_GeometryType.POLYGON], styles[geom_GeometryType.LINE_STRING]);
            Object(ol_array[
              "c"
              /* extend */
            ])(styles[geom_GeometryType.GEOMETRY_COLLECTION], styles[geom_GeometryType.LINE_STRING]);
            return function(feature) {
              if (!feature.getGeometry()) {
                return null;
              }
              return styles[feature.getGeometry().getType()];
            };
          }
          var interaction_Select = Select_Select;
          var SelectInteractionvue_type_script_lang_js = {
            name: "ol-interaction-select",
            emits: ["select"],
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var s = new interaction_Select(_objectSpread2(_objectSpread2({}, properties), {}, {
                  style: new style_Style()
                }));
                s.on("select", function(event) {
                  emit("select", event);
                });
                return s;
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(select, function(newVal, oldVal) {
                map.removeInteraction(oldVal);
                map.addInteraction(newVal);
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(select.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(select.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", select);
            },
            props: {
              multi: {
                type: Boolean,
                default: false
              },
              condition: {
                type: Function
              },
              filter: {
                type: Function
              },
              features: {
                type: [ol_Collection, Object]
              }
            }
          };
          SelectInteractionvue_type_script_lang_js.render = SelectInteractionvue_type_template_id_7a0923bf_lang_true_render;
          var SelectInteraction = SelectInteractionvue_type_script_lang_js;
          function ClusterSelectInteractionvue_type_template_id_52363d25_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_interaction_SelectCluster = function(options) {
            options = options || {};
            this.pointRadius = options.pointRadius || 12;
            this.circleMaxObjects = options.circleMaxObjects || 10;
            this.maxObjects = options.maxObjects || 60;
            this.spiral = options.spiral !== false;
            this.animate = options.animate;
            this.animationDuration = options.animationDuration || 500;
            this.selectCluster_ = options.selectCluster !== false;
            var overlay = this.overlayLayer_ = new Vector({
              source: new source_Vector({
                features: new ol_Collection(),
                wrapX: options.wrapX,
                useSpatialIndex: true
              }),
              name: "Cluster overlay",
              updateWhileAnimating: true,
              updateWhileInteracting: true,
              displayInLayerSwitcher: false,
              style: options.featureStyle
            });
            if (options.layers) {
              if (typeof options.layers == "function") {
                var fnLayers = options.layers;
                options.layers = function(layer) {
                  return layer === overlay || fnLayers(layer);
                };
              } else if (options.layers.push) {
                options.layers.push(this.overlayLayer_);
              }
            }
            if (options.filter) {
              var fnFilter = options.filter;
              options.filter = function(f, l) {
                if (!l && f.get("selectclusterlink")) return false;
                else return fnFilter(f, l);
              };
            } else options.filter = function(f, l) {
              if (!l && f.get("selectclusterlink")) return false;
              else return true;
            };
            this.filter_ = options.filter;
            interaction_Select.call(this, options);
            this.on("select", this.selectCluster.bind(this));
          };
          util_ext(ol_interaction_SelectCluster, interaction_Select);
          ol_interaction_SelectCluster.prototype.setMap = function(map) {
            if (this.getMap()) {
              this.getMap().removeLayer(this.overlayLayer_);
            }
            if (this._listener) Object(Observable[
              "b"
              /* unByKey */
            ])(this._listener);
            this._listener = null;
            interaction_Select.prototype.setMap.call(this, map);
            this.overlayLayer_.setMap(map);
            if (map && map.getView()) {
              this._listener = map.getView().on("change:resolution", this.clear.bind(this));
            }
          };
          ol_interaction_SelectCluster.prototype.clear = function() {
            this.getFeatures().clear();
            this.overlayLayer_.getSource().clear();
          };
          ol_interaction_SelectCluster.prototype.getLayer = function() {
            return this.overlayLayer_;
          };
          ol_interaction_SelectCluster.prototype.selectCluster = function(e) {
            if (e instanceof ol_Feature) {
              e = { selected: [e] };
            }
            if (!e.selected.length) {
              this.clear();
              return;
            }
            var feature = e.selected[0];
            if (feature.get("selectclusterfeature")) return;
            var source = this.overlayLayer_.getSource();
            source.clear();
            var cluster = feature.get("features");
            if (!cluster || cluster.length == 1) return;
            if (!this.selectCluster_) this.getFeatures().clear();
            var center = feature.getGeometry().getCoordinates();
            var pix = this.getMap().getView().getResolution();
            var r, a, i, max;
            var p, cf, lk;
            var features = [];
            if (!this.spiral || cluster.length <= this.circleMaxObjects) {
              max = Math.min(cluster.length, this.circleMaxObjects);
              r = pix * this.pointRadius * (0.5 + max / 4);
              for (i = 0; i < max; i++) {
                a = 2 * Math.PI * i / max;
                if (max == 2 || max == 4) a += Math.PI / 4;
                p = [center[0] + r * Math.sin(a), center[1] + r * Math.cos(a)];
                cf = new ol_Feature({ "selectclusterfeature": true, "features": [cluster[i]], geometry: new geom_Point(p) });
                cf.setStyle(cluster[i].getStyle());
                features.push(cf);
                lk = new ol_Feature({ "selectclusterlink": true, geometry: new geom_LineString([center, p]) });
                features.push(lk);
              }
            } else {
              a = 0;
              var d = 2 * this.pointRadius;
              max = Math.min(this.maxObjects, cluster.length);
              for (i = 0; i < max; i++) {
                r = d / 2 + d * a / (2 * Math.PI);
                a = a + (d + 0.1) / r;
                var dx = pix * r * Math.sin(a);
                var dy = pix * r * Math.cos(a);
                p = [center[0] + dx, center[1] + dy];
                cf = new ol_Feature({ "selectclusterfeature": true, "features": [cluster[i]], geometry: new geom_Point(p) });
                cf.setStyle(cluster[i].getStyle());
                features.push(cf);
                lk = new ol_Feature({ "selectclusterlink": true, geometry: new geom_LineString([center, p]) });
                features.push(lk);
              }
            }
            source.clear();
            if (this.animate) {
              this.animateCluster_(center, features);
            } else {
              source.addFeatures(features);
            }
          };
          ol_interaction_SelectCluster.prototype.animateCluster_ = function(center, features) {
            if (this.listenerKey_) {
              Object(Observable[
                "b"
                /* unByKey */
              ])(this.listenerKey_);
            }
            if (!features.length) return;
            var style = this.overlayLayer_.getStyle();
            var stylefn = typeof style == "function" ? style : style.length ? function() {
              return style;
            } : function() {
              return [style];
            };
            var duration = this.animationDuration || 500;
            var start = (/* @__PURE__ */ new Date()).getTime();
            function animate(event) {
              var vectorContext = event.vectorContext || util_getVectorContext(event);
              var ratio = event.frameState.pixelRatio;
              var res = this.getMap().getView().getResolution();
              var e = easeOut((event.frameState.time - start) / duration);
              for (var i = 0, feature2; feature2 = features[i]; i++) if (feature2.get("features")) {
                var pt = feature2.getGeometry().getCoordinates();
                pt[0] = center[0] + e * (pt[0] - center[0]);
                pt[1] = center[1] + e * (pt[1] - center[1]);
                var geo = new geom_Point(pt);
                var st = stylefn(feature2, res);
                for (var s = 0; s < st.length; s++) {
                  var sc;
                  var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : st[s].getImage();
                  if (imgs) {
                    sc = imgs.getScale();
                    imgs.setScale(ratio);
                  }
                  if (vectorContext.setStyle) {
                    vectorContext.setStyle(st[s]);
                    vectorContext.drawGeometry(geo);
                  } else {
                    vectorContext.setImageStyle(imgs);
                    vectorContext.drawPointGeometry(geo);
                  }
                  if (imgs) imgs.setScale(sc);
                }
              }
              if (e > 1) {
                Object(Observable[
                  "b"
                  /* unByKey */
                ])(this.listenerKey_);
                this.overlayLayer_.getSource().addFeatures(features);
                this.overlayLayer_.changed();
                return;
              }
              event.frameState.animate = true;
            }
            this.listenerKey_ = this.overlayLayer_.on(["postcompose", "postrender"], animate.bind(this));
            var feature = new ol_Feature(new geom_Point(this.getMap().getView().getCenter()));
            feature.setStyle(new style_Style({ image: new style_Circle({}) }));
            this.overlayLayer_.getSource().addFeature(feature);
          };
          ol_interaction_SelectCluster.prototype.getClusterExtent = function(feature) {
            if (!feature.get("features")) return null;
            var extent = createEmpty();
            feature.get("features").forEach(function(f) {
              extent = extend2(extent, f.getGeometry().getExtent());
            });
            if (extent[0] === extent[2] && extent[1] === extent[3]) return null;
            return extent;
          };
          var SelectCluster = ol_interaction_SelectCluster;
          var ClusterSelectInteractionvue_type_script_lang_js = {
            name: "ol-interaction-clusterselect",
            emits: ["select"],
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var s = new SelectCluster(_objectSpread2(_objectSpread2({}, properties), {}, {
                  style: new style_Style()
                }));
                s.on("select", function(event) {
                  emit("select", event);
                });
                return s;
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(select, function(newVal, oldVal) {
                map.removeInteraction(oldVal);
                map.addInteraction(newVal);
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(select.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(select.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", select);
            },
            props: {
              multi: {
                type: Boolean,
                default: false
              },
              condition: {
                type: Function
              },
              filter: {
                type: Function
              },
              pointRadius: {
                type: Number,
                default: 7
              },
              animate: {
                type: Boolean,
                default: true
              },
              featureStyle: {
                type: Function
              },
              style: {
                type: Function
              }
            }
          };
          ClusterSelectInteractionvue_type_script_lang_js.render = ClusterSelectInteractionvue_type_template_id_52363d25_lang_true_render;
          var ClusterSelectInteraction = ClusterSelectInteractionvue_type_script_lang_js;
          function DrawInteractionvue_type_template_id_403e40bc_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var DrawInteractionvue_type_script_lang_js = {
            name: "ol-interaction-draw",
            emits: ["drawstart", "drawend"],
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
              var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), type = _toRefs.type, clickTolerance = _toRefs.clickTolerance, dragVertexDelay = _toRefs.dragVertexDelay, snapTolerance = _toRefs.snapTolerance, stopClick = _toRefs.stopClick, maxPoints = _toRefs.maxPoints, minPoints = _toRefs.minPoints, finishCondition = _toRefs.finishCondition, geometryFunction = _toRefs.geometryFunction, geometryName = _toRefs.geometryName, condition = _toRefs.condition, freehand = _toRefs.freehand, freehandCondition = _toRefs.freehandCondition, wrapX = _toRefs.wrapX;
              var createDraw = function createDraw2() {
                var draw2 = new interaction_Draw({
                  source: source.value,
                  type: type.value,
                  clickTolerance: clickTolerance.value,
                  dragVertexDelay: dragVertexDelay.value,
                  snapTolerance: snapTolerance.value,
                  stopClick: stopClick.value,
                  maxPoints: maxPoints.value,
                  minPoints: minPoints.value,
                  finishCondition: finishCondition.value,
                  geometryFunction: geometryFunction.value,
                  geometryName: geometryName.value,
                  condition: condition.value,
                  freehand: freehand.value,
                  freehandCondition: freehandCondition.value,
                  wrapX: wrapX.value
                });
                draw2.on("drawstart", function(event) {
                  emit("drawstart", event);
                });
                draw2.on("drawend", function(event) {
                  emit("drawend", event);
                });
                return draw2;
              };
              var draw = createDraw();
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])([type, clickTolerance, dragVertexDelay, snapTolerance, stopClick, maxPoints, minPoints, finishCondition, geometryFunction, geometryName, condition, freehand, freehandCondition, wrapX], function() {
                map.removeInteraction(draw);
                draw = createDraw();
                map.addInteraction(draw);
                draw.changed();
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(draw);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(draw);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", draw);
            },
            props: {
              type: {
                type: String,
                required: true
              },
              clickTolerance: {
                type: Number,
                default: 6
              },
              dragVertexDelay: {
                type: Number,
                default: 500
              },
              snapTolerance: {
                type: Number,
                default: 12
              },
              stopClick: {
                type: Boolean,
                default: false
              },
              maxPoints: {
                type: Number
              },
              minPoints: {
                type: Number
              },
              finishCondition: {
                type: Function
              },
              geometryFunction: {
                type: Function
              },
              geometryName: {
                type: String
              },
              condition: {
                type: Function
              },
              freehand: {
                type: Boolean,
                default: false
              },
              freehandCondition: {
                type: Function
              },
              wrapX: {
                type: Boolean,
                default: false
              }
            }
          };
          DrawInteractionvue_type_script_lang_js.render = DrawInteractionvue_type_template_id_403e40bc_lang_true_render;
          var DrawInteraction = DrawInteractionvue_type_script_lang_js;
          function SnapInteractionvue_type_template_id_0e672858_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var Snap_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          function getFeatureFromEvent(evt) {
            if (
              /** @type {import("../source/Vector.js").VectorSourceEvent} */
              evt.feature
            ) {
              return (
                /** @type {import("../source/Vector.js").VectorSourceEvent} */
                evt.feature
              );
            } else if (
              /** @type {import("../Collection.js").CollectionEvent} */
              evt.element
            ) {
              return (
                /** @type {import("../Feature.js").default} */
                /** @type {import("../Collection.js").CollectionEvent} */
                evt.element
              );
            }
          }
          var Snap_tempSegment = [];
          var Snap_Snap = (
            /** @class */
            function(_super) {
              Snap_extends(Snap, _super);
              function Snap(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                var pointerOptions = (
                  /** @type {import("./Pointer.js").Options} */
                  options
                );
                if (!pointerOptions.handleDownEvent) {
                  pointerOptions.handleDownEvent = functions[
                    "b"
                    /* TRUE */
                  ];
                }
                if (!pointerOptions.stopDown) {
                  pointerOptions.stopDown = functions[
                    "a"
                    /* FALSE */
                  ];
                }
                _this = _super.call(this, pointerOptions) || this;
                _this.source_ = options.source ? options.source : null;
                _this.vertex_ = options.vertex !== void 0 ? options.vertex : true;
                _this.edge_ = options.edge !== void 0 ? options.edge : true;
                _this.features_ = options.features ? options.features : null;
                _this.featuresListenerKeys_ = [];
                _this.featureChangeListenerKeys_ = {};
                _this.indexedFeaturesExtents_ = {};
                _this.pendingFeatures_ = {};
                _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
                _this.rBush_ = new structs_RBush();
                _this.SEGMENT_WRITERS_ = {
                  "Point": _this.writePointGeometry_.bind(_this),
                  "LineString": _this.writeLineStringGeometry_.bind(_this),
                  "LinearRing": _this.writeLineStringGeometry_.bind(_this),
                  "Polygon": _this.writePolygonGeometry_.bind(_this),
                  "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
                  "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
                  "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
                  "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this),
                  "Circle": _this.writeCircleGeometry_.bind(_this)
                };
                return _this;
              }
              Snap.prototype.addFeature = function(feature, opt_listen) {
                var register = opt_listen !== void 0 ? opt_listen : true;
                var feature_uid = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                var geometry = feature.getGeometry();
                if (geometry) {
                  var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
                  if (segmentWriter) {
                    this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
                    segmentWriter(feature, geometry);
                  }
                }
                if (register) {
                  this.featureChangeListenerKeys_[feature_uid] = Object(events[
                    "a"
                    /* listen */
                  ])(feature, EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.handleFeatureChange_, this);
                }
              };
              Snap.prototype.forEachFeatureAdd_ = function(feature) {
                this.addFeature(feature);
              };
              Snap.prototype.forEachFeatureRemove_ = function(feature) {
                this.removeFeature(feature);
              };
              Snap.prototype.getFeatures_ = function() {
                var features;
                if (this.features_) {
                  features = this.features_;
                } else if (this.source_) {
                  features = this.source_.getFeatures();
                }
                return features;
              };
              Snap.prototype.handleEvent = function(evt) {
                var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
                if (result.snapped) {
                  evt.coordinate = result.vertex.slice(0, 2);
                  evt.pixel = result.vertexPixel;
                }
                return _super.prototype.handleEvent.call(this, evt);
              };
              Snap.prototype.handleFeatureAdd_ = function(evt) {
                var feature = getFeatureFromEvent(evt);
                this.addFeature(feature);
              };
              Snap.prototype.handleFeatureRemove_ = function(evt) {
                var feature = getFeatureFromEvent(evt);
                this.removeFeature(feature);
              };
              Snap.prototype.handleFeatureChange_ = function(evt) {
                var feature = (
                  /** @type {import("../Feature.js").default} */
                  evt.target
                );
                if (this.handlingDownUpSequence) {
                  var uid = Object(util[
                    "c"
                    /* getUid */
                  ])(feature);
                  if (!(uid in this.pendingFeatures_)) {
                    this.pendingFeatures_[uid] = feature;
                  }
                } else {
                  this.updateFeature_(feature);
                }
              };
              Snap.prototype.handleUpEvent = function(evt) {
                var featuresToUpdate = Object(ol_obj[
                  "c"
                  /* getValues */
                ])(this.pendingFeatures_);
                if (featuresToUpdate.length) {
                  featuresToUpdate.forEach(this.updateFeature_.bind(this));
                  this.pendingFeatures_ = {};
                }
                return false;
              };
              Snap.prototype.removeFeature = function(feature, opt_unlisten) {
                var unregister = opt_unlisten !== void 0 ? opt_unlisten : true;
                var feature_uid = Object(util[
                  "c"
                  /* getUid */
                ])(feature);
                var extent = this.indexedFeaturesExtents_[feature_uid];
                if (extent) {
                  var rBush = this.rBush_;
                  var nodesToRemove_1 = [];
                  rBush.forEachInExtent(extent, function(node) {
                    if (feature === node.feature) {
                      nodesToRemove_1.push(node);
                    }
                  });
                  for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
                    rBush.remove(nodesToRemove_1[i]);
                  }
                }
                if (unregister) {
                  Object(events[
                    "c"
                    /* unlistenByKey */
                  ])(this.featureChangeListenerKeys_[feature_uid]);
                  delete this.featureChangeListenerKeys_[feature_uid];
                }
              };
              Snap.prototype.setMap = function(map) {
                var currentMap = this.getMap();
                var keys = this.featuresListenerKeys_;
                var features = (
                  /** @type {Array<import("../Feature.js").default>} */
                  this.getFeatures_()
                );
                if (currentMap) {
                  keys.forEach(events[
                    "c"
                    /* unlistenByKey */
                  ]);
                  keys.length = 0;
                  features.forEach(this.forEachFeatureRemove_.bind(this));
                }
                _super.prototype.setMap.call(this, map);
                if (map) {
                  if (this.features_) {
                    keys.push(Object(events[
                      "a"
                      /* listen */
                    ])(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), Object(events[
                      "a"
                      /* listen */
                    ])(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
                  } else if (this.source_) {
                    keys.push(Object(events[
                      "a"
                      /* listen */
                    ])(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), Object(events[
                      "a"
                      /* listen */
                    ])(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
                  }
                  features.forEach(this.forEachFeatureAdd_.bind(this));
                }
              };
              Snap.prototype.snapTo = function(pixel, pixelCoordinate, map) {
                var lowerLeft = map.getCoordinateFromPixel([
                  pixel[0] - this.pixelTolerance_,
                  pixel[1] + this.pixelTolerance_
                ]);
                var upperRight = map.getCoordinateFromPixel([
                  pixel[0] + this.pixelTolerance_,
                  pixel[1] - this.pixelTolerance_
                ]);
                var box = boundingExtent([lowerLeft, upperRight]);
                var segments = this.rBush_.getInExtent(box);
                if (this.vertex_ && !this.edge_) {
                  segments = segments.filter(function(segment) {
                    return segment.feature.getGeometry().getType() !== geom_GeometryType.CIRCLE;
                  });
                }
                var snapped = false;
                var vertex = null;
                var vertexPixel = null;
                if (segments.length === 0) {
                  return {
                    snapped,
                    vertex,
                    vertexPixel
                  };
                }
                var projection = map.getView().getProjection();
                var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);
                var closestSegmentData;
                var minSquaredDistance = Infinity;
                for (var i = 0; i < segments.length; ++i) {
                  var segmentData = segments[i];
                  Snap_tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
                  Snap_tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
                  var delta = squaredDistanceToSegment(projectedCoordinate, Snap_tempSegment);
                  if (delta < minSquaredDistance) {
                    closestSegmentData = segmentData;
                    minSquaredDistance = delta;
                  }
                }
                var closestSegment = closestSegmentData.segment;
                if (this.vertex_ && !this.edge_) {
                  var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                  var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                  var squaredDist1 = coordinate_squaredDistance(pixel, pixel1);
                  var squaredDist2 = coordinate_squaredDistance(pixel, pixel2);
                  var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                  if (dist <= this.pixelTolerance_) {
                    snapped = true;
                    vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    vertexPixel = map.getPixelFromCoordinate(vertex);
                  }
                } else if (this.edge_) {
                  var isCircle = closestSegmentData.feature.getGeometry().getType() === geom_GeometryType.CIRCLE;
                  if (isCircle) {
                    var circleGeometry = closestSegmentData.feature.getGeometry();
                    var userProjection = getUserProjection();
                    if (userProjection) {
                      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    }
                    vertex = toUserCoordinate(closestOnCircle(
                      projectedCoordinate,
                      /** @type {import("../geom/Circle.js").default} */
                      circleGeometry
                    ), projection);
                  } else {
                    Snap_tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);
                    Snap_tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);
                    vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, Snap_tempSegment), projection);
                  }
                  vertexPixel = map.getPixelFromCoordinate(vertex);
                  if (coordinate_distance(pixel, vertexPixel) <= this.pixelTolerance_) {
                    snapped = true;
                    if (this.vertex_ && !isCircle) {
                      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                      var squaredDist1 = coordinate_squaredDistance(vertexPixel, pixel1);
                      var squaredDist2 = coordinate_squaredDistance(vertexPixel, pixel2);
                      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                      if (dist <= this.pixelTolerance_) {
                        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                        vertexPixel = map.getPixelFromCoordinate(vertex);
                      }
                    }
                  }
                }
                if (snapped) {
                  vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
                }
                return {
                  snapped,
                  vertex,
                  vertexPixel
                };
              };
              Snap.prototype.updateFeature_ = function(feature) {
                this.removeFeature(feature, false);
                this.addFeature(feature, false);
              };
              Snap.prototype.writeCircleGeometry_ = function(feature, geometry) {
                var projection = this.getMap().getView().getProjection();
                var circleGeometry = geometry;
                var userProjection = getUserProjection();
                if (userProjection) {
                  circleGeometry = /** @type {import("../geom/Circle.js").default} */
                  circleGeometry.clone().transform(userProjection, projection);
                }
                var polygon = fromCircle(circleGeometry);
                if (userProjection) {
                  polygon.transform(projection, userProjection);
                }
                var coordinates = polygon.getCoordinates()[0];
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                    feature,
                    segment
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
                }
              };
              Snap.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
                var geometries = geometry.getGeometriesArray();
                for (var i = 0; i < geometries.length; ++i) {
                  var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
                  if (segmentWriter) {
                    segmentWriter(feature, geometries[i]);
                  }
                }
              };
              Snap.prototype.writeLineStringGeometry_ = function(feature, geometry) {
                var coordinates = geometry.getCoordinates();
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                    feature,
                    segment
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
                }
              };
              Snap.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
                var lines = geometry.getCoordinates();
                for (var j = 0, jj = lines.length; j < jj; ++j) {
                  var coordinates = lines[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var segment = coordinates.slice(i, i + 2);
                    var segmentData = {
                      feature,
                      segment
                    };
                    this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
                }
              };
              Snap.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
                var points = geometry.getCoordinates();
                for (var i = 0, ii = points.length; i < ii; ++i) {
                  var coordinates = points[i];
                  var segmentData = {
                    feature,
                    segment: [coordinates, coordinates]
                  };
                  this.rBush_.insert(geometry.getExtent(), segmentData);
                }
              };
              Snap.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
                var polygons = geometry.getCoordinates();
                for (var k = 0, kk = polygons.length; k < kk; ++k) {
                  var rings = polygons[k];
                  for (var j = 0, jj = rings.length; j < jj; ++j) {
                    var coordinates = rings[j];
                    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                      var segment = coordinates.slice(i, i + 2);
                      var segmentData = {
                        feature,
                        segment
                      };
                      this.rBush_.insert(boundingExtent(segment), segmentData);
                    }
                  }
                }
              };
              Snap.prototype.writePointGeometry_ = function(feature, geometry) {
                var coordinates = geometry.getCoordinates();
                var segmentData = {
                  feature,
                  segment: [coordinates, coordinates]
                };
                this.rBush_.insert(geometry.getExtent(), segmentData);
              };
              Snap.prototype.writePolygonGeometry_ = function(feature, geometry) {
                var rings = geometry.getCoordinates();
                for (var j = 0, jj = rings.length; j < jj; ++j) {
                  var coordinates = rings[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var segment = coordinates.slice(i, i + 2);
                    var segmentData = {
                      feature,
                      segment
                    };
                    this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
                }
              };
              return Snap;
            }(Pointer)
          );
          var interaction_Snap = Snap_Snap;
          var SnapInteractionvue_type_script_lang_js = {
            name: "ol-interaction-snap",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var createSnap = function createSnap2() {
                var s = new interaction_Snap(_objectSpread2(_objectSpread2({}, properties), {}, {
                  source: source.value
                }));
                return s;
              };
              var snap = createSnap();
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                map.removeInteraction(snap);
                snap = createSnap();
                map.addInteraction(snap);
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(snap);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(snap);
              });
            },
            props: {
              vertex: {
                type: Boolean,
                default: true
              },
              edge: {
                type: Boolean,
                default: true
              },
              pixelTolerance: {
                type: Number,
                default: 10
              }
            }
          };
          SnapInteractionvue_type_script_lang_js.render = SnapInteractionvue_type_template_id_0e672858_lang_true_render;
          var SnapInteraction = SnapInteractionvue_type_script_lang_js;
          function ModifyInteractionvue_type_template_id_13ac86b6_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ModifyInteractionvue_type_script_lang_js = {
            name: "ol-interaction-modify",
            emits: ["modifystart", "modifyend"],
            setup: function setup(props, _ref) {
              var emit = _ref.emit;
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
              var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), features = _toRefs.features, condition = _toRefs.condition, deleteCondition = _toRefs.deleteCondition, insertVertexCondition = _toRefs.insertVertexCondition, pixelTolerance = _toRefs.pixelTolerance, wrapX = _toRefs.wrapX, hitDetection = _toRefs.hitDetection;
              var createModify = function createModify2() {
                var modify2 = new interaction_Modify({
                  source: source.value,
                  features: features.value,
                  condition: condition.value,
                  deleteCondition: deleteCondition.value,
                  insertVertexCondition: insertVertexCondition.value,
                  pixelTolerance: pixelTolerance.value,
                  wrapX: wrapX.value,
                  hitDetection: hitDetection.value
                });
                modify2.on("modifystart", function(event) {
                  emit("modifystart", event);
                });
                modify2.on("modifyend", function(event) {
                  emit("modifyend", event);
                });
                return modify2;
              };
              var modify = createModify();
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])([condition, deleteCondition, insertVertexCondition, pixelTolerance, wrapX, hitDetection], function() {
                map.removeInteraction(modify);
                modify = createModify();
                map.addInteraction(modify);
                modify.changed();
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(modify);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(modify);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", modify);
            },
            props: {
              condition: {
                type: Function
              },
              deleteCondition: {
                type: Function
              },
              insertVertexCondition: {
                type: Function
              },
              pixelTolerance: {
                type: Number,
                default: 10
              },
              wrapX: {
                type: Boolean,
                default: false
              },
              hitDetection: {
                type: Boolean
              },
              features: {
                type: [ol_Collection, Object]
              }
            }
          };
          ModifyInteractionvue_type_script_lang_js.render = ModifyInteractionvue_type_template_id_13ac86b6_lang_true_render;
          var ModifyInteraction = ModifyInteractionvue_type_script_lang_js;
          function TransformInteractionvue_type_template_id_044a350b_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_interaction_Transform = function(options) {
            if (!options) options = {};
            var self2 = this;
            this.selection_ = new ol_Collection();
            this.handles_ = new ol_Collection();
            this.overlayLayer_ = new Vector({
              source: new source_Vector({
                features: this.handles_,
                useSpatialIndex: false,
                wrapX: false
                // For vector editing across the -180 and 180 meridians to work properly, this should be set to false
              }),
              name: "Transform overlay",
              displayInLayerSwitcher: false,
              // Return the style according to the handle type
              style: function(feature) {
                return self2.style[(feature.get("handle") || "default") + (feature.get("constraint") || "") + (feature.get("option") || "")];
              }
            });
            Pointer.call(this, {
              handleDownEvent: this.handleDownEvent_,
              handleDragEvent: this.handleDragEvent_,
              handleMoveEvent: this.handleMoveEvent_,
              handleUpEvent: this.handleUpEvent_
            });
            this.features_ = options.features;
            if (typeof options.filter === "function") this._filter = options.filter;
            this.layers_ = options.layers ? options.layers instanceof Array ? options.layers : [options.layers] : null;
            this._handleEvent = options.condition || function() {
              return true;
            };
            this.addFn_ = options.addCondition || function() {
              return false;
            };
            this.set("translateFeature", options.translateFeature !== false);
            this.set("translate", options.translate !== false);
            this.set("translateBBox", options.translateBBox === true);
            this.set("stretch", options.stretch !== false);
            this.set("scale", options.scale !== false);
            this.set("rotate", options.rotate !== false);
            this.set("keepAspectRatio", options.keepAspectRatio || function(e) {
              return e.originalEvent.shiftKey;
            });
            this.set("modifyCenter", options.modifyCenter || function(e) {
              return e.originalEvent.metaKey || e.originalEvent.ctrlKey;
            });
            this.set("noFlip", options.noFlip || false);
            this.set("selection", options.selection !== false);
            this.set("hitTolerance", options.hitTolerance || 0);
            this.set("enableRotatedTransform", options.enableRotatedTransform || false);
            this.on("propertychange", function() {
              this.drawSketch_();
            });
            this.setDefaultStyle();
          };
          util_ext(ol_interaction_Transform, Pointer);
          ol_interaction_Transform.prototype.Cursors = {
            "default": "auto",
            "select": "pointer",
            "translate": "move",
            "rotate": "move",
            "rotate0": "move",
            "scale": "nesw-resize",
            "scale1": "nwse-resize",
            "scale2": "nesw-resize",
            "scale3": "nwse-resize",
            "scalev": "ew-resize",
            "scaleh1": "ns-resize",
            "scalev2": "ew-resize",
            "scaleh3": "ns-resize"
          };
          ol_interaction_Transform.prototype.setMap = function(map) {
            var oldMap = this.getMap();
            if (oldMap) {
              var targetElement = oldMap.getTargetElement();
              oldMap.removeLayer(this.overlayLayer_);
              if (this.previousCursor_ && targetElement) {
                targetElement.style.cursor = this.previousCursor_;
              }
              this.previousCursor_ = void 0;
            }
            Pointer.prototype.setMap.call(this, map);
            this.overlayLayer_.setMap(map);
            if (map === null) {
              this.select(null);
            }
            if (map !== null) {
              this.isTouch = /touch/.test(map.getViewport().className);
              this.setDefaultStyle();
            }
          };
          ol_interaction_Transform.prototype.setActive = function(b) {
            this.select(null);
            this.overlayLayer_.setVisible(b);
            Pointer.prototype.setActive.call(this, b);
          };
          ol_interaction_Transform.prototype.setDefaultStyle = function(options) {
            options = options || {};
            var stroke = options.pointStroke || new style_Stroke({ color: [255, 0, 0, 1], width: 1 });
            var strokedash = options.stroke || new style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] });
            var fill0 = options.fill || new style_Fill({ color: [255, 0, 0, 0.01] });
            var fill = options.pointFill || new style_Fill({ color: [255, 255, 255, 0.8] });
            var circle = new style_RegularShape({
              fill,
              stroke,
              radius: this.isTouch ? 12 : 6,
              points: 15
            });
            circle.getAnchor()[0] = this.isTouch ? -10 : -5;
            var bigpt = new style_RegularShape({
              fill,
              stroke,
              radius: this.isTouch ? 16 : 8,
              points: 4,
              angle: Math.PI / 4
            });
            var smallpt = new style_RegularShape({
              fill,
              stroke,
              radius: this.isTouch ? 12 : 6,
              points: 4,
              angle: Math.PI / 4
            });
            function createStyle(img, stroke2, fill2) {
              return [new style_Style({ image: img, stroke: stroke2, fill: fill2 })];
            }
            this.style = {
              "default": createStyle(bigpt, strokedash, fill0),
              "translate": createStyle(bigpt, stroke, fill),
              "rotate": createStyle(circle, stroke, fill),
              "rotate0": createStyle(bigpt, stroke, fill),
              "scale": createStyle(bigpt, stroke, fill),
              "scale1": createStyle(bigpt, stroke, fill),
              "scale2": createStyle(bigpt, stroke, fill),
              "scale3": createStyle(bigpt, stroke, fill),
              "scalev": createStyle(smallpt, stroke, fill),
              "scaleh1": createStyle(smallpt, stroke, fill),
              "scalev2": createStyle(smallpt, stroke, fill),
              "scaleh3": createStyle(smallpt, stroke, fill)
            };
            this.drawSketch_();
          };
          ol_interaction_Transform.prototype.setStyle = function(style, olstyle) {
            if (!olstyle) return;
            if (olstyle instanceof Array) this.style[style] = olstyle;
            else this.style[style] = [olstyle];
            for (var i = 0; i < this.style[style].length; i++) {
              var im = this.style[style][i].getImage();
              if (im) {
                if (style == "rotate") im.getAnchor()[0] = -5;
                if (this.isTouch) im.setScale(1.8);
              }
              var tx = this.style[style][i].getText();
              if (tx) {
                if (style == "rotate") tx.setOffsetX(this.isTouch ? 14 : 7);
                if (this.isTouch) tx.setScale(1.8);
              }
            }
            this.drawSketch_();
          };
          ol_interaction_Transform.prototype.getFeatureAtPixel_ = function(pixel) {
            var self2 = this;
            return this.getMap().forEachFeatureAtPixel(
              pixel,
              function(feature, layer) {
                var found = false;
                if (!layer) {
                  if (feature === self2.bbox_) {
                    if (self2.get("translateBBox")) {
                      return { feature, handle: "translate", constraint: "", option: "" };
                    } else {
                      return false;
                    }
                  }
                  self2.handles_.forEach(function(f) {
                    if (f === feature) found = true;
                  });
                  if (found) return { feature, handle: feature.get("handle"), constraint: feature.get("constraint"), option: feature.get("option") };
                }
                if (!self2.get("selection")) {
                  if (self2.selection_.getArray().some(function(f) {
                    return feature === f;
                  })) {
                    return { feature };
                  }
                  return null;
                }
                if (self2._filter) {
                  if (self2._filter(feature, layer)) return { feature };
                  else return null;
                } else if (self2.layers_) {
                  for (var i = 0; i < self2.layers_.length; i++) {
                    if (self2.layers_[i] === layer) return { feature };
                  }
                  return null;
                } else if (self2.features_) {
                  self2.features_.forEach(function(f) {
                    if (f === feature) found = true;
                  });
                  if (found) return { feature };
                  else return null;
                } else return { feature };
              },
              { hitTolerance: this.get("hitTolerance") }
            ) || {};
          };
          ol_interaction_Transform.prototype.getGeometryRotateToZero_ = function(f, clone2) {
            var origGeom = f.getGeometry();
            var viewRotation = this.getMap().getView().getRotation();
            if (viewRotation === 0 || !this.get("enableRotatedTransform")) {
              return clone2 ? origGeom.clone() : origGeom;
            }
            var rotGeom = origGeom.clone();
            rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter());
            return rotGeom;
          };
          ol_interaction_Transform.prototype.drawSketch_ = function(center) {
            var i, f, geom;
            this.overlayLayer_.getSource().clear();
            if (!this.selection_.getLength()) return;
            var viewRotation = this.getMap().getView().getRotation();
            var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent();
            ext = extent_buffer(ext, 0);
            this.selection_.forEach((function(f2) {
              var extendExt = this.getGeometryRotateToZero_(f2).getExtent();
              extend2(ext, extendExt);
            }).bind(this));
            if (center === true) {
              if (!this.ispt_) {
                this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new geom_Point(this.center_), handle: "rotate0" }));
                geom = fromExtent(ext);
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  geom.rotate(viewRotation, this.getMap().getView().getCenter());
                }
                f = this.bbox_ = new ol_Feature(geom);
                this.overlayLayer_.getSource().addFeature(f);
              }
            } else {
              if (this.ispt_) {
                var p = this.getMap().getPixelFromCoordinate([ext[0], ext[1]]);
                ext = boundingExtent([
                  this.getMap().getCoordinateFromPixel([p[0] - 10, p[1] - 10]),
                  this.getMap().getCoordinateFromPixel([p[0] + 10, p[1] + 10])
                ]);
              }
              geom = fromExtent(ext);
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                geom.rotate(viewRotation, this.getMap().getView().getCenter());
              }
              f = this.bbox_ = new ol_Feature(geom);
              var features = [];
              var g = geom.getCoordinates()[0];
              if (!this.ispt_) {
                features.push(f);
                if (!this.iscircle_ && this.get("stretch") && this.get("scale")) for (i = 0; i < g.length - 1; i++) {
                  f = new ol_Feature({ geometry: new geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: "scale", constraint: i % 2 ? "h" : "v", option: i });
                  features.push(f);
                }
                if (this.get("scale")) for (i = 0; i < g.length - 1; i++) {
                  f = new ol_Feature({ geometry: new geom_Point(g[i]), handle: "scale", option: i });
                  features.push(f);
                }
                if (this.get("translate") && !this.get("translateFeature")) {
                  f = new ol_Feature({ geometry: new geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: "translate" });
                  features.push(f);
                }
              }
              if (!this.iscircle_ && this.get("rotate")) {
                f = new ol_Feature({ geometry: new geom_Point(g[3]), handle: "rotate" });
                features.push(f);
              }
              this.overlayLayer_.getSource().addFeatures(features);
            }
          };
          ol_interaction_Transform.prototype.select = function(feature, add) {
            if (!feature) {
              this.selection_.clear();
              this.drawSketch_();
              return;
            }
            if (!feature.getGeometry || !feature.getGeometry()) return;
            if (add) {
              this.selection_.push(feature);
            } else {
              var index = this.selection_.getArray().indexOf(feature);
              this.selection_.removeAt(index);
            }
            this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
            this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
            this.drawSketch_();
            this.watchFeatures_();
            this.dispatchEvent({ type: "select", feature, features: this.selection_ });
          };
          ol_interaction_Transform.prototype.setSelection = function(features) {
            this.selection_.clear();
            features.forEach((function(feature) {
              this.selection_.push(feature);
            }).bind(this));
            this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
            this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
            this.drawSketch_();
            this.watchFeatures_();
            this.dispatchEvent({ type: "select", features: this.selection_ });
          };
          ol_interaction_Transform.prototype.watchFeatures_ = function() {
            if (this._featureListeners) {
              this._featureListeners.forEach(function(l) {
                Object(Observable[
                  "b"
                  /* unByKey */
                ])(l);
              });
            }
            this._featureListeners = [];
            this.selection_.forEach((function(f) {
              this._featureListeners.push(
                f.on("change", (function() {
                  if (!this.isUpdating_) {
                    this.drawSketch_();
                  }
                }).bind(this))
              );
            }).bind(this));
          };
          ol_interaction_Transform.prototype.handleDownEvent_ = function(evt) {
            if (!this._handleEvent(evt, this.selection_)) return;
            var sel = this.getFeatureAtPixel_(evt.pixel);
            var feature = sel.feature;
            if (this.selection_.getLength() && this.selection_.getArray().indexOf(feature) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature"))) {
              sel.handle = "translate";
            }
            if (sel.handle) {
              this.mode_ = sel.handle;
              this.opt_ = sel.option;
              this.constraint_ = sel.constraint;
              var viewRotation = this.getMap().getView().getRotation();
              this.coordinate_ = evt.coordinate;
              this.pixel_ = evt.pixel;
              this.geoms_ = [];
              this.rotatedGeoms_ = [];
              var extent = createEmpty();
              var rotExtent = createEmpty();
              for (var i = 0, f; f = this.selection_.item(i); i++) {
                this.geoms_.push(f.getGeometry().clone());
                extent = extend2(extent, f.getGeometry().getExtent());
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  var rotGeom = this.getGeometryRotateToZero_(f, true);
                  this.rotatedGeoms_.push(rotGeom);
                  rotExtent = extend2(rotExtent, rotGeom.getExtent());
                }
              }
              this.extent_ = fromExtent(extent).getCoordinates()[0];
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                this.rotatedExtent_ = fromExtent(rotExtent).getCoordinates()[0];
              }
              if (this.mode_ === "rotate") {
                this.center_ = this.getCenter() || extent_getCenter(extent);
                var element = evt.map.getTargetElement();
                element.style.cursor = this.Cursors.rotate0;
                this.previousCursor_ = element.style.cursor;
              } else {
                this.center_ = extent_getCenter(extent);
              }
              this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0]);
              this.dispatchEvent({
                type: this.mode_ + "start",
                feature: this.selection_.item(0),
                // backward compatibility
                features: this.selection_,
                pixel: evt.pixel,
                coordinate: evt.coordinate
              });
              return true;
            } else if (this.get("selection")) {
              if (feature) {
                if (!this.addFn_(evt)) this.selection_.clear();
                var index = this.selection_.getArray().indexOf(feature);
                if (index < 0) this.selection_.push(feature);
                else this.selection_.removeAt(index);
              } else {
                this.selection_.clear();
              }
              this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
              this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
              this.drawSketch_();
              this.watchFeatures_();
              this.dispatchEvent({ type: "select", feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate });
              return false;
            }
          };
          ol_interaction_Transform.prototype.getFeatures = function() {
            return this.selection_;
          };
          ol_interaction_Transform.prototype.getCenter = function() {
            return this.get("center");
          };
          ol_interaction_Transform.prototype.setCenter = function(c) {
            return this.set("center", c);
          };
          ol_interaction_Transform.prototype.handleDragEvent_ = function(evt) {
            if (!this._handleEvent(evt, this.features_)) return;
            var viewRotation = this.getMap().getView().getRotation();
            var i, f, geometry;
            var pt0 = [this.coordinate_[0], this.coordinate_[1]];
            var pt = [evt.coordinate[0], evt.coordinate[1]];
            this.isUpdating_ = true;
            switch (this.mode_) {
              case "rotate": {
                var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0]);
                if (!this.ispt) {
                  for (i = 0, f; f = this.selection_.item(i); i++) {
                    geometry = this.geoms_[i].clone();
                    geometry.rotate(a - this.angle_, this.center_);
                    if (geometry.getType() == "Circle") geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
                    f.setGeometry(geometry);
                  }
                }
                this.drawSketch_(true);
                this.dispatchEvent({
                  type: "rotating",
                  feature: this.selection_.item(0),
                  features: this.selection_,
                  angle: a - this.angle_,
                  pixel: evt.pixel,
                  coordinate: evt.coordinate
                });
                break;
              }
              case "translate": {
                var deltaX = pt[0] - pt0[0];
                var deltaY = pt[1] - pt0[1];
                for (i = 0, f; f = this.selection_.item(i); i++) {
                  f.getGeometry().translate(deltaX, deltaY);
                }
                this.handles_.forEach(function(f2) {
                  f2.getGeometry().translate(deltaX, deltaY);
                });
                this.coordinate_ = evt.coordinate;
                this.dispatchEvent({
                  type: "translating",
                  feature: this.selection_.item(0),
                  features: this.selection_,
                  delta: [deltaX, deltaY],
                  pixel: evt.pixel,
                  coordinate: evt.coordinate
                });
                break;
              }
              case "scale": {
                var center = this.center_;
                if (this.get("modifyCenter")(evt)) {
                  var extentCoordinates = this.extent_;
                  if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                    extentCoordinates = this.rotatedExtent_;
                  }
                  center = extentCoordinates[(Number(this.opt_) + 2) % 4];
                }
                var downCoordinate = this.coordinate_;
                var dragCoordinate = evt.coordinate;
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  var downPoint = new geom_Point(this.coordinate_);
                  downPoint.rotate(viewRotation * -1, center);
                  downCoordinate = downPoint.getCoordinates();
                  var dragPoint = new geom_Point(evt.coordinate);
                  dragPoint.rotate(viewRotation * -1, center);
                  dragCoordinate = dragPoint.getCoordinates();
                }
                var scx = (dragCoordinate[0] - center[0]) / (downCoordinate[0] - center[0]);
                var scy = (dragCoordinate[1] - center[1]) / (downCoordinate[1] - center[1]);
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  var centerPoint = new geom_Point(center);
                  centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter());
                  center = centerPoint.getCoordinates();
                }
                if (this.get("noFlip")) {
                  if (scx < 0) scx = -scx;
                  if (scy < 0) scy = -scy;
                }
                if (this.constraint_) {
                  if (this.constraint_ == "h") scx = 1;
                  else scy = 1;
                } else {
                  if (this.get("keepAspectRatio")(evt)) {
                    scx = scy = Math.min(scx, scy);
                  }
                }
                for (i = 0, f; f = this.selection_.item(i); i++) {
                  geometry = viewRotation === 0 || !this.get("enableRotatedTransform") ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone();
                  geometry.applyTransform(function(g1, g2, dim) {
                    if (dim < 2) return g2;
                    for (var j = 0; j < g1.length; j += dim) {
                      if (scx != 1) g2[j] = center[0] + (g1[j] - center[0]) * scx;
                      if (scy != 1) g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy;
                    }
                    if (geometry.getType() == "Circle") geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
                    return g2;
                  });
                  if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                    geometry.rotate(viewRotation, this.getMap().getView().getCenter());
                  }
                  f.setGeometry(geometry);
                }
                this.drawSketch_();
                this.dispatchEvent({
                  type: "scaling",
                  feature: this.selection_.item(0),
                  features: this.selection_,
                  scale: [scx, scy],
                  pixel: evt.pixel,
                  coordinate: evt.coordinate
                });
                break;
              }
              default:
                break;
            }
            this.isUpdating_ = false;
          };
          ol_interaction_Transform.prototype.handleMoveEvent_ = function(evt) {
            if (!this._handleEvent(evt, this.features_)) return;
            if (!this.mode_) {
              var sel = this.getFeatureAtPixel_(evt.pixel);
              var element = evt.map.getTargetElement();
              if (sel.feature) {
                var c = sel.handle ? this.Cursors[(sel.handle || "default") + (sel.constraint || "") + (sel.option || "")] : this.Cursors.select;
                if (this.previousCursor_ === void 0) {
                  this.previousCursor_ = element.style.cursor;
                }
                element.style.cursor = c;
              } else {
                if (this.previousCursor_ !== void 0) element.style.cursor = this.previousCursor_;
                this.previousCursor_ = void 0;
              }
            }
          };
          ol_interaction_Transform.prototype.handleUpEvent_ = function(evt) {
            if (this.mode_ === "rotate") {
              var element = evt.map.getTargetElement();
              element.style.cursor = this.Cursors.default;
              this.previousCursor_ = void 0;
            }
            this.dispatchEvent({
              type: this.mode_ + "end",
              feature: this.selection_.item(0),
              features: this.selection_,
              oldgeom: this.geoms_[0],
              oldgeoms: this.geoms_
            });
            this.drawSketch_();
            this.mode_ = null;
            return false;
          };
          ol_interaction_Transform.prototype.getFeatures = function() {
            return this.selection_;
          };
          var Transform = ol_interaction_Transform;
          var TransformInteractionvue_type_script_lang_js = {
            name: "ol-interaction-transform",
            setup: function setup(props) {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
              var transform2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                var interaction = new Transform(_objectSpread2({}, properties));
                return interaction;
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(transform2, function(newVal, oldVal) {
                map.removeInteraction(oldVal);
                map.addInteraction(newVal);
                map.changed();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                map.addInteraction(transform2.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                map.removeInteraction(transform2.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", transform2);
            },
            props: {
              enableRotatedTransform: {
                type: Boolean,
                default: false
              },
              condition: {
                type: Function
              },
              addCondition: {
                type: Function
              },
              filter: {
                type: Function
              },
              layers: {
                type: Array
              },
              hitTolerance: {
                type: Number,
                default: 2
              },
              translateFeature: {
                type: Boolean,
                default: true
              },
              scale: {
                type: Boolean,
                default: true
              },
              rotate: {
                type: Boolean,
                default: true
              },
              keepAspectRatio: {
                type: Boolean,
                default: false
              },
              translate: {
                type: Boolean,
                default: true
              },
              stretch: {
                type: Boolean,
                default: true
              }
            }
          };
          TransformInteractionvue_type_script_lang_js.render = TransformInteractionvue_type_template_id_044a350b_lang_true_render;
          var TransformInteraction = TransformInteractionvue_type_script_lang_js;
          function interaction_install(app) {
            if (interaction_install.installed) {
              return;
            }
            interaction_install.installed = true;
            app.component(SelectInteraction.name, SelectInteraction);
            app.component(ClusterSelectInteraction.name, ClusterSelectInteraction);
            app.component(DrawInteraction.name, DrawInteraction);
            app.component(SnapInteraction.name, SnapInteraction);
            app.component(ModifyInteraction.name, ModifyInteraction);
            app.component(TransformInteraction.name, TransformInteraction);
          }
          var components_interaction = interaction_install;
          function FeatureAnimationvue_type_template_id_733c99d6_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var FeatureAnimationvue_type_script_lang_js = {
            setup: function setup() {
              var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
              var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
              return {
                map,
                vectorLayer
              };
            },
            props: {
              duration: {
                type: Number,
                default: 1e3
              },
              revers: {
                type: Boolean,
                default: false
              },
              repeat: {
                type: Number,
                default: 0
              },
              fade: {
                type: Function
              },
              easing: {
                type: Function,
                default: easeOut
              }
            }
          };
          FeatureAnimationvue_type_script_lang_js.render = FeatureAnimationvue_type_template_id_733c99d6_lang_true_render;
          var FeatureAnimation = FeatureAnimationvue_type_script_lang_js;
          function DropAnimationvue_type_template_id_75951dd8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var es_array_map = __webpack_require__("d81d");
          var ol_featureAnimation = function(options) {
            options = options || {};
            this.duration_ = typeof options.duration == "number" ? options.duration >= 0 ? options.duration : 0 : 1e3;
            this.fade_ = typeof options.fade == "function" ? options.fade : null;
            this.repeat_ = Number(options.repeat);
            var easing = typeof options.easing == "function" ? options.easing : linear;
            if (options.revers) this.easing_ = function(t) {
              return 1 - easing(t);
            };
            else this.easing_ = easing;
            this.hiddenStyle = options.hiddenStyle;
            ol_Object[
              "a"
              /* default */
            ].call(this);
          };
          util_ext(ol_featureAnimation, ol_Object[
            "a"
            /* default */
          ]);
          ol_featureAnimation.hiddenStyle = new style_Style({
            image: new style_Circle({}),
            stroke: new style_Stroke({
              color: "transparent"
            })
          });
          ol_featureAnimation.prototype.drawGeom_ = function(e, geom, shadow) {
            if (this.fade_) {
              e.context.globalAlpha = this.fade_(1 - e.elapsed);
            }
            var style = e.style;
            for (var i = 0; i < style.length; i++) {
              try {
                var vectorContext = e.vectorContext || util_getVectorContext(e);
                vectorContext.setStyle(style[i]);
                if (style[i].getZIndex() < 0) vectorContext.drawGeometry(shadow || geom);
                else vectorContext.drawGeometry(geom);
              } catch (e2) {
              }
            }
          };
          ol_featureAnimation.prototype.animate = function() {
            return false;
          };
          ol_Map.prototype.animateFeature = function(feature, fanim) {
            var layer = this._featureAnimationLayer;
            if (!layer) {
              layer = this._featureAnimationLayer = new Vector({ source: new source_Vector() });
              layer.setMap(this);
            }
            layer.getSource().addFeature(feature);
            var listener = fanim.on("animationend", function(e) {
              if (e.feature === feature) {
                layer.getSource().removeFeature(feature);
                Object(Observable[
                  "b"
                  /* unByKey */
                ])(listener);
              }
            });
            layer.animateFeature(feature, fanim);
          };
          Base.prototype.animateFeature = function(feature, fanim, useFilter) {
            var self2 = this;
            var listenerKey;
            var style = feature.getStyle();
            var flashStyle = style || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);
            if (!flashStyle) flashStyle = [];
            if (!(flashStyle instanceof Array)) flashStyle = [flashStyle];
            var event = {
              // Frame context
              vectorContext: null,
              frameState: null,
              start: 0,
              time: 0,
              elapsed: 0,
              extent: false,
              // Feature information
              feature,
              geom: feature.getGeometry(),
              typeGeom: feature.getGeometry().getType(),
              bbox: feature.getGeometry().getExtent(),
              coord: extent_getCenter(feature.getGeometry().getExtent()),
              style: flashStyle
            };
            if (!(fanim instanceof Array)) fanim = [fanim];
            for (var i = fanim.length - 1; i >= 0; i--) {
              if (fanim[i].duration_ === 0) fanim.splice(i, 1);
            }
            var nb = 0, step = 0;
            var filters = useFilter && this.getFilters ? this.getFilters() : [];
            function animate(e) {
              event.type = e.type;
              try {
                event.vectorContext = e.vectorContext || util_getVectorContext(e);
              } catch (e2) {
              }
              event.frameState = e.frameState;
              event.inversePixelTransform = e.inversePixelTransform;
              if (!event.extent) {
                event.extent = e.frameState.extent;
                event.start = e.frameState.time;
                event.context = e.context;
              }
              event.time = e.frameState.time - event.start;
              event.elapsed = event.time / fanim[step].duration_;
              if (event.elapsed > 1) event.elapsed = 1;
              e.context.save();
              filters.forEach(function(f) {
                if (f.get("active")) f.precompose(e);
              });
              if (this.getOpacity) {
                e.context.globalAlpha = this.getOpacity();
              }
              if (!fanim[step].animate(event)) {
                nb++;
                if (nb < fanim[step].repeat_) {
                  event.extent = false;
                } else if (step < fanim.length - 1) {
                  fanim[step].dispatchEvent({ type: "animationend", feature });
                  step++;
                  nb = 0;
                  event.extent = false;
                } else {
                  stop();
                }
              } else {
                var animEvent = {
                  type: "animating",
                  step,
                  start: event.start,
                  time: event.time,
                  elapsed: event.elapsed,
                  rotation: event.rotation || 0,
                  geom: event.geom,
                  coordinate: event.coord,
                  feature
                };
                fanim[step].dispatchEvent(animEvent);
                self2.dispatchEvent(animEvent);
              }
              filters.forEach(function(f) {
                if (f.get("active")) f.postcompose(e);
              });
              e.context.restore();
              e.frameState.animate = true;
            }
            function stop(options) {
              Object(Observable[
                "b"
                /* unByKey */
              ])(listenerKey);
              listenerKey = null;
              feature.setStyle(style);
              var event2 = { type: "animationend", feature };
              if (options) {
                for (var i2 in options) if (options.hasOwnProperty(i2)) {
                  event2[i2] = options[i2];
                }
              }
              fanim[step].dispatchEvent(event2);
              self2.dispatchEvent(event2);
            }
            function start(options) {
              if (fanim.length && !listenerKey) {
                listenerKey = self2.on(["postcompose", "postrender"], animate.bind(self2));
                if (self2.renderSync) self2.renderSync();
                else self2.changed();
                feature.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);
                var event2 = { type: "animationstart", feature };
                if (options) {
                  for (var i2 in options) if (options.hasOwnProperty(i2)) {
                    event2[i2] = options[i2];
                  }
                }
                fanim[step].dispatchEvent(event2);
                self2.dispatchEvent(event2);
              }
            }
            start();
            return {
              start,
              stop,
              isPlaying: function() {
                return !!listenerKey;
              }
            };
          };
          var featureanimation_FeatureAnimation = ol_featureAnimation;
          var ol_featureAnimation_Drop = function(options) {
            options = options || {};
            this.speed_ = options.speed || 0;
            featureanimation_FeatureAnimation.call(this, options);
            this.side_ = options.side || "top";
          };
          util_ext(ol_featureAnimation_Drop, featureanimation_FeatureAnimation);
          ol_featureAnimation_Drop.prototype.animate = function(e) {
            if (!e.time) {
              var angle = e.frameState.viewState.rotation;
              var s = e.frameState.size[1] * e.frameState.viewState.resolution;
              if (this.side_ != "top") s *= -1;
              this.dx = -Math.sin(angle) * s;
              this.dy = Math.cos(angle) * s;
              if (this.speed_) {
                this.duration_ = s / this.speed_ / e.frameState.viewState.resolution;
              }
            }
            var flashGeom = e.geom.clone();
            flashGeom.translate(
              this.dx * (1 - this.easing_(e.elapsed)),
              this.dy * (1 - this.easing_(e.elapsed))
            );
            this.drawGeom_(e, flashGeom, e.geom);
            return e.time <= this.duration_;
          };
          var Drop = ol_featureAnimation_Drop;
          function useAnimation(AnimationType, props) {
            var _Animation$setup = FeatureAnimation.setup(), map = _Animation$setup.map, vectorLayer = _Animation$setup.vectorLayer;
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var animation = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var anim = new AnimationType(_objectSpread2({}, properties));
              return anim;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("animation", animation);
            return {
              map,
              vectorLayer,
              animation,
              properties
            };
          }
          var DropAnimationvue_type_script_lang_js = {
            name: "ol-animation-drop",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(Drop, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
              return {
                map,
                vectorLayer,
                properties
              };
            },
            props: {
              side: {
                type: Number,
                default: 0
              },
              speed: {
                type: Number,
                default: 0
              }
            }
          };
          DropAnimationvue_type_script_lang_js.render = DropAnimationvue_type_template_id_75951dd8_lang_true_render;
          var DropAnimation = DropAnimationvue_type_script_lang_js;
          function ShakeAnimationvue_type_template_id_1703e1b0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_featureAnimation_Shake = function(options) {
            options = options || {};
            featureanimation_FeatureAnimation.call(this, options);
            this.amplitude_ = options.amplitude || 40;
            this.bounce_ = -Math.PI * (options.bounce || 6);
            this.horizontal_ = options.horizontal;
          };
          util_ext(ol_featureAnimation_Shake, featureanimation_FeatureAnimation);
          ol_featureAnimation_Shake.prototype.animate = function(e) {
            var flashGeom = e.geom.clone();
            var shadow = e.geom.clone();
            var t = this.easing_(e.elapsed);
            t = Math.sin(this.bounce_ * t) * this.amplitude_ * (1 - t) * e.frameState.viewState.resolution;
            if (this.horizontal_) {
              flashGeom.translate(t, 0);
              shadow.translate(t, 0);
            } else flashGeom.translate(0, t);
            this.drawGeom_(e, flashGeom, shadow);
            return e.time <= this.duration_;
          };
          var Shake = ol_featureAnimation_Shake;
          var ShakeAnimationvue_type_script_lang_js = {
            name: "ol-animation-shake",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(Shake, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties, animation = _useAnimation.animation;
              return {
                map,
                vectorLayer,
                properties,
                animation
              };
            },
            props: {
              bounce: {
                type: Number,
                default: 6
              },
              amplitude: {
                type: Number,
                default: 40
              },
              horizontal: {
                type: Boolean,
                default: false
              }
            }
          };
          ShakeAnimationvue_type_script_lang_js.render = ShakeAnimationvue_type_template_id_1703e1b0_lang_true_render;
          var ShakeAnimation = ShakeAnimationvue_type_script_lang_js;
          function ZoomAnimationvue_type_template_id_06ca7ff1_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_featureAnimation_Zoom = function(options) {
            options = options || {};
            featureanimation_FeatureAnimation.call(this, options);
            this.set("zoomout", options.zoomOut);
          };
          util_ext(ol_featureAnimation_Zoom, featureanimation_FeatureAnimation);
          var ol_featureAnimation_ZoomOut = function(options) {
            options = options || {};
            options.zoomOut = true;
            ol_featureAnimation_Zoom.call(this, options);
          };
          util_ext(ol_featureAnimation_ZoomOut, ol_featureAnimation_Zoom);
          ol_featureAnimation_Zoom.prototype.animate = function(e) {
            var fac = this.easing_(e.elapsed);
            if (fac) {
              if (this.get("zoomout")) fac = 1 / fac;
              var style = e.style;
              var i, imgs, sc = [];
              for (i = 0; i < style.length; i++) {
                imgs = style[i].getImage();
                if (imgs) {
                  sc[i] = imgs.getScale();
                  if (e.type === "postrender") imgs.setScale(sc[i] * fac / e.frameState.pixelRatio);
                  else imgs.setScale(sc[i] * fac);
                }
              }
              this.drawGeom_(e, e.geom);
              for (i = 0; i < style.length; i++) {
                imgs = style[i].getImage();
                if (imgs) imgs.setScale(sc[i]);
              }
            }
            return e.time <= this.duration_;
          };
          var featureanimation_Zoom = ol_featureAnimation_Zoom;
          var ZoomAnimationvue_type_script_lang_js = {
            name: "ol-animation-zoom",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(featureanimation_Zoom, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
              return {
                map,
                vectorLayer,
                properties
              };
            },
            props: {
              zoomOut: {
                type: Boolean,
                default: false
              }
            }
          };
          ZoomAnimationvue_type_script_lang_js.render = ZoomAnimationvue_type_template_id_06ca7ff1_lang_true_render;
          var ZoomAnimation = ZoomAnimationvue_type_script_lang_js;
          function TeleportAnimationvue_type_template_id_1d6d3df8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_featureAnimation_Teleport = function(options) {
            featureanimation_FeatureAnimation.call(this, options);
          };
          util_ext(ol_featureAnimation_Teleport, featureanimation_FeatureAnimation);
          ol_featureAnimation_Teleport.prototype.animate = function(e) {
            var sc = this.easing_(e.elapsed);
            if (sc) {
              e.context.save();
              var ratio = e.frameState.pixelRatio;
              e.context.globalAlpha = sc;
              e.context.scale(sc, 1 / sc);
              var m = e.frameState.coordinateToPixelTransform;
              var dx = (1 / sc - 1) * ratio * (m[0] * e.coord[0] + m[1] * e.coord[1] + m[4]);
              var dy = (sc - 1) * ratio * (m[2] * e.coord[0] + m[3] * e.coord[1] + m[5]);
              e.context.translate(dx, dy);
              this.drawGeom_(e, e.geom);
              e.context.restore();
            }
            return e.time <= this.duration_;
          };
          var Teleport = ol_featureAnimation_Teleport;
          var TeleportAnimationvue_type_script_lang_js = {
            name: "ol-animation-teleport",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(Teleport, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
              return {
                map,
                vectorLayer,
                properties
              };
            },
            props: {}
          };
          TeleportAnimationvue_type_script_lang_js.render = TeleportAnimationvue_type_template_id_1d6d3df8_lang_true_render;
          var TeleportAnimation = TeleportAnimationvue_type_script_lang_js;
          function FadeAnimationvue_type_template_id_cb41c1b2_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_featureAnimation_Fade = function(options) {
            options = options || {};
            this.speed_ = options.speed || 0;
            featureanimation_FeatureAnimation.call(this, options);
          };
          util_ext(ol_featureAnimation_Fade, featureanimation_FeatureAnimation);
          ol_featureAnimation_Fade.prototype.animate = function(e) {
            e.context.globalAlpha = this.easing_(e.elapsed);
            this.drawGeom_(e, e.geom);
            return e.time <= this.duration_;
          };
          var Fade = ol_featureAnimation_Fade;
          var FadeAnimationvue_type_script_lang_js = {
            name: "ol-animation-fade",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(Fade, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
              return {
                map,
                vectorLayer,
                properties
              };
            }
          };
          FadeAnimationvue_type_script_lang_js.render = FadeAnimationvue_type_template_id_cb41c1b2_lang_true_render;
          var FadeAnimation = FadeAnimationvue_type_script_lang_js;
          function SlideAnimationvue_type_template_id_11eaec2d_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
          }
          var ol_featureAnimation_Slide = function(options) {
            options = options || {};
            this.speed_ = options.speed || 0;
            featureanimation_FeatureAnimation.call(this, options);
            this.side_ = options.side || "left";
          };
          util_ext(ol_featureAnimation_Slide, featureanimation_FeatureAnimation);
          ol_featureAnimation_Slide.prototype.animate = function(e) {
            if (!e.time) {
              if (this.side_ == "left") this.dx = e.extent[0] - e.bbox[2];
              else this.dx = e.extent[2] - e.bbox[0];
              if (this.speed_) this.duration_ = Math.abs(this.dx) / this.speed_ / e.frameState.viewState.resolution;
            }
            var flashGeom = e.geom.clone();
            flashGeom.translate(this.dx * (1 - this.easing_(e.elapsed)), 0);
            this.drawGeom_(e, flashGeom);
            return e.time <= this.duration_;
          };
          var Slide = ol_featureAnimation_Slide;
          var SlideAnimationvue_type_script_lang_js = {
            name: "ol-animation-slide",
            extends: FeatureAnimation,
            setup: function setup(props) {
              var _useAnimation = useAnimation(Slide, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
              return {
                map,
                vectorLayer,
                properties
              };
            },
            props: {
              speed: {
                type: Number,
                default: 0
              }
            }
          };
          SlideAnimationvue_type_script_lang_js.render = SlideAnimationvue_type_template_id_11eaec2d_lang_true_render;
          var SlideAnimation = SlideAnimationvue_type_script_lang_js;
          function animations_install(app) {
            if (animations_install.installed) {
              return;
            }
            animations_install.installed = true;
            app.component(FeatureAnimation.name, FeatureAnimation);
            app.component(DropAnimation.name, DropAnimation);
            app.component(ShakeAnimation.name, ShakeAnimation);
            app.component(ZoomAnimation.name, ZoomAnimation);
            app.component(TeleportAnimation.name, TeleportAnimation);
            app.component(FadeAnimation.name, FadeAnimation);
            app.component(SlideAnimation.name, SlideAnimation);
          }
          var animations = animations_install;
          var ol_ol = __webpack_require__("5bc0");
          var ol_ext = __webpack_require__("dbd0");
          var dist_ol_contextmenu = __webpack_require__("872d");
          var assets_style = __webpack_require__("7d05");
          var GeometryCollection_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GeometryCollection_GeometryCollection = (
            /** @class */
            function(_super) {
              GeometryCollection_extends(GeometryCollection, _super);
              function GeometryCollection(opt_geometries) {
                var _this = _super.call(this) || this;
                _this.geometries_ = opt_geometries ? opt_geometries : null;
                _this.changeEventsKeys_ = [];
                _this.listenGeometriesChange_();
                return _this;
              }
              GeometryCollection.prototype.unlistenGeometriesChange_ = function() {
                this.changeEventsKeys_.forEach(events[
                  "c"
                  /* unlistenByKey */
                ]);
                this.changeEventsKeys_.length = 0;
              };
              GeometryCollection.prototype.listenGeometriesChange_ = function() {
                if (!this.geometries_) {
                  return;
                }
                for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
                  this.changeEventsKeys_.push(Object(events[
                    "a"
                    /* listen */
                  ])(this.geometries_[i], EventType[
                    "a"
                    /* default */
                  ].CHANGE, this.changed, this));
                }
              };
              GeometryCollection.prototype.clone = function() {
                var geometryCollection = new GeometryCollection(null);
                geometryCollection.setGeometries(this.geometries_);
                geometryCollection.applyProperties(this);
                return geometryCollection;
              };
              GeometryCollection.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
                if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
                  return minSquaredDistance;
                }
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
                }
                return minSquaredDistance;
              };
              GeometryCollection.prototype.containsXY = function(x, y) {
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  if (geometries[i].containsXY(x, y)) {
                    return true;
                  }
                }
                return false;
              };
              GeometryCollection.prototype.computeExtent = function(extent) {
                createOrUpdateEmpty(extent);
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  extend2(extent, geometries[i].getExtent());
                }
                return extent;
              };
              GeometryCollection.prototype.getGeometries = function() {
                return cloneGeometries(this.geometries_);
              };
              GeometryCollection.prototype.getGeometriesArray = function() {
                return this.geometries_;
              };
              GeometryCollection.prototype.getGeometriesArrayRecursive = function() {
                var geometriesArray = [];
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  if (geometries[i].getType() === this.getType()) {
                    geometriesArray = geometriesArray.concat(
                      /** @type {GeometryCollection} */
                      geometries[i].getGeometriesArrayRecursive()
                    );
                  } else {
                    geometriesArray.push(geometries[i]);
                  }
                }
                return geometriesArray;
              };
              GeometryCollection.prototype.getSimplifiedGeometry = function(squaredTolerance) {
                if (this.simplifiedGeometryRevision !== this.getRevision()) {
                  this.simplifiedGeometryMaxMinSquaredTolerance = 0;
                  this.simplifiedGeometryRevision = this.getRevision();
                }
                if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
                  return this;
                }
                var simplifiedGeometries = [];
                var geometries = this.geometries_;
                var simplified = false;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  var geometry = geometries[i];
                  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
                  simplifiedGeometries.push(simplifiedGeometry);
                  if (simplifiedGeometry !== geometry) {
                    simplified = true;
                  }
                }
                if (simplified) {
                  var simplifiedGeometryCollection = new GeometryCollection(null);
                  simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
                  return simplifiedGeometryCollection;
                } else {
                  this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
                  return this;
                }
              };
              GeometryCollection.prototype.getType = function() {
                return geom_GeometryType.GEOMETRY_COLLECTION;
              };
              GeometryCollection.prototype.intersectsExtent = function(extent) {
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  if (geometries[i].intersectsExtent(extent)) {
                    return true;
                  }
                }
                return false;
              };
              GeometryCollection.prototype.isEmpty = function() {
                return this.geometries_.length === 0;
              };
              GeometryCollection.prototype.rotate = function(angle, anchor) {
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  geometries[i].rotate(angle, anchor);
                }
                this.changed();
              };
              GeometryCollection.prototype.scale = function(sx, opt_sy, opt_anchor) {
                var anchor = opt_anchor;
                if (!anchor) {
                  anchor = extent_getCenter(this.getExtent());
                }
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  geometries[i].scale(sx, opt_sy, anchor);
                }
                this.changed();
              };
              GeometryCollection.prototype.setGeometries = function(geometries) {
                this.setGeometriesArray(cloneGeometries(geometries));
              };
              GeometryCollection.prototype.setGeometriesArray = function(geometries) {
                this.unlistenGeometriesChange_();
                this.geometries_ = geometries;
                this.listenGeometriesChange_();
                this.changed();
              };
              GeometryCollection.prototype.applyTransform = function(transformFn) {
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  geometries[i].applyTransform(transformFn);
                }
                this.changed();
              };
              GeometryCollection.prototype.translate = function(deltaX, deltaY) {
                var geometries = this.geometries_;
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  geometries[i].translate(deltaX, deltaY);
                }
                this.changed();
              };
              GeometryCollection.prototype.disposeInternal = function() {
                this.unlistenGeometriesChange_();
                _super.prototype.disposeInternal.call(this);
              };
              return GeometryCollection;
            }(geom_Geometry)
          );
          function cloneGeometries(geometries) {
            var clonedGeometries = [];
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              clonedGeometries.push(geometries[i].clone());
            }
            return clonedGeometries;
          }
          var geom_GeometryCollection = GeometryCollection_GeometryCollection;
          var Feature_FeatureFormat = (
            /** @class */
            function() {
              function FeatureFormat() {
                this.dataProjection = void 0;
                this.defaultFeatureProjection = void 0;
              }
              FeatureFormat.prototype.getReadOptions = function(source, opt_options) {
                var options;
                if (opt_options) {
                  var dataProjection = opt_options.dataProjection ? proj_get(opt_options.dataProjection) : this.readProjection(source);
                  if (opt_options.extent && dataProjection && dataProjection.getUnits() === proj_Units.TILE_PIXELS) {
                    dataProjection = proj_get(dataProjection);
                    dataProjection.setWorldExtent(opt_options.extent);
                  }
                  options = {
                    dataProjection,
                    featureProjection: opt_options.featureProjection
                  };
                }
                return this.adaptOptions(options);
              };
              FeatureFormat.prototype.adaptOptions = function(options) {
                return Object(ol_obj[
                  "a"
                  /* assign */
                ])({
                  dataProjection: this.dataProjection,
                  featureProjection: this.defaultFeatureProjection
                }, options);
              };
              FeatureFormat.prototype.getType = function() {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.readFeature = function(source, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.readFeatures = function(source, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.readGeometry = function(source, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.readProjection = function(source) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.writeFeature = function(feature, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.writeFeatures = function(features, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              FeatureFormat.prototype.writeGeometry = function(geometry, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              return FeatureFormat;
            }()
          );
          var format_Feature = Feature_FeatureFormat;
          function transformGeometryWithOptions(geometry, write, opt_options) {
            var featureProjection = opt_options ? proj_get(opt_options.featureProjection) : null;
            var dataProjection = opt_options ? proj_get(opt_options.dataProjection) : null;
            var transformed;
            if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
              transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
            } else {
              transformed = geometry;
            }
            if (write && opt_options && /** @type {WriteOptions} */
            opt_options.decimals !== void 0) {
              var power_1 = Math.pow(
                10,
                /** @type {WriteOptions} */
                opt_options.decimals
              );
              var transform2 = function(coordinates) {
                for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                  coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
                }
                return coordinates;
              };
              if (transformed === geometry) {
                transformed = geometry.clone();
              }
              transformed.applyTransform(transform2);
            }
            return transformed;
          }
          function transformExtentWithOptions(extent, opt_options) {
            var featureProjection = opt_options ? proj_get(opt_options.featureProjection) : null;
            var dataProjection = opt_options ? proj_get(opt_options.dataProjection) : null;
            if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
              return transformExtent(extent, dataProjection, featureProjection);
            } else {
              return extent;
            }
          }
          var JSONFeature_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var JSONFeature_JSONFeature = (
            /** @class */
            function(_super) {
              JSONFeature_extends(JSONFeature, _super);
              function JSONFeature() {
                return _super.call(this) || this;
              }
              JSONFeature.prototype.getType = function() {
                return FormatType.JSON;
              };
              JSONFeature.prototype.readFeature = function(source, opt_options) {
                return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
              };
              JSONFeature.prototype.readFeatures = function(source, opt_options) {
                return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
              };
              JSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.readGeometry = function(source, opt_options) {
                return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
              };
              JSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.readProjection = function(source) {
                return this.readProjectionFromObject(getObject(source));
              };
              JSONFeature.prototype.readProjectionFromObject = function(object) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.writeFeature = function(feature, opt_options) {
                return JSON.stringify(this.writeFeatureObject(feature, opt_options));
              };
              JSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.writeFeatures = function(features, opt_options) {
                return JSON.stringify(this.writeFeaturesObject(features, opt_options));
              };
              JSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              JSONFeature.prototype.writeGeometry = function(geometry, opt_options) {
                return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
              };
              JSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              return JSONFeature;
            }(format_Feature)
          );
          function getObject(source) {
            if (typeof source === "string") {
              var object = JSON.parse(source);
              return object ? (
                /** @type {Object} */
                object
              ) : null;
            } else if (source !== null) {
              return source;
            } else {
              return null;
            }
          }
          var format_JSONFeature = JSONFeature_JSONFeature;
          var EsriJSON_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GEOMETRY_READERS = {};
          GEOMETRY_READERS[geom_GeometryType.POINT] = readPointGeometry;
          GEOMETRY_READERS[geom_GeometryType.LINE_STRING] = readLineStringGeometry;
          GEOMETRY_READERS[geom_GeometryType.POLYGON] = readPolygonGeometry;
          GEOMETRY_READERS[geom_GeometryType.MULTI_POINT] = readMultiPointGeometry;
          GEOMETRY_READERS[geom_GeometryType.MULTI_LINE_STRING] = readMultiLineStringGeometry;
          GEOMETRY_READERS[geom_GeometryType.MULTI_POLYGON] = readMultiPolygonGeometry;
          var GEOMETRY_WRITERS = {};
          GEOMETRY_WRITERS[geom_GeometryType.POINT] = writePointGeometry;
          GEOMETRY_WRITERS[geom_GeometryType.LINE_STRING] = writeLineStringGeometry;
          GEOMETRY_WRITERS[geom_GeometryType.POLYGON] = writePolygonGeometry;
          GEOMETRY_WRITERS[geom_GeometryType.MULTI_POINT] = writeMultiPointGeometry;
          GEOMETRY_WRITERS[geom_GeometryType.MULTI_LINE_STRING] = writeMultiLineStringGeometry;
          GEOMETRY_WRITERS[geom_GeometryType.MULTI_POLYGON] = writeMultiPolygonGeometry;
          var EsriJSON_EsriJSON = (
            /** @class */
            function(_super) {
              EsriJSON_extends(EsriJSON, _super);
              function EsriJSON(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this) || this;
                _this.geometryName_ = options.geometryName;
                return _this;
              }
              EsriJSON.prototype.readFeatureFromObject = function(object, opt_options, opt_idField) {
                var esriJSONFeature = (
                  /** @type {EsriJSONFeature} */
                  object
                );
                var geometry = readGeometry(esriJSONFeature.geometry, opt_options);
                var feature = new ol_Feature();
                if (this.geometryName_) {
                  feature.setGeometryName(this.geometryName_);
                }
                feature.setGeometry(geometry);
                if (esriJSONFeature.attributes) {
                  feature.setProperties(esriJSONFeature.attributes, true);
                  var id = esriJSONFeature.attributes[opt_idField];
                  if (id !== void 0) {
                    feature.setId(
                      /** @type {number} */
                      id
                    );
                  }
                }
                return feature;
              };
              EsriJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
                var options = opt_options ? opt_options : {};
                if (object["features"]) {
                  var esriJSONFeatureSet = (
                    /** @type {EsriJSONFeatureSet} */
                    object
                  );
                  var features = [];
                  var esriJSONFeatures = esriJSONFeatureSet.features;
                  for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
                    features.push(this.readFeatureFromObject(esriJSONFeatures[i], options, object.objectIdFieldName));
                  }
                  return features;
                } else {
                  return [this.readFeatureFromObject(object, options)];
                }
              };
              EsriJSON.prototype.readGeometryFromObject = function(object, opt_options) {
                return readGeometry(object, opt_options);
              };
              EsriJSON.prototype.readProjectionFromObject = function(object) {
                if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
                  var spatialReference = (
                    /** @type {EsriJSONSpatialReferenceWkid} */
                    object["spatialReference"]
                  );
                  var crs = spatialReference.wkid;
                  return proj_get("EPSG:" + crs);
                } else {
                  return null;
                }
              };
              EsriJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
                return writeGeometry(geometry, this.adaptOptions(opt_options));
              };
              EsriJSON.prototype.writeFeatureObject = function(feature, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var object = {};
                if (!feature.hasProperties()) {
                  object["attributes"] = {};
                  return object;
                }
                var properties = feature.getProperties();
                var geometry = feature.getGeometry();
                if (geometry) {
                  object["geometry"] = writeGeometry(geometry, opt_options);
                  var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);
                  if (projection) {
                    object["geometry"]["spatialReference"] = /** @type {EsriJSONSpatialReferenceWkid} */
                    {
                      wkid: Number(proj_get(projection).getCode().split(":").pop())
                    };
                  }
                  delete properties[feature.getGeometryName()];
                }
                if (!Object(ol_obj[
                  "d"
                  /* isEmpty */
                ])(properties)) {
                  object["attributes"] = properties;
                } else {
                  object["attributes"] = {};
                }
                return object;
              };
              EsriJSON.prototype.writeFeaturesObject = function(features, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var objects = [];
                for (var i = 0, ii = features.length; i < ii; ++i) {
                  objects.push(this.writeFeatureObject(features[i], opt_options));
                }
                return {
                  "features": objects
                };
              };
              return EsriJSON;
            }(format_JSONFeature)
          );
          function readGeometry(object, opt_options) {
            var _a, _b;
            if (!object) {
              return null;
            }
            var type;
            if (typeof object["x"] === "number" && typeof object["y"] === "number") {
              type = geom_GeometryType.POINT;
            } else if (object["points"]) {
              type = geom_GeometryType.MULTI_POINT;
            } else if (object["paths"]) {
              var esriJSONPolyline = (
                /** @type {EsriJSONPolyline} */
                object
              );
              if (esriJSONPolyline.paths.length === 1) {
                type = geom_GeometryType.LINE_STRING;
              } else {
                type = geom_GeometryType.MULTI_LINE_STRING;
              }
            } else if (object["rings"]) {
              var esriJSONPolygon = (
                /** @type {EsriJSONPolygon} */
                object
              );
              var layout = getGeometryLayout(esriJSONPolygon);
              var rings = convertRings(esriJSONPolygon.rings, layout);
              if (rings.length === 1) {
                type = geom_GeometryType.POLYGON;
                object = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, object, (_a = {}, _a["rings"] = rings[0], _a));
              } else {
                type = geom_GeometryType.MULTI_POLYGON;
                object = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, object, (_b = {}, _b["rings"] = rings, _b));
              }
            }
            var geometryReader = GEOMETRY_READERS[type];
            return transformGeometryWithOptions(geometryReader(object), false, opt_options);
          }
          function convertRings(rings, layout) {
            var flatRing = [];
            var outerRings = [];
            var holes = [];
            var i, ii;
            for (i = 0, ii = rings.length; i < ii; ++i) {
              flatRing.length = 0;
              deflateCoordinates(flatRing, 0, rings[i], layout.length);
              var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
              if (clockwise) {
                outerRings.push([rings[i]]);
              } else {
                holes.push(rings[i]);
              }
            }
            while (holes.length) {
              var hole = holes.shift();
              var matched = false;
              for (i = outerRings.length - 1; i >= 0; i--) {
                var outerRing = outerRings[i][0];
                var containsHole = containsExtent(new geom_LinearRing(outerRing).getExtent(), new geom_LinearRing(hole).getExtent());
                if (containsHole) {
                  outerRings[i].push(hole);
                  matched = true;
                  break;
                }
              }
              if (!matched) {
                outerRings.push([hole.reverse()]);
              }
            }
            return outerRings;
          }
          function readPointGeometry(object) {
            var point;
            if (object.m !== void 0 && object.z !== void 0) {
              point = new geom_Point([object.x, object.y, object.z, object.m], GeometryLayout.XYZM);
            } else if (object.z !== void 0) {
              point = new geom_Point([object.x, object.y, object.z], GeometryLayout.XYZ);
            } else if (object.m !== void 0) {
              point = new geom_Point([object.x, object.y, object.m], GeometryLayout.XYM);
            } else {
              point = new geom_Point([object.x, object.y]);
            }
            return point;
          }
          function readLineStringGeometry(object) {
            var layout = getGeometryLayout(object);
            return new geom_LineString(object.paths[0], layout);
          }
          function readMultiLineStringGeometry(object) {
            var layout = getGeometryLayout(object);
            return new geom_MultiLineString(object.paths, layout);
          }
          function getGeometryLayout(object) {
            var layout = GeometryLayout.XY;
            if (object.hasZ === true && object.hasM === true) {
              layout = GeometryLayout.XYZM;
            } else if (object.hasZ === true) {
              layout = GeometryLayout.XYZ;
            } else if (object.hasM === true) {
              layout = GeometryLayout.XYM;
            }
            return layout;
          }
          function readMultiPointGeometry(object) {
            var layout = getGeometryLayout(object);
            return new geom_MultiPoint(object.points, layout);
          }
          function readMultiPolygonGeometry(object) {
            var layout = getGeometryLayout(object);
            return new geom_MultiPolygon(object.rings, layout);
          }
          function readPolygonGeometry(object) {
            var layout = getGeometryLayout(object);
            return new geom_Polygon(object.rings, layout);
          }
          function writePointGeometry(geometry, opt_options) {
            var coordinates = geometry.getCoordinates();
            var esriJSON;
            var layout = geometry.getLayout();
            if (layout === GeometryLayout.XYZ) {
              esriJSON = {
                x: coordinates[0],
                y: coordinates[1],
                z: coordinates[2]
              };
            } else if (layout === GeometryLayout.XYM) {
              esriJSON = {
                x: coordinates[0],
                y: coordinates[1],
                m: coordinates[2]
              };
            } else if (layout === GeometryLayout.XYZM) {
              esriJSON = {
                x: coordinates[0],
                y: coordinates[1],
                z: coordinates[2],
                m: coordinates[3]
              };
            } else if (layout === GeometryLayout.XY) {
              esriJSON = {
                x: coordinates[0],
                y: coordinates[1]
              };
            } else {
              assert2(false, 34);
            }
            return esriJSON;
          }
          function getHasZM(geometry) {
            var layout = geometry.getLayout();
            return {
              hasZ: layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM,
              hasM: layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM
            };
          }
          function writeLineStringGeometry(lineString, opt_options) {
            var hasZM = getHasZM(lineString);
            return {
              hasZ: hasZM.hasZ,
              hasM: hasZM.hasM,
              paths: [
                /** @type {Array<EsriJSONPosition>} */
                lineString.getCoordinates()
              ]
            };
          }
          function writePolygonGeometry(polygon, opt_options) {
            var hasZM = getHasZM(polygon);
            return {
              hasZ: hasZM.hasZ,
              hasM: hasZM.hasM,
              rings: (
                /** @type {Array<Array<EsriJSONPosition>>} */
                polygon.getCoordinates(false)
              )
            };
          }
          function writeMultiLineStringGeometry(multiLineString, opt_options) {
            var hasZM = getHasZM(multiLineString);
            return {
              hasZ: hasZM.hasZ,
              hasM: hasZM.hasM,
              paths: (
                /** @type {Array<Array<EsriJSONPosition>>} */
                multiLineString.getCoordinates()
              )
            };
          }
          function writeMultiPointGeometry(multiPoint, opt_options) {
            var hasZM = getHasZM(multiPoint);
            return {
              hasZ: hasZM.hasZ,
              hasM: hasZM.hasM,
              points: (
                /** @type {Array<EsriJSONPosition>} */
                multiPoint.getCoordinates()
              )
            };
          }
          function writeMultiPolygonGeometry(geometry, opt_options) {
            var hasZM = getHasZM(geometry);
            var coordinates = geometry.getCoordinates(false);
            var output = [];
            for (var i = 0; i < coordinates.length; i++) {
              for (var x = coordinates[i].length - 1; x >= 0; x--) {
                output.push(coordinates[i][x]);
              }
            }
            return {
              hasZ: hasZM.hasZ,
              hasM: hasZM.hasM,
              rings: (
                /** @type {Array<Array<EsriJSONPosition>>} */
                output
              )
            };
          }
          function writeGeometry(geometry, opt_options) {
            var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
            return geometryWriter(transformGeometryWithOptions(geometry, true, opt_options), opt_options);
          }
          var format_EsriJSON = EsriJSON_EsriJSON;
          var GeoJSON_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GeoJSON_GeoJSON = (
            /** @class */
            function(_super) {
              GeoJSON_extends(GeoJSON, _super);
              function GeoJSON(opt_options) {
                var _this = this;
                var options = opt_options ? opt_options : {};
                _this = _super.call(this) || this;
                _this.dataProjection = proj_get(options.dataProjection ? options.dataProjection : "EPSG:4326");
                if (options.featureProjection) {
                  _this.defaultFeatureProjection = proj_get(options.featureProjection);
                }
                _this.geometryName_ = options.geometryName;
                _this.extractGeometryName_ = options.extractGeometryName;
                return _this;
              }
              GeoJSON.prototype.readFeatureFromObject = function(object, opt_options) {
                var geoJSONFeature = null;
                if (object["type"] === "Feature") {
                  geoJSONFeature = /** @type {GeoJSONFeature} */
                  object;
                } else {
                  geoJSONFeature = {
                    "type": "Feature",
                    "geometry": (
                      /** @type {GeoJSONGeometry} */
                      object
                    ),
                    "properties": null
                  };
                }
                var geometry = GeoJSON_readGeometry(geoJSONFeature["geometry"], opt_options);
                var feature = new ol_Feature();
                if (this.geometryName_) {
                  feature.setGeometryName(this.geometryName_);
                } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
                  feature.setGeometryName(geoJSONFeature["geometry_name"]);
                }
                feature.setGeometry(geometry);
                if ("id" in geoJSONFeature) {
                  feature.setId(geoJSONFeature["id"]);
                }
                if (geoJSONFeature["properties"]) {
                  feature.setProperties(geoJSONFeature["properties"], true);
                }
                return feature;
              };
              GeoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
                var geoJSONObject = (
                  /** @type {GeoJSONObject} */
                  object
                );
                var features = null;
                if (geoJSONObject["type"] === "FeatureCollection") {
                  var geoJSONFeatureCollection = (
                    /** @type {GeoJSONFeatureCollection} */
                    object
                  );
                  features = [];
                  var geoJSONFeatures = geoJSONFeatureCollection["features"];
                  for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                    features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
                  }
                } else {
                  features = [this.readFeatureFromObject(object, opt_options)];
                }
                return features;
              };
              GeoJSON.prototype.readGeometryFromObject = function(object, opt_options) {
                return GeoJSON_readGeometry(object, opt_options);
              };
              GeoJSON.prototype.readProjectionFromObject = function(object) {
                var crs = object["crs"];
                var projection;
                if (crs) {
                  if (crs["type"] == "name") {
                    projection = proj_get(crs["properties"]["name"]);
                  } else if (crs["type"] === "EPSG") {
                    projection = proj_get("EPSG:" + crs["properties"]["code"]);
                  } else {
                    assert2(false, 36);
                  }
                } else {
                  projection = this.dataProjection;
                }
                return (
                  /** @type {import("../proj/Projection.js").default} */
                  projection
                );
              };
              GeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var object = {
                  "type": "Feature",
                  geometry: null,
                  properties: null
                };
                var id = feature.getId();
                if (id !== void 0) {
                  object.id = id;
                }
                if (!feature.hasProperties()) {
                  return object;
                }
                var properties = feature.getProperties();
                var geometry = feature.getGeometry();
                if (geometry) {
                  object.geometry = GeoJSON_writeGeometry(geometry, opt_options);
                  delete properties[feature.getGeometryName()];
                }
                if (!Object(ol_obj[
                  "d"
                  /* isEmpty */
                ])(properties)) {
                  object.properties = properties;
                }
                return object;
              };
              GeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var objects = [];
                for (var i = 0, ii = features.length; i < ii; ++i) {
                  objects.push(this.writeFeatureObject(features[i], opt_options));
                }
                return {
                  type: "FeatureCollection",
                  features: objects
                };
              };
              GeoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
                return GeoJSON_writeGeometry(geometry, this.adaptOptions(opt_options));
              };
              return GeoJSON;
            }(format_JSONFeature)
          );
          function GeoJSON_readGeometry(object, opt_options) {
            if (!object) {
              return null;
            }
            var geometry;
            switch (object["type"]) {
              case geom_GeometryType.POINT: {
                geometry = GeoJSON_readPointGeometry(
                  /** @type {GeoJSONPoint} */
                  object
                );
                break;
              }
              case geom_GeometryType.LINE_STRING: {
                geometry = GeoJSON_readLineStringGeometry(
                  /** @type {GeoJSONLineString} */
                  object
                );
                break;
              }
              case geom_GeometryType.POLYGON: {
                geometry = GeoJSON_readPolygonGeometry(
                  /** @type {GeoJSONPolygon} */
                  object
                );
                break;
              }
              case geom_GeometryType.MULTI_POINT: {
                geometry = GeoJSON_readMultiPointGeometry(
                  /** @type {GeoJSONMultiPoint} */
                  object
                );
                break;
              }
              case geom_GeometryType.MULTI_LINE_STRING: {
                geometry = GeoJSON_readMultiLineStringGeometry(
                  /** @type {GeoJSONMultiLineString} */
                  object
                );
                break;
              }
              case geom_GeometryType.MULTI_POLYGON: {
                geometry = GeoJSON_readMultiPolygonGeometry(
                  /** @type {GeoJSONMultiPolygon} */
                  object
                );
                break;
              }
              case geom_GeometryType.GEOMETRY_COLLECTION: {
                geometry = readGeometryCollectionGeometry(
                  /** @type {GeoJSONGeometryCollection} */
                  object
                );
                break;
              }
              default: {
                throw new Error("Unsupported GeoJSON type: " + object.type);
              }
            }
            return transformGeometryWithOptions(geometry, false, opt_options);
          }
          function readGeometryCollectionGeometry(object, opt_options) {
            var geometries = object["geometries"].map(
              /**
               * @param {GeoJSONGeometry} geometry Geometry.
               * @return {import("../geom/Geometry.js").default} geometry Geometry.
               */
              function(geometry) {
                return GeoJSON_readGeometry(geometry, opt_options);
              }
            );
            return new geom_GeometryCollection(geometries);
          }
          function GeoJSON_readPointGeometry(object) {
            return new geom_Point(object["coordinates"]);
          }
          function GeoJSON_readLineStringGeometry(object) {
            return new geom_LineString(object["coordinates"]);
          }
          function GeoJSON_readMultiLineStringGeometry(object) {
            return new geom_MultiLineString(object["coordinates"]);
          }
          function GeoJSON_readMultiPointGeometry(object) {
            return new geom_MultiPoint(object["coordinates"]);
          }
          function GeoJSON_readMultiPolygonGeometry(object) {
            return new geom_MultiPolygon(object["coordinates"]);
          }
          function GeoJSON_readPolygonGeometry(object) {
            return new geom_Polygon(object["coordinates"]);
          }
          function GeoJSON_writeGeometry(geometry, opt_options) {
            geometry = transformGeometryWithOptions(geometry, true, opt_options);
            var type = geometry.getType();
            var geoJSON;
            switch (type) {
              case geom_GeometryType.POINT: {
                geoJSON = GeoJSON_writePointGeometry(
                  /** @type {Point} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.LINE_STRING: {
                geoJSON = GeoJSON_writeLineStringGeometry(
                  /** @type {LineString} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.POLYGON: {
                geoJSON = GeoJSON_writePolygonGeometry(
                  /** @type {Polygon} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.MULTI_POINT: {
                geoJSON = GeoJSON_writeMultiPointGeometry(
                  /** @type {MultiPoint} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.MULTI_LINE_STRING: {
                geoJSON = GeoJSON_writeMultiLineStringGeometry(
                  /** @type {MultiLineString} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.MULTI_POLYGON: {
                geoJSON = GeoJSON_writeMultiPolygonGeometry(
                  /** @type {MultiPolygon} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.GEOMETRY_COLLECTION: {
                geoJSON = writeGeometryCollectionGeometry(
                  /** @type {GeometryCollection} */
                  geometry,
                  opt_options
                );
                break;
              }
              case geom_GeometryType.CIRCLE: {
                geoJSON = {
                  type: "GeometryCollection",
                  geometries: []
                };
                break;
              }
              default: {
                throw new Error("Unsupported geometry type: " + type);
              }
            }
            return geoJSON;
          }
          function writeGeometryCollectionGeometry(geometry, opt_options) {
            var geometries = geometry.getGeometriesArray().map(function(geometry2) {
              var options = Object(ol_obj[
                "a"
                /* assign */
              ])({}, opt_options);
              delete options.featureProjection;
              return GeoJSON_writeGeometry(geometry2, options);
            });
            return {
              type: "GeometryCollection",
              geometries
            };
          }
          function GeoJSON_writeLineStringGeometry(geometry, opt_options) {
            return {
              type: "LineString",
              coordinates: geometry.getCoordinates()
            };
          }
          function GeoJSON_writeMultiLineStringGeometry(geometry, opt_options) {
            return {
              type: "MultiLineString",
              coordinates: geometry.getCoordinates()
            };
          }
          function GeoJSON_writeMultiPointGeometry(geometry, opt_options) {
            return {
              type: "MultiPoint",
              coordinates: geometry.getCoordinates()
            };
          }
          function GeoJSON_writeMultiPolygonGeometry(geometry, opt_options) {
            var right;
            if (opt_options) {
              right = opt_options.rightHanded;
            }
            return {
              type: "MultiPolygon",
              coordinates: geometry.getCoordinates(right)
            };
          }
          function GeoJSON_writePointGeometry(geometry, opt_options) {
            return {
              type: "Point",
              coordinates: geometry.getCoordinates()
            };
          }
          function GeoJSON_writePolygonGeometry(geometry, opt_options) {
            var right;
            if (opt_options) {
              right = opt_options.rightHanded;
            }
            return {
              type: "Polygon",
              coordinates: geometry.getCoordinates(right)
            };
          }
          var format_GeoJSON = GeoJSON_GeoJSON;
          var XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
          function createElementNS(namespaceURI, qualifiedName) {
            return getDocument().createElementNS(namespaceURI, qualifiedName);
          }
          function getAllTextContent(node, normalizeWhitespace) {
            return getAllTextContent_(node, normalizeWhitespace, []).join("");
          }
          function getAllTextContent_(node, normalizeWhitespace, accumulator) {
            if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
              if (normalizeWhitespace) {
                accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
              } else {
                accumulator.push(node.nodeValue);
              }
            } else {
              var n = void 0;
              for (n = node.firstChild; n; n = n.nextSibling) {
                getAllTextContent_(n, normalizeWhitespace, accumulator);
              }
            }
            return accumulator;
          }
          function isDocument(object) {
            return "documentElement" in object;
          }
          function getAttributeNS(node, namespaceURI, name) {
            return node.getAttributeNS(namespaceURI, name) || "";
          }
          function parse2(xml) {
            return new DOMParser().parseFromString(xml, "application/xml");
          }
          function makeArrayExtender(valueReader, opt_this) {
            return (
              /**
               * @param {Node} node Node.
               * @param {Array<*>} objectStack Object stack.
               */
              function(node, objectStack) {
                var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
                if (value !== void 0) {
                  var array = (
                    /** @type {Array<*>} */
                    objectStack[objectStack.length - 1]
                  );
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(array, value);
                }
              }
            );
          }
          function makeArrayPusher(valueReader, opt_this) {
            return (
              /**
               * @param {Element} node Node.
               * @param {Array<*>} objectStack Object stack.
               */
              function(node, objectStack) {
                var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
                if (value !== void 0) {
                  var array = (
                    /** @type {Array<*>} */
                    objectStack[objectStack.length - 1]
                  );
                  array.push(value);
                }
              }
            );
          }
          function makeReplacer(valueReader, opt_this) {
            return (
              /**
               * @param {Node} node Node.
               * @param {Array<*>} objectStack Object stack.
               */
              function(node, objectStack) {
                var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
                if (value !== void 0) {
                  objectStack[objectStack.length - 1] = value;
                }
              }
            );
          }
          function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
            return (
              /**
               * @param {Element} node Node.
               * @param {Array<*>} objectStack Object stack.
               */
              function(node, objectStack) {
                var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
                if (value !== void 0) {
                  var object = (
                    /** @type {!Object} */
                    objectStack[objectStack.length - 1]
                  );
                  var property = opt_property !== void 0 ? opt_property : node.localName;
                  var array = void 0;
                  if (property in object) {
                    array = object[property];
                  } else {
                    array = [];
                    object[property] = array;
                  }
                  array.push(value);
                }
              }
            );
          }
          function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
            return (
              /**
               * @param {Element} node Node.
               * @param {Array<*>} objectStack Object stack.
               */
              function(node, objectStack) {
                var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
                if (value !== void 0) {
                  var object = (
                    /** @type {!Object} */
                    objectStack[objectStack.length - 1]
                  );
                  var property = opt_property !== void 0 ? opt_property : node.localName;
                  object[property] = value;
                }
              }
            );
          }
          function makeChildAppender(nodeWriter, opt_this) {
            return function(node, value, objectStack) {
              nodeWriter.call(opt_this !== void 0 ? opt_this : this, node, value, objectStack);
              var parent = (
                /** @type {NodeStackItem} */
                objectStack[objectStack.length - 1]
              );
              var parentNode = parent.node;
              parentNode.appendChild(node);
            };
          }
          function makeArraySerializer(nodeWriter, opt_this) {
            var serializersNS, nodeFactory;
            return function(node, value, objectStack) {
              if (serializersNS === void 0) {
                serializersNS = {};
                var serializers = {};
                serializers[node.localName] = nodeWriter;
                serializersNS[node.namespaceURI] = serializers;
                nodeFactory = makeSimpleNodeFactory(node.localName);
              }
              serialize(serializersNS, nodeFactory, value, objectStack);
            };
          }
          function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
            var fixedNodeName = opt_nodeName;
            return (
              /**
               * @param {*} value Value.
               * @param {Array<*>} objectStack Object stack.
               * @param {string} [opt_nodeName] Node name.
               * @return {Node} Node.
               */
              function(value, objectStack, opt_nodeName2) {
                var context = (
                  /** @type {NodeStackItem} */
                  objectStack[objectStack.length - 1]
                );
                var node = context.node;
                var nodeName = fixedNodeName;
                if (nodeName === void 0) {
                  nodeName = opt_nodeName2;
                }
                var namespaceURI = opt_namespaceURI !== void 0 ? opt_namespaceURI : node.namespaceURI;
                return createElementNS(
                  namespaceURI,
                  /** @type {string} */
                  nodeName
                );
              }
            );
          }
          var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
          function makeSequence(object, orderedKeys) {
            var length = orderedKeys.length;
            var sequence = new Array(length);
            for (var i = 0; i < length; ++i) {
              sequence[i] = object[orderedKeys[i]];
            }
            return sequence;
          }
          function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
            var structureNS = opt_structureNS !== void 0 ? opt_structureNS : {};
            var i, ii;
            for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
              structureNS[namespaceURIs[i]] = structure;
            }
            return structureNS;
          }
          function parseNode(parsersNS, node, objectStack, opt_this) {
            var n;
            for (n = node.firstElementChild; n; n = n.nextElementSibling) {
              var parsers = parsersNS[n.namespaceURI];
              if (parsers !== void 0) {
                var parser = parsers[n.localName];
                if (parser !== void 0) {
                  parser.call(opt_this, n, objectStack);
                }
              }
            }
          }
          function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
            objectStack.push(object);
            parseNode(parsersNS, node, objectStack, opt_this);
            return (
              /** @type {T} */
              objectStack.pop()
            );
          }
          function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
            var length = (opt_keys !== void 0 ? opt_keys : values).length;
            var value, node;
            for (var i = 0; i < length; ++i) {
              value = values[i];
              if (value !== void 0) {
                node = nodeFactory.call(opt_this !== void 0 ? opt_this : this, value, objectStack, opt_keys !== void 0 ? opt_keys[i] : void 0);
                if (node !== void 0) {
                  serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
                }
              }
            }
          }
          function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
            objectStack.push(object);
            serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
            return (
              /** @type {O|undefined} */
              objectStack.pop()
            );
          }
          var xmlSerializer_ = void 0;
          function registerXMLSerializer(xmlSerializer) {
            xmlSerializer_ = xmlSerializer;
          }
          function getXMLSerializer() {
            if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
              xmlSerializer_ = new XMLSerializer();
            }
            return xmlSerializer_;
          }
          var document_ = void 0;
          function registerDocument(document2) {
            document_ = document2;
          }
          function getDocument() {
            if (document_ === void 0 && typeof document !== "undefined") {
              document_ = document.implementation.createDocument("", "", null);
            }
            return document_;
          }
          var XMLFeature_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var XMLFeature_XMLFeature = (
            /** @class */
            function(_super) {
              XMLFeature_extends(XMLFeature, _super);
              function XMLFeature() {
                var _this = _super.call(this) || this;
                _this.xmlSerializer_ = getXMLSerializer();
                return _this;
              }
              XMLFeature.prototype.getType = function() {
                return FormatType.XML;
              };
              XMLFeature.prototype.readFeature = function(source, opt_options) {
                if (!source) {
                  return null;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readFeatureFromDocument(doc, opt_options);
                } else if (isDocument(source)) {
                  return this.readFeatureFromDocument(
                    /** @type {Document} */
                    source,
                    opt_options
                  );
                } else {
                  return this.readFeatureFromNode(
                    /** @type {Element} */
                    source,
                    opt_options
                  );
                }
              };
              XMLFeature.prototype.readFeatureFromDocument = function(doc, opt_options) {
                var features = this.readFeaturesFromDocument(doc, opt_options);
                if (features.length > 0) {
                  return features[0];
                } else {
                  return null;
                }
              };
              XMLFeature.prototype.readFeatureFromNode = function(node, opt_options) {
                return null;
              };
              XMLFeature.prototype.readFeatures = function(source, opt_options) {
                if (!source) {
                  return [];
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readFeaturesFromDocument(doc, opt_options);
                } else if (isDocument(source)) {
                  return this.readFeaturesFromDocument(
                    /** @type {Document} */
                    source,
                    opt_options
                  );
                } else {
                  return this.readFeaturesFromNode(
                    /** @type {Element} */
                    source,
                    opt_options
                  );
                }
              };
              XMLFeature.prototype.readFeaturesFromDocument = function(doc, opt_options) {
                var features = [];
                for (var n = doc.firstChild; n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(features, this.readFeaturesFromNode(
                      /** @type {Element} */
                      n,
                      opt_options
                    ));
                  }
                }
                return features;
              };
              XMLFeature.prototype.readFeaturesFromNode = function(node, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              XMLFeature.prototype.readGeometry = function(source, opt_options) {
                if (!source) {
                  return null;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readGeometryFromDocument(doc, opt_options);
                } else if (isDocument(source)) {
                  return this.readGeometryFromDocument(
                    /** @type {Document} */
                    source,
                    opt_options
                  );
                } else {
                  return this.readGeometryFromNode(
                    /** @type {Element} */
                    source,
                    opt_options
                  );
                }
              };
              XMLFeature.prototype.readGeometryFromDocument = function(doc, opt_options) {
                return null;
              };
              XMLFeature.prototype.readGeometryFromNode = function(node, opt_options) {
                return null;
              };
              XMLFeature.prototype.readProjection = function(source) {
                if (!source) {
                  return null;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readProjectionFromDocument(doc);
                } else if (isDocument(source)) {
                  return this.readProjectionFromDocument(
                    /** @type {Document} */
                    source
                  );
                } else {
                  return this.readProjectionFromNode(
                    /** @type {Element} */
                    source
                  );
                }
              };
              XMLFeature.prototype.readProjectionFromDocument = function(doc) {
                return this.dataProjection;
              };
              XMLFeature.prototype.readProjectionFromNode = function(node) {
                return this.dataProjection;
              };
              XMLFeature.prototype.writeFeature = function(feature, opt_options) {
                var node = this.writeFeatureNode(feature, opt_options);
                return this.xmlSerializer_.serializeToString(node);
              };
              XMLFeature.prototype.writeFeatureNode = function(feature, opt_options) {
                return null;
              };
              XMLFeature.prototype.writeFeatures = function(features, opt_options) {
                var node = this.writeFeaturesNode(features, opt_options);
                return this.xmlSerializer_.serializeToString(node);
              };
              XMLFeature.prototype.writeFeaturesNode = function(features, opt_options) {
                return null;
              };
              XMLFeature.prototype.writeGeometry = function(geometry, opt_options) {
                var node = this.writeGeometryNode(geometry, opt_options);
                return this.xmlSerializer_.serializeToString(node);
              };
              XMLFeature.prototype.writeGeometryNode = function(geometry, opt_options) {
                return null;
              };
              return XMLFeature;
            }(format_Feature)
          );
          var format_XMLFeature = XMLFeature_XMLFeature;
          var GMLBase_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GMLNS = "http://www.opengis.net/gml";
          var ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;
          var GMLBase_GMLBase = (
            /** @class */
            function(_super) {
              GMLBase_extends(GMLBase, _super);
              function GMLBase(opt_options) {
                var _this = _super.call(this) || this;
                var options = (
                  /** @type {Options} */
                  opt_options ? opt_options : {}
                );
                _this.featureType = options.featureType;
                _this.featureNS = options.featureNS;
                _this.srsName = options.srsName;
                _this.schemaLocation = "";
                _this.FEATURE_COLLECTION_PARSERS = {};
                _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {
                  "featureMember": makeArrayPusher(_this.readFeaturesInternal),
                  "featureMembers": makeReplacer(_this.readFeaturesInternal)
                };
                return _this;
              }
              GMLBase.prototype.readFeaturesInternal = function(node, objectStack) {
                var localName = node.localName;
                var features = null;
                if (localName == "FeatureCollection") {
                  features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
                } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
                  var context = objectStack[0];
                  var featureType = context["featureType"];
                  var featureNS = context["featureNS"];
                  var prefix = "p";
                  var defaultPrefix = "p0";
                  if (!featureType && node.childNodes) {
                    featureType = [], featureNS = {};
                    for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {
                      var child = node.childNodes[i];
                      if (child.nodeType === 1) {
                        var ft = child.nodeName.split(":").pop();
                        if (featureType.indexOf(ft) === -1) {
                          var key = "";
                          var count = 0;
                          var uri = child.namespaceURI;
                          for (var candidate in featureNS) {
                            if (featureNS[candidate] === uri) {
                              key = candidate;
                              break;
                            }
                            ++count;
                          }
                          if (!key) {
                            key = prefix + count;
                            featureNS[key] = uri;
                          }
                          featureType.push(key + ":" + ft);
                        }
                      }
                    }
                    if (localName != "featureMember") {
                      context["featureType"] = featureType;
                      context["featureNS"] = featureNS;
                    }
                  }
                  if (typeof featureNS === "string") {
                    var ns = featureNS;
                    featureNS = {};
                    featureNS[defaultPrefix] = ns;
                  }
                  var parsersNS = {};
                  var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
                  for (var p in featureNS) {
                    var parsers = {};
                    for (var i = 0, ii = featureTypes.length; i < ii; ++i) {
                      var featurePrefix = featureTypes[i].indexOf(":") === -1 ? defaultPrefix : featureTypes[i].split(":")[0];
                      if (featurePrefix === p) {
                        parsers[featureTypes[i].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
                      }
                    }
                    parsersNS[featureNS[p]] = parsers;
                  }
                  if (localName == "featureMember" || localName == "member") {
                    features = pushParseAndPop(void 0, parsersNS, node, objectStack);
                  } else {
                    features = pushParseAndPop([], parsersNS, node, objectStack);
                  }
                }
                if (features === null) {
                  features = [];
                }
                return features;
              };
              GMLBase.prototype.readGeometryElement = function(node, objectStack) {
                var context = (
                  /** @type {Object} */
                  objectStack[0]
                );
                context["srsName"] = node.firstElementChild.getAttribute("srsName");
                context["srsDimension"] = node.firstElementChild.getAttribute("srsDimension");
                var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);
                if (geometry) {
                  if (Array.isArray(geometry)) {
                    return transformExtentWithOptions(
                      /** @type {import("../extent.js").Extent} */
                      geometry,
                      context
                    );
                  } else {
                    return transformGeometryWithOptions(
                      /** @type {import("../geom/Geometry.js").default} */
                      geometry,
                      false,
                      context
                    );
                  }
                } else {
                  return void 0;
                }
              };
              GMLBase.prototype.readFeatureElementInternal = function(node, objectStack, asFeature) {
                var geometryName;
                var values = {};
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  var value = void 0;
                  var localName = n.localName;
                  if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
                    value = getAllTextContent(n, false);
                    if (ONLY_WHITESPACE_RE.test(value)) {
                      value = void 0;
                    }
                  } else {
                    if (asFeature) {
                      value = this.readGeometryElement(n, objectStack);
                    }
                    if (!value) {
                      value = this.readFeatureElementInternal(n, objectStack, false);
                    } else if (localName !== "boundedBy") {
                      geometryName = localName;
                    }
                  }
                  if (values[localName]) {
                    if (!(values[localName] instanceof Array)) {
                      values[localName] = [values[localName]];
                    }
                    values[localName].push(value);
                  } else {
                    values[localName] = value;
                  }
                  var len = n.attributes.length;
                  if (len > 0) {
                    values[localName] = { _content_: values[localName] };
                    for (var i = 0; i < len; i++) {
                      var attName = n.attributes[i].name;
                      values[localName][attName] = n.attributes[i].value;
                    }
                  }
                }
                if (!asFeature) {
                  return values;
                } else {
                  var feature = new ol_Feature(values);
                  if (geometryName) {
                    feature.setGeometryName(geometryName);
                  }
                  var fid = node.getAttribute("fid") || getAttributeNS(node, this.namespace, "id");
                  if (fid) {
                    feature.setId(fid);
                  }
                  return feature;
                }
              };
              GMLBase.prototype.readFeatureElement = function(node, objectStack) {
                return this.readFeatureElementInternal(node, objectStack, true);
              };
              GMLBase.prototype.readPoint = function(node, objectStack) {
                var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
                if (flatCoordinates) {
                  return new geom_Point(flatCoordinates, GeometryLayout.XYZ);
                }
              };
              GMLBase.prototype.readMultiPoint = function(node, objectStack) {
                var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);
                if (coordinates) {
                  return new geom_MultiPoint(coordinates);
                } else {
                  return void 0;
                }
              };
              GMLBase.prototype.readMultiLineString = function(node, objectStack) {
                var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);
                if (lineStrings) {
                  return new geom_MultiLineString(lineStrings);
                }
              };
              GMLBase.prototype.readMultiPolygon = function(node, objectStack) {
                var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);
                if (polygons) {
                  return new geom_MultiPolygon(polygons);
                }
              };
              GMLBase.prototype.pointMemberParser = function(node, objectStack) {
                parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);
              };
              GMLBase.prototype.lineStringMemberParser = function(node, objectStack) {
                parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
              };
              GMLBase.prototype.polygonMemberParser = function(node, objectStack) {
                parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
              };
              GMLBase.prototype.readLineString = function(node, objectStack) {
                var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
                if (flatCoordinates) {
                  var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
                  return lineString;
                } else {
                  return void 0;
                }
              };
              GMLBase.prototype.readFlatLinearRing = function(node, objectStack) {
                var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
                if (ring) {
                  return ring;
                } else {
                  return void 0;
                }
              };
              GMLBase.prototype.readLinearRing = function(node, objectStack) {
                var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
                if (flatCoordinates) {
                  return new geom_LinearRing(flatCoordinates, GeometryLayout.XYZ);
                }
              };
              GMLBase.prototype.readPolygon = function(node, objectStack) {
                var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
                if (flatLinearRings && flatLinearRings[0]) {
                  var flatCoordinates = flatLinearRings[0];
                  var ends = [flatCoordinates.length];
                  var i = void 0, ii = void 0;
                  for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(flatCoordinates, flatLinearRings[i]);
                    ends.push(flatCoordinates.length);
                  }
                  return new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
                } else {
                  return void 0;
                }
              };
              GMLBase.prototype.readFlatCoordinatesFromNode = function(node, objectStack) {
                return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
              };
              GMLBase.prototype.readGeometryFromNode = function(node, opt_options) {
                var geometry = this.readGeometryElement(node, [
                  this.getReadOptions(node, opt_options ? opt_options : {})
                ]);
                return geometry ? geometry : null;
              };
              GMLBase.prototype.readFeaturesFromNode = function(node, opt_options) {
                var options = {
                  featureType: this.featureType,
                  featureNS: this.featureNS
                };
                if (opt_options) {
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(options, this.getReadOptions(node, opt_options));
                }
                var features = this.readFeaturesInternal(node, [options]);
                return features || [];
              };
              GMLBase.prototype.readProjectionFromNode = function(node) {
                return proj_get(this.srsName ? this.srsName : node.firstElementChild.getAttribute("srsName"));
              };
              return GMLBase;
            }(format_XMLFeature)
          );
          GMLBase_GMLBase.prototype.namespace = GMLNS;
          GMLBase_GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
            "http://www.opengis.net/gml": {}
          };
          GMLBase_GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
            "http://www.opengis.net/gml": {}
          };
          GMLBase_GMLBase.prototype.GEOMETRY_PARSERS = {
            "http://www.opengis.net/gml": {}
          };
          GMLBase_GMLBase.prototype.MULTIPOINT_PARSERS = {
            "http://www.opengis.net/gml": {
              "pointMember": makeArrayPusher(GMLBase_GMLBase.prototype.pointMemberParser),
              "pointMembers": makeArrayPusher(GMLBase_GMLBase.prototype.pointMemberParser)
            }
          };
          GMLBase_GMLBase.prototype.MULTILINESTRING_PARSERS = {
            "http://www.opengis.net/gml": {
              "lineStringMember": makeArrayPusher(GMLBase_GMLBase.prototype.lineStringMemberParser),
              "lineStringMembers": makeArrayPusher(GMLBase_GMLBase.prototype.lineStringMemberParser)
            }
          };
          GMLBase_GMLBase.prototype.MULTIPOLYGON_PARSERS = {
            "http://www.opengis.net/gml": {
              "polygonMember": makeArrayPusher(GMLBase_GMLBase.prototype.polygonMemberParser),
              "polygonMembers": makeArrayPusher(GMLBase_GMLBase.prototype.polygonMemberParser)
            }
          };
          GMLBase_GMLBase.prototype.POINTMEMBER_PARSERS = {
            "http://www.opengis.net/gml": {
              "Point": makeArrayPusher(GMLBase_GMLBase.prototype.readFlatCoordinatesFromNode)
            }
          };
          GMLBase_GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
            "http://www.opengis.net/gml": {
              "LineString": makeArrayPusher(GMLBase_GMLBase.prototype.readLineString)
            }
          };
          GMLBase_GMLBase.prototype.POLYGONMEMBER_PARSERS = {
            "http://www.opengis.net/gml": {
              "Polygon": makeArrayPusher(GMLBase_GMLBase.prototype.readPolygon)
            }
          };
          GMLBase_GMLBase.prototype.RING_PARSERS = {
            "http://www.opengis.net/gml": {
              "LinearRing": makeReplacer(GMLBase_GMLBase.prototype.readFlatLinearRing)
            }
          };
          var format_GMLBase = GMLBase_GMLBase;
          function readBoolean(node) {
            var s = getAllTextContent(node, false);
            return readBooleanString(s);
          }
          function readBooleanString(string) {
            var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
            if (m) {
              return m[1] !== void 0 || false;
            } else {
              return void 0;
            }
          }
          function readDateTime(node) {
            var s = getAllTextContent(node, false);
            var dateTime = Date.parse(s);
            return isNaN(dateTime) ? void 0 : dateTime / 1e3;
          }
          function readDecimal(node) {
            var s = getAllTextContent(node, false);
            return readDecimalString(s);
          }
          function readDecimalString(string) {
            var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
            if (m) {
              return parseFloat(m[1]);
            } else {
              return void 0;
            }
          }
          function readNonNegativeInteger(node) {
            var s = getAllTextContent(node, false);
            return readNonNegativeIntegerString(s);
          }
          function readNonNegativeIntegerString(string) {
            var m = /^\s*(\d+)\s*$/.exec(string);
            if (m) {
              return parseInt(m[1], 10);
            } else {
              return void 0;
            }
          }
          function readString(node) {
            return getAllTextContent(node, false).trim();
          }
          function writeBooleanTextNode(node, bool) {
            writeStringTextNode(node, bool ? "1" : "0");
          }
          function writeCDATASection(node, string) {
            node.appendChild(getDocument().createCDATASection(string));
          }
          function writeDateTimeTextNode(node, dateTime) {
            var date = new Date(dateTime * 1e3);
            var string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
            node.appendChild(getDocument().createTextNode(string));
          }
          function writeDecimalTextNode(node, decimal) {
            var string = decimal.toPrecision();
            node.appendChild(getDocument().createTextNode(string));
          }
          function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
            var string = nonNegativeInteger.toString();
            node.appendChild(getDocument().createTextNode(string));
          }
          function writeStringTextNode(node, string) {
            node.appendChild(getDocument().createTextNode(string));
          }
          var GML2_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var schemaLocation = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
          var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
            "MultiLineString": "lineStringMember",
            "MultiCurve": "curveMember",
            "MultiPolygon": "polygonMember",
            "MultiSurface": "surfaceMember"
          };
          var GML2_GML2 = (
            /** @class */
            function(_super) {
              GML2_extends(GML2, _super);
              function GML2(opt_options) {
                var _this = this;
                var options = (
                  /** @type {import("./GMLBase.js").Options} */
                  opt_options ? opt_options : {}
                );
                _this = _super.call(this, options) || this;
                _this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(_this.readFeaturesInternal);
                _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
                return _this;
              }
              GML2.prototype.readFlatCoordinates = function(node, objectStack) {
                var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
                var context = (
                  /** @type {import("../xml.js").NodeStackItem} */
                  objectStack[0]
                );
                var containerSrs = context["srsName"];
                var axisOrientation = "enu";
                if (containerSrs) {
                  var proj = proj_get(containerSrs);
                  if (proj) {
                    axisOrientation = proj.getAxisOrientation();
                  }
                }
                var coordsGroups = s.trim().split(/\s+/);
                var flatCoordinates = [];
                for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
                  var coords = coordsGroups[i].split(/,+/);
                  var x = parseFloat(coords[0]);
                  var y = parseFloat(coords[1]);
                  var z = coords.length === 3 ? parseFloat(coords[2]) : 0;
                  if (axisOrientation.substr(0, 2) === "en") {
                    flatCoordinates.push(x, y, z);
                  } else {
                    flatCoordinates.push(y, x, z);
                  }
                }
                return flatCoordinates;
              };
              GML2.prototype.readBox = function(node, objectStack) {
                var flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);
                return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
              };
              GML2.prototype.innerBoundaryIsParser = function(node, objectStack) {
                var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
                if (flatLinearRing) {
                  var flatLinearRings = (
                    /** @type {Array<Array<number>>} */
                    objectStack[objectStack.length - 1]
                  );
                  flatLinearRings.push(flatLinearRing);
                }
              };
              GML2.prototype.outerBoundaryIsParser = function(node, objectStack) {
                var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
                if (flatLinearRing) {
                  var flatLinearRings = (
                    /** @type {Array<Array<number>>} */
                    objectStack[objectStack.length - 1]
                  );
                  flatLinearRings[0] = flatLinearRing;
                }
              };
              GML2.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var context = objectStack[objectStack.length - 1];
                var multiSurface = context["multiSurface"];
                var surface = context["surface"];
                var multiCurve = context["multiCurve"];
                var nodeName;
                if (!Array.isArray(value)) {
                  nodeName = /** @type {import("../geom/Geometry.js").default} */
                  value.getType();
                  if (nodeName === "MultiPolygon" && multiSurface === true) {
                    nodeName = "MultiSurface";
                  } else if (nodeName === "Polygon" && surface === true) {
                    nodeName = "Surface";
                  } else if (nodeName === "MultiLineString" && multiCurve === true) {
                    nodeName = "MultiCurve";
                  }
                } else {
                  nodeName = "Envelope";
                }
                return createElementNS("http://www.opengis.net/gml", nodeName);
              };
              GML2.prototype.writeFeatureElement = function(node, feature, objectStack) {
                var fid = feature.getId();
                if (fid) {
                  node.setAttribute(
                    "fid",
                    /** @type {string} */
                    fid
                  );
                }
                var context = (
                  /** @type {Object} */
                  objectStack[objectStack.length - 1]
                );
                var featureNS = context["featureNS"];
                var geometryName = feature.getGeometryName();
                if (!context.serializers) {
                  context.serializers = {};
                  context.serializers[featureNS] = {};
                }
                var keys = [];
                var values = [];
                if (feature.hasProperties()) {
                  var properties = feature.getProperties();
                  for (var key in properties) {
                    var value = properties[key];
                    if (value !== null) {
                      keys.push(key);
                      values.push(value);
                      if (key == geometryName || typeof /** @type {?} */
                      value.getSimplifiedGeometry === "function") {
                        if (!(key in context.serializers[featureNS])) {
                          context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
                        }
                      } else {
                        if (!(key in context.serializers[featureNS])) {
                          context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
                        }
                      }
                    }
                  }
                }
                var item = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, context);
                item.node = node;
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  item,
                  context.serializers,
                  makeSimpleNodeFactory(void 0, featureNS),
                  values,
                  objectStack,
                  keys
                );
              };
              GML2.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (node.nodeName !== "LineStringSegment" && srsName) {
                  node.setAttribute("srsName", srsName);
                }
                if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
                  var coordinates = this.createCoordinatesNode_(node.namespaceURI);
                  node.appendChild(coordinates);
                  this.writeCoordinates_(coordinates, geometry, objectStack);
                } else if (node.nodeName === "Curve") {
                  var segments = createElementNS(node.namespaceURI, "segments");
                  node.appendChild(segments);
                  this.writeCurveSegments_(segments, geometry, objectStack);
                }
              };
              GML2.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
                var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
                if (child) {
                  node.appendChild(child);
                  this.writeCurveOrLineString(child, line, objectStack);
                }
              };
              GML2.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                var curve = context["curve"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var lines = geometry.getLineStrings();
                pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
              };
              GML2.prototype.writeGeometryElement = function(node, geometry, objectStack) {
                var context = (
                  /** @type {import("./Feature.js").WriteOptions} */
                  objectStack[objectStack.length - 1]
                );
                var item = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, context);
                item["node"] = node;
                var value;
                if (Array.isArray(geometry)) {
                  value = transformExtentWithOptions(
                    /** @type {import("../extent.js").Extent} */
                    geometry,
                    context
                  );
                } else {
                  value = transformGeometryWithOptions(
                    /** @type {import("../geom/Geometry.js").default} */
                    geometry,
                    true,
                    context
                  );
                }
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  item,
                  this.GEOMETRY_SERIALIZERS,
                  this.GEOMETRY_NODE_FACTORY_,
                  [value],
                  objectStack,
                  void 0,
                  this
                );
              };
              GML2.prototype.createCoordinatesNode_ = function(namespaceURI) {
                var coordinates = createElementNS(namespaceURI, "coordinates");
                coordinates.setAttribute("decimal", ".");
                coordinates.setAttribute("cs", ",");
                coordinates.setAttribute("ts", " ");
                return coordinates;
              };
              GML2.prototype.writeCoordinates_ = function(node, value, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                var points = value.getCoordinates();
                var len = points.length;
                var parts = new Array(len);
                for (var i = 0; i < len; ++i) {
                  var point = points[i];
                  parts[i] = this.getCoords_(point, srsName, hasZ);
                }
                writeStringTextNode(node, parts.join(" "));
              };
              GML2.prototype.writeCurveSegments_ = function(node, line, objectStack) {
                var child = createElementNS(node.namespaceURI, "LineStringSegment");
                node.appendChild(child);
                this.writeCurveOrLineString(child, line, objectStack);
              };
              GML2.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                if (node.nodeName !== "PolygonPatch" && srsName) {
                  node.setAttribute("srsName", srsName);
                }
                if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
                  var rings = geometry.getLinearRings();
                  pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
                } else if (node.nodeName === "Surface") {
                  var patches = createElementNS(node.namespaceURI, "patches");
                  node.appendChild(patches);
                  this.writeSurfacePatches_(patches, geometry, objectStack);
                }
              };
              GML2.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var context = objectStack[objectStack.length - 1];
                var parentNode = context.node;
                var exteriorWritten = context["exteriorWritten"];
                if (exteriorWritten === void 0) {
                  context["exteriorWritten"] = true;
                }
                return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
              };
              GML2.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
                var child = createElementNS(node.namespaceURI, "PolygonPatch");
                node.appendChild(child);
                this.writeSurfaceOrPolygon(child, polygon, objectStack);
              };
              GML2.prototype.writeRing = function(node, ring, objectStack) {
                var linearRing = createElementNS(node.namespaceURI, "LinearRing");
                node.appendChild(linearRing);
                this.writeLinearRing(linearRing, ring, objectStack);
              };
              GML2.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
                var axisOrientation = "enu";
                if (opt_srsName) {
                  axisOrientation = proj_get(opt_srsName).getAxisOrientation();
                }
                var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
                if (opt_hasZ) {
                  var z = point[2] || 0;
                  coords += "," + z;
                }
                return coords;
              };
              GML2.prototype.writePoint = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var coordinates = this.createCoordinatesNode_(node.namespaceURI);
                node.appendChild(coordinates);
                var point = geometry.getCoordinates();
                var coord = this.getCoords_(point, srsName, hasZ);
                writeStringTextNode(coordinates, coord);
              };
              GML2.prototype.writeMultiPoint = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var points = geometry.getPoints();
                pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
              };
              GML2.prototype.writePointMember = function(node, point, objectStack) {
                var child = createElementNS(node.namespaceURI, "Point");
                node.appendChild(child);
                this.writePoint(child, point, objectStack);
              };
              GML2.prototype.writeLinearRing = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var coordinates = this.createCoordinatesNode_(node.namespaceURI);
                node.appendChild(coordinates);
                this.writeCoordinates_(coordinates, geometry, objectStack);
              };
              GML2.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                var surface = context["surface"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var polygons = geometry.getPolygons();
                pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
              };
              GML2.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
                var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
                if (child) {
                  node.appendChild(child);
                  this.writeSurfaceOrPolygon(child, polygon, objectStack);
                }
              };
              GML2.prototype.writeEnvelope = function(node, extent, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var keys = ["lowerCorner", "upperCorner"];
                var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  { node },
                  this.ENVELOPE_SERIALIZERS,
                  OBJECT_PROPERTY_NODE_FACTORY,
                  values,
                  objectStack,
                  keys,
                  this
                );
              };
              GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var parentNode = objectStack[objectStack.length - 1].node;
                return createElementNS("http://www.opengis.net/gml", MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
              };
              return GML2;
            }(format_GMLBase)
          );
          GML2_GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
            "http://www.opengis.net/gml": {
              "coordinates": makeReplacer(GML2_GML2.prototype.readFlatCoordinates)
            }
          };
          GML2_GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
            "http://www.opengis.net/gml": {
              "innerBoundaryIs": GML2_GML2.prototype.innerBoundaryIsParser,
              "outerBoundaryIs": GML2_GML2.prototype.outerBoundaryIsParser
            }
          };
          GML2_GML2.prototype.BOX_PARSERS_ = {
            "http://www.opengis.net/gml": {
              "coordinates": makeArrayPusher(GML2_GML2.prototype.readFlatCoordinates)
            }
          };
          GML2_GML2.prototype.GEOMETRY_PARSERS = {
            "http://www.opengis.net/gml": {
              "Point": makeReplacer(format_GMLBase.prototype.readPoint),
              "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
              "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
              "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
              "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
              "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
              "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
              "Box": makeReplacer(GML2_GML2.prototype.readBox)
            }
          };
          GML2_GML2.prototype.GEOMETRY_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "Curve": makeChildAppender(GML2_GML2.prototype.writeCurveOrLineString),
              "MultiCurve": makeChildAppender(GML2_GML2.prototype.writeMultiCurveOrLineString),
              "Point": makeChildAppender(GML2_GML2.prototype.writePoint),
              "MultiPoint": makeChildAppender(GML2_GML2.prototype.writeMultiPoint),
              "LineString": makeChildAppender(GML2_GML2.prototype.writeCurveOrLineString),
              "MultiLineString": makeChildAppender(GML2_GML2.prototype.writeMultiCurveOrLineString),
              "LinearRing": makeChildAppender(GML2_GML2.prototype.writeLinearRing),
              "Polygon": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygon),
              "MultiPolygon": makeChildAppender(GML2_GML2.prototype.writeMultiSurfaceOrPolygon),
              "Surface": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygon),
              "MultiSurface": makeChildAppender(GML2_GML2.prototype.writeMultiSurfaceOrPolygon),
              "Envelope": makeChildAppender(GML2_GML2.prototype.writeEnvelope)
            }
          };
          GML2_GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "lineStringMember": makeChildAppender(GML2_GML2.prototype.writeLineStringOrCurveMember),
              "curveMember": makeChildAppender(GML2_GML2.prototype.writeLineStringOrCurveMember)
            }
          };
          GML2_GML2.prototype.RING_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "outerBoundaryIs": makeChildAppender(GML2_GML2.prototype.writeRing),
              "innerBoundaryIs": makeChildAppender(GML2_GML2.prototype.writeRing)
            }
          };
          GML2_GML2.prototype.POINTMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "pointMember": makeChildAppender(GML2_GML2.prototype.writePointMember)
            }
          };
          GML2_GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "surfaceMember": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygonMember),
              "polygonMember": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygonMember)
            }
          };
          GML2_GML2.prototype.ENVELOPE_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "lowerCorner": makeChildAppender(writeStringTextNode),
              "upperCorner": makeChildAppender(writeStringTextNode)
            }
          };
          var format_GML2 = GML2_GML2;
          var GML3_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GML3_schemaLocation = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
          var GML3_MULTIGEOMETRY_TO_MEMBER_NODENAME = {
            "MultiLineString": "lineStringMember",
            "MultiCurve": "curveMember",
            "MultiPolygon": "polygonMember",
            "MultiSurface": "surfaceMember"
          };
          var GML3_GML3 = (
            /** @class */
            function(_super) {
              GML3_extends(GML3, _super);
              function GML3(opt_options) {
                var _this = this;
                var options = (
                  /** @type {import("./GMLBase.js").Options} */
                  opt_options ? opt_options : {}
                );
                _this = _super.call(this, options) || this;
                _this.surface_ = options.surface !== void 0 ? options.surface : false;
                _this.curve_ = options.curve !== void 0 ? options.curve : false;
                _this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
                _this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
                _this.schemaLocation = options.schemaLocation ? options.schemaLocation : GML3_schemaLocation;
                _this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
                return _this;
              }
              GML3.prototype.readMultiCurve = function(node, objectStack) {
                var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);
                if (lineStrings) {
                  var multiLineString = new geom_MultiLineString(lineStrings);
                  return multiLineString;
                } else {
                  return void 0;
                }
              };
              GML3.prototype.readMultiSurface = function(node, objectStack) {
                var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node, objectStack, this);
                if (polygons) {
                  return new geom_MultiPolygon(polygons);
                }
              };
              GML3.prototype.curveMemberParser = function(node, objectStack) {
                parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);
              };
              GML3.prototype.surfaceMemberParser = function(node, objectStack) {
                parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
              };
              GML3.prototype.readPatch = function(node, objectStack) {
                return pushParseAndPop([null], this.PATCHES_PARSERS, node, objectStack, this);
              };
              GML3.prototype.readSegment = function(node, objectStack) {
                return pushParseAndPop([null], this.SEGMENTS_PARSERS, node, objectStack, this);
              };
              GML3.prototype.readPolygonPatch = function(node, objectStack) {
                return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
              };
              GML3.prototype.readLineStringSegment = function(node, objectStack) {
                return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
              };
              GML3.prototype.interiorParser = function(node, objectStack) {
                var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
                if (flatLinearRing) {
                  var flatLinearRings = (
                    /** @type {Array<Array<number>>} */
                    objectStack[objectStack.length - 1]
                  );
                  flatLinearRings.push(flatLinearRing);
                }
              };
              GML3.prototype.exteriorParser = function(node, objectStack) {
                var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
                if (flatLinearRing) {
                  var flatLinearRings = (
                    /** @type {Array<Array<number>>} */
                    objectStack[objectStack.length - 1]
                  );
                  flatLinearRings[0] = flatLinearRing;
                }
              };
              GML3.prototype.readSurface = function(node, objectStack) {
                var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node, objectStack, this);
                if (flatLinearRings && flatLinearRings[0]) {
                  var flatCoordinates = flatLinearRings[0];
                  var ends = [flatCoordinates.length];
                  var i = void 0, ii = void 0;
                  for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(flatCoordinates, flatLinearRings[i]);
                    ends.push(flatCoordinates.length);
                  }
                  return new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
                } else {
                  return void 0;
                }
              };
              GML3.prototype.readCurve = function(node, objectStack) {
                var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node, objectStack, this);
                if (flatCoordinates) {
                  var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
                  return lineString;
                } else {
                  return void 0;
                }
              };
              GML3.prototype.readEnvelope = function(node, objectStack) {
                var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node, objectStack, this);
                return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
              };
              GML3.prototype.readFlatPos = function(node, objectStack) {
                var s = getAllTextContent(node, false);
                var re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
                var flatCoordinates = [];
                var m;
                while (m = re.exec(s)) {
                  flatCoordinates.push(parseFloat(m[1]));
                  s = s.substr(m[0].length);
                }
                if (s !== "") {
                  return void 0;
                }
                var context = objectStack[0];
                var containerSrs = context["srsName"];
                var axisOrientation = "enu";
                if (containerSrs) {
                  var proj = proj_get(containerSrs);
                  axisOrientation = proj.getAxisOrientation();
                }
                if (axisOrientation === "neu") {
                  var i = void 0, ii = void 0;
                  for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
                    var y = flatCoordinates[i];
                    var x = flatCoordinates[i + 1];
                    flatCoordinates[i] = x;
                    flatCoordinates[i + 1] = y;
                  }
                }
                var len = flatCoordinates.length;
                if (len == 2) {
                  flatCoordinates.push(0);
                }
                if (len === 0) {
                  return void 0;
                }
                return flatCoordinates;
              };
              GML3.prototype.readFlatPosList = function(node, objectStack) {
                var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
                var context = objectStack[0];
                var containerSrs = context["srsName"];
                var contextDimension = context["srsDimension"];
                var axisOrientation = "enu";
                if (containerSrs) {
                  var proj = proj_get(containerSrs);
                  axisOrientation = proj.getAxisOrientation();
                }
                var coords = s.split(/\s+/);
                var dim = 2;
                if (node.getAttribute("srsDimension")) {
                  dim = readNonNegativeIntegerString(node.getAttribute("srsDimension"));
                } else if (node.getAttribute("dimension")) {
                  dim = readNonNegativeIntegerString(node.getAttribute("dimension"));
                } else if (
                  /** @type {Element} */
                  node.parentNode.getAttribute("srsDimension")
                ) {
                  dim = readNonNegativeIntegerString(
                    /** @type {Element} */
                    node.parentNode.getAttribute("srsDimension")
                  );
                } else if (contextDimension) {
                  dim = readNonNegativeIntegerString(contextDimension);
                }
                var x, y, z;
                var flatCoordinates = [];
                for (var i = 0, ii = coords.length; i < ii; i += dim) {
                  x = parseFloat(coords[i]);
                  y = parseFloat(coords[i + 1]);
                  z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
                  if (axisOrientation.substr(0, 2) === "en") {
                    flatCoordinates.push(x, y, z);
                  } else {
                    flatCoordinates.push(y, x, z);
                  }
                }
                return flatCoordinates;
              };
              GML3.prototype.writePos_ = function(node, value, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsDimension = hasZ ? "3" : "2";
                node.setAttribute("srsDimension", srsDimension);
                var srsName = context["srsName"];
                var axisOrientation = "enu";
                if (srsName) {
                  axisOrientation = proj_get(srsName).getAxisOrientation();
                }
                var point = value.getCoordinates();
                var coords;
                if (axisOrientation.substr(0, 2) === "en") {
                  coords = point[0] + " " + point[1];
                } else {
                  coords = point[1] + " " + point[0];
                }
                if (hasZ) {
                  var z = point[2] || 0;
                  coords += " " + z;
                }
                writeStringTextNode(node, coords);
              };
              GML3.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
                var axisOrientation = "enu";
                if (opt_srsName) {
                  axisOrientation = proj_get(opt_srsName).getAxisOrientation();
                }
                var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
                if (opt_hasZ) {
                  var z = point[2] || 0;
                  coords += " " + z;
                }
                return coords;
              };
              GML3.prototype.writePosList_ = function(node, value, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsDimension = hasZ ? "3" : "2";
                node.setAttribute("srsDimension", srsDimension);
                var srsName = context["srsName"];
                var points = value.getCoordinates();
                var len = points.length;
                var parts = new Array(len);
                var point;
                for (var i = 0; i < len; ++i) {
                  point = points[i];
                  parts[i] = this.getCoords_(point, srsName, hasZ);
                }
                writeStringTextNode(node, parts.join(" "));
              };
              GML3.prototype.writePoint = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var pos = createElementNS(node.namespaceURI, "pos");
                node.appendChild(pos);
                this.writePos_(pos, geometry, objectStack);
              };
              GML3.prototype.writeEnvelope = function(node, extent, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var keys = ["lowerCorner", "upperCorner"];
                var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  { node },
                  this.ENVELOPE_SERIALIZERS,
                  OBJECT_PROPERTY_NODE_FACTORY,
                  values,
                  objectStack,
                  keys,
                  this
                );
              };
              GML3.prototype.writeLinearRing = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var posList = createElementNS(node.namespaceURI, "posList");
                node.appendChild(posList);
                this.writePosList_(posList, geometry, objectStack);
              };
              GML3.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var context = objectStack[objectStack.length - 1];
                var parentNode = context.node;
                var exteriorWritten = context["exteriorWritten"];
                if (exteriorWritten === void 0) {
                  context["exteriorWritten"] = true;
                }
                return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "interior" : "exterior");
              };
              GML3.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                if (node.nodeName !== "PolygonPatch" && srsName) {
                  node.setAttribute("srsName", srsName);
                }
                if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
                  var rings = geometry.getLinearRings();
                  pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
                } else if (node.nodeName === "Surface") {
                  var patches = createElementNS(node.namespaceURI, "patches");
                  node.appendChild(patches);
                  this.writeSurfacePatches_(patches, geometry, objectStack);
                }
              };
              GML3.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                if (node.nodeName !== "LineStringSegment" && srsName) {
                  node.setAttribute("srsName", srsName);
                }
                if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
                  var posList = createElementNS(node.namespaceURI, "posList");
                  node.appendChild(posList);
                  this.writePosList_(posList, geometry, objectStack);
                } else if (node.nodeName === "Curve") {
                  var segments = createElementNS(node.namespaceURI, "segments");
                  node.appendChild(segments);
                  this.writeCurveSegments_(segments, geometry, objectStack);
                }
              };
              GML3.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                var surface = context["surface"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var polygons = geometry.getPolygons();
                pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
              };
              GML3.prototype.writeMultiPoint = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var srsName = context["srsName"];
                var hasZ = context["hasZ"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var points = geometry.getPoints();
                pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
              };
              GML3.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
                var context = objectStack[objectStack.length - 1];
                var hasZ = context["hasZ"];
                var srsName = context["srsName"];
                var curve = context["curve"];
                if (srsName) {
                  node.setAttribute("srsName", srsName);
                }
                var lines = geometry.getLineStrings();
                pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
              };
              GML3.prototype.writeRing = function(node, ring, objectStack) {
                var linearRing = createElementNS(node.namespaceURI, "LinearRing");
                node.appendChild(linearRing);
                this.writeLinearRing(linearRing, ring, objectStack);
              };
              GML3.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
                var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
                if (child) {
                  node.appendChild(child);
                  this.writeSurfaceOrPolygon(child, polygon, objectStack);
                }
              };
              GML3.prototype.writePointMember = function(node, point, objectStack) {
                var child = createElementNS(node.namespaceURI, "Point");
                node.appendChild(child);
                this.writePoint(child, point, objectStack);
              };
              GML3.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
                var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
                if (child) {
                  node.appendChild(child);
                  this.writeCurveOrLineString(child, line, objectStack);
                }
              };
              GML3.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
                var child = createElementNS(node.namespaceURI, "PolygonPatch");
                node.appendChild(child);
                this.writeSurfaceOrPolygon(child, polygon, objectStack);
              };
              GML3.prototype.writeCurveSegments_ = function(node, line, objectStack) {
                var child = createElementNS(node.namespaceURI, "LineStringSegment");
                node.appendChild(child);
                this.writeCurveOrLineString(child, line, objectStack);
              };
              GML3.prototype.writeGeometryElement = function(node, geometry, objectStack) {
                var context = (
                  /** @type {import("./Feature.js").WriteOptions} */
                  objectStack[objectStack.length - 1]
                );
                var item = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, context);
                item["node"] = node;
                var value;
                if (Array.isArray(geometry)) {
                  value = transformExtentWithOptions(
                    /** @type {import("../extent.js").Extent} */
                    geometry,
                    context
                  );
                } else {
                  value = transformGeometryWithOptions(
                    /** @type {import("../geom/Geometry.js").default} */
                    geometry,
                    true,
                    context
                  );
                }
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  item,
                  this.GEOMETRY_SERIALIZERS,
                  this.GEOMETRY_NODE_FACTORY_,
                  [value],
                  objectStack,
                  void 0,
                  this
                );
              };
              GML3.prototype.writeFeatureElement = function(node, feature, objectStack) {
                var fid = feature.getId();
                if (fid) {
                  node.setAttribute(
                    "fid",
                    /** @type {string} */
                    fid
                  );
                }
                var context = (
                  /** @type {Object} */
                  objectStack[objectStack.length - 1]
                );
                var featureNS = context["featureNS"];
                var geometryName = feature.getGeometryName();
                if (!context.serializers) {
                  context.serializers = {};
                  context.serializers[featureNS] = {};
                }
                var keys = [];
                var values = [];
                if (feature.hasProperties()) {
                  var properties = feature.getProperties();
                  for (var key in properties) {
                    var value = properties[key];
                    if (value !== null) {
                      keys.push(key);
                      values.push(value);
                      if (key == geometryName || typeof /** @type {?} */
                      value.getSimplifiedGeometry === "function") {
                        if (!(key in context.serializers[featureNS])) {
                          context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
                        }
                      } else {
                        if (!(key in context.serializers[featureNS])) {
                          context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
                        }
                      }
                    }
                  }
                }
                var item = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, context);
                item.node = node;
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  item,
                  context.serializers,
                  makeSimpleNodeFactory(void 0, featureNS),
                  values,
                  objectStack,
                  keys
                );
              };
              GML3.prototype.writeFeatureMembers_ = function(node, features, objectStack) {
                var context = (
                  /** @type {Object} */
                  objectStack[objectStack.length - 1]
                );
                var featureType = context["featureType"];
                var featureNS = context["featureNS"];
                var serializers = {};
                serializers[featureNS] = {};
                serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);
                var item = Object(ol_obj[
                  "a"
                  /* assign */
                ])({}, context);
                item.node = node;
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  item,
                  serializers,
                  makeSimpleNodeFactory(featureType, featureNS),
                  features,
                  objectStack
                );
              };
              GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var parentNode = objectStack[objectStack.length - 1].node;
                return createElementNS(this.namespace, GML3_MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
              };
              GML3.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
                var context = objectStack[objectStack.length - 1];
                var multiSurface = context["multiSurface"];
                var surface = context["surface"];
                var curve = context["curve"];
                var multiCurve = context["multiCurve"];
                var nodeName;
                if (!Array.isArray(value)) {
                  nodeName = /** @type {import("../geom/Geometry.js").default} */
                  value.getType();
                  if (nodeName === "MultiPolygon" && multiSurface === true) {
                    nodeName = "MultiSurface";
                  } else if (nodeName === "Polygon" && surface === true) {
                    nodeName = "Surface";
                  } else if (nodeName === "LineString" && curve === true) {
                    nodeName = "Curve";
                  } else if (nodeName === "MultiLineString" && multiCurve === true) {
                    nodeName = "MultiCurve";
                  }
                } else {
                  nodeName = "Envelope";
                }
                return createElementNS(this.namespace, nodeName);
              };
              GML3.prototype.writeGeometryNode = function(geometry, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var geom = createElementNS(this.namespace, "geom");
                var context = {
                  node: geom,
                  hasZ: this.hasZ,
                  srsName: this.srsName,
                  curve: this.curve_,
                  surface: this.surface_,
                  multiSurface: this.multiSurface_,
                  multiCurve: this.multiCurve_
                };
                if (opt_options) {
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(context, opt_options);
                }
                this.writeGeometryElement(geom, geometry, [context]);
                return geom;
              };
              GML3.prototype.writeFeaturesNode = function(features, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var node = createElementNS(this.namespace, "featureMembers");
                node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation);
                var context = {
                  srsName: this.srsName,
                  hasZ: this.hasZ,
                  curve: this.curve_,
                  surface: this.surface_,
                  multiSurface: this.multiSurface_,
                  multiCurve: this.multiCurve_,
                  featureNS: this.featureNS,
                  featureType: this.featureType
                };
                if (opt_options) {
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(context, opt_options);
                }
                this.writeFeatureMembers_(node, features, [context]);
                return node;
              };
              return GML3;
            }(format_GMLBase)
          );
          GML3_GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
            "http://www.opengis.net/gml": {
              "pos": makeReplacer(GML3_GML3.prototype.readFlatPos),
              "posList": makeReplacer(GML3_GML3.prototype.readFlatPosList),
              "coordinates": makeReplacer(format_GML2.prototype.readFlatCoordinates)
            }
          };
          GML3_GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
            "http://www.opengis.net/gml": {
              "interior": GML3_GML3.prototype.interiorParser,
              "exterior": GML3_GML3.prototype.exteriorParser
            }
          };
          GML3_GML3.prototype.GEOMETRY_PARSERS = {
            "http://www.opengis.net/gml": {
              "Point": makeReplacer(format_GMLBase.prototype.readPoint),
              "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
              "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
              "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
              "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
              "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
              "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
              "Surface": makeReplacer(GML3_GML3.prototype.readSurface),
              "MultiSurface": makeReplacer(GML3_GML3.prototype.readMultiSurface),
              "Curve": makeReplacer(GML3_GML3.prototype.readCurve),
              "MultiCurve": makeReplacer(GML3_GML3.prototype.readMultiCurve),
              "Envelope": makeReplacer(GML3_GML3.prototype.readEnvelope)
            }
          };
          GML3_GML3.prototype.MULTICURVE_PARSERS = {
            "http://www.opengis.net/gml": {
              "curveMember": makeArrayPusher(GML3_GML3.prototype.curveMemberParser),
              "curveMembers": makeArrayPusher(GML3_GML3.prototype.curveMemberParser)
            }
          };
          GML3_GML3.prototype.MULTISURFACE_PARSERS = {
            "http://www.opengis.net/gml": {
              "surfaceMember": makeArrayPusher(GML3_GML3.prototype.surfaceMemberParser),
              "surfaceMembers": makeArrayPusher(GML3_GML3.prototype.surfaceMemberParser)
            }
          };
          GML3_GML3.prototype.CURVEMEMBER_PARSERS = {
            "http://www.opengis.net/gml": {
              "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString),
              "Curve": makeArrayPusher(GML3_GML3.prototype.readCurve)
            }
          };
          GML3_GML3.prototype.SURFACEMEMBER_PARSERS = {
            "http://www.opengis.net/gml": {
              "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon),
              "Surface": makeArrayPusher(GML3_GML3.prototype.readSurface)
            }
          };
          GML3_GML3.prototype.SURFACE_PARSERS = {
            "http://www.opengis.net/gml": {
              "patches": makeReplacer(GML3_GML3.prototype.readPatch)
            }
          };
          GML3_GML3.prototype.CURVE_PARSERS = {
            "http://www.opengis.net/gml": {
              "segments": makeReplacer(GML3_GML3.prototype.readSegment)
            }
          };
          GML3_GML3.prototype.ENVELOPE_PARSERS = {
            "http://www.opengis.net/gml": {
              "lowerCorner": makeArrayPusher(GML3_GML3.prototype.readFlatPosList),
              "upperCorner": makeArrayPusher(GML3_GML3.prototype.readFlatPosList)
            }
          };
          GML3_GML3.prototype.PATCHES_PARSERS = {
            "http://www.opengis.net/gml": {
              "PolygonPatch": makeReplacer(GML3_GML3.prototype.readPolygonPatch)
            }
          };
          GML3_GML3.prototype.SEGMENTS_PARSERS = {
            "http://www.opengis.net/gml": {
              "LineStringSegment": makeReplacer(GML3_GML3.prototype.readLineStringSegment)
            }
          };
          GML3_GML3.prototype.writeFeatures;
          GML3_GML3.prototype.RING_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "exterior": makeChildAppender(GML3_GML3.prototype.writeRing),
              "interior": makeChildAppender(GML3_GML3.prototype.writeRing)
            }
          };
          GML3_GML3.prototype.ENVELOPE_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "lowerCorner": makeChildAppender(writeStringTextNode),
              "upperCorner": makeChildAppender(writeStringTextNode)
            }
          };
          GML3_GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "surfaceMember": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygonMember),
              "polygonMember": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygonMember)
            }
          };
          GML3_GML3.prototype.POINTMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "pointMember": makeChildAppender(GML3_GML3.prototype.writePointMember)
            }
          };
          GML3_GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "lineStringMember": makeChildAppender(GML3_GML3.prototype.writeLineStringOrCurveMember),
              "curveMember": makeChildAppender(GML3_GML3.prototype.writeLineStringOrCurveMember)
            }
          };
          GML3_GML3.prototype.GEOMETRY_SERIALIZERS = {
            "http://www.opengis.net/gml": {
              "Curve": makeChildAppender(GML3_GML3.prototype.writeCurveOrLineString),
              "MultiCurve": makeChildAppender(GML3_GML3.prototype.writeMultiCurveOrLineString),
              "Point": makeChildAppender(GML3_GML3.prototype.writePoint),
              "MultiPoint": makeChildAppender(GML3_GML3.prototype.writeMultiPoint),
              "LineString": makeChildAppender(GML3_GML3.prototype.writeCurveOrLineString),
              "MultiLineString": makeChildAppender(GML3_GML3.prototype.writeMultiCurveOrLineString),
              "LinearRing": makeChildAppender(GML3_GML3.prototype.writeLinearRing),
              "Polygon": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygon),
              "MultiPolygon": makeChildAppender(GML3_GML3.prototype.writeMultiSurfaceOrPolygon),
              "Surface": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygon),
              "MultiSurface": makeChildAppender(GML3_GML3.prototype.writeMultiSurfaceOrPolygon),
              "Envelope": makeChildAppender(GML3_GML3.prototype.writeEnvelope)
            }
          };
          var format_GML3 = GML3_GML3;
          var GML = format_GML3;
          GML.prototype.writeFeatures;
          GML.prototype.writeFeaturesNode;
          var format_GML = GML;
          var GPX_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var NAMESPACE_URIS = [
            null,
            "http://www.topografix.com/GPX/1/0",
            "http://www.topografix.com/GPX/1/1"
          ];
          var SCHEMA_LOCATION = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
          var FEATURE_READER = {
            "rte": readRte,
            "trk": readTrk,
            "wpt": readWpt
          };
          var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "rte": makeArrayPusher(readRte),
            "trk": makeArrayPusher(readTrk),
            "wpt": makeArrayPusher(readWpt)
          });
          var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "text": makeObjectPropertySetter(readString, "linkText"),
            "type": makeObjectPropertySetter(readString, "linkType")
          });
          var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "rte": makeChildAppender(writeRte),
            "trk": makeChildAppender(writeTrk),
            "wpt": makeChildAppender(writeWpt)
          });
          var GPX_GPX = (
            /** @class */
            function(_super) {
              GPX_extends(GPX, _super);
              function GPX(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.dataProjection = proj_get("EPSG:4326");
                _this.readExtensions_ = options.readExtensions;
                return _this;
              }
              GPX.prototype.handleReadExtensions_ = function(features) {
                if (!features) {
                  features = [];
                }
                for (var i = 0, ii = features.length; i < ii; ++i) {
                  var feature = features[i];
                  if (this.readExtensions_) {
                    var extensionsNode = feature.get("extensionsNode_") || null;
                    this.readExtensions_(feature, extensionsNode);
                  }
                  feature.set("extensionsNode_", void 0);
                }
              };
              GPX.prototype.readFeatureFromNode = function(node, opt_options) {
                if (!Object(ol_array[
                  "f"
                  /* includes */
                ])(NAMESPACE_URIS, node.namespaceURI)) {
                  return null;
                }
                var featureReader = FEATURE_READER[node.localName];
                if (!featureReader) {
                  return null;
                }
                var feature = featureReader(node, [
                  this.getReadOptions(node, opt_options)
                ]);
                if (!feature) {
                  return null;
                }
                this.handleReadExtensions_([feature]);
                return feature;
              };
              GPX.prototype.readFeaturesFromNode = function(node, opt_options) {
                if (!Object(ol_array[
                  "f"
                  /* includes */
                ])(NAMESPACE_URIS, node.namespaceURI)) {
                  return [];
                }
                if (node.localName == "gpx") {
                  var features = pushParseAndPop([], GPX_PARSERS, node, [
                    this.getReadOptions(node, opt_options)
                  ]);
                  if (features) {
                    this.handleReadExtensions_(features);
                    return features;
                  } else {
                    return [];
                  }
                }
                return [];
              };
              GPX.prototype.writeFeaturesNode = function(features, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
                var xmlnsUri = "http://www.w3.org/2000/xmlns/";
                gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
                gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION);
                gpx.setAttribute("version", "1.1");
                gpx.setAttribute("creator", "OpenLayers");
                pushSerializeAndPop(
                  /** @type {import("../xml.js").NodeStackItem} */
                  { node: gpx },
                  GPX_SERIALIZERS,
                  GPX_NODE_FACTORY,
                  features,
                  [opt_options]
                );
                return gpx;
              };
              return GPX;
            }(format_XMLFeature)
          );
          var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "name": makeObjectPropertySetter(readString),
            "cmt": makeObjectPropertySetter(readString),
            "desc": makeObjectPropertySetter(readString),
            "src": makeObjectPropertySetter(readString),
            "link": parseLink,
            "number": makeObjectPropertySetter(readNonNegativeInteger),
            "extensions": parseExtensions,
            "type": makeObjectPropertySetter(readString),
            "rtept": parseRtePt
          });
          var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "ele": makeObjectPropertySetter(readDecimal),
            "time": makeObjectPropertySetter(readDateTime)
          });
          var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "name": makeObjectPropertySetter(readString),
            "cmt": makeObjectPropertySetter(readString),
            "desc": makeObjectPropertySetter(readString),
            "src": makeObjectPropertySetter(readString),
            "link": parseLink,
            "number": makeObjectPropertySetter(readNonNegativeInteger),
            "type": makeObjectPropertySetter(readString),
            "extensions": parseExtensions,
            "trkseg": parseTrkSeg
          });
          var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "trkpt": parseTrkPt
          });
          var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "ele": makeObjectPropertySetter(readDecimal),
            "time": makeObjectPropertySetter(readDateTime)
          });
          var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
            "ele": makeObjectPropertySetter(readDecimal),
            "time": makeObjectPropertySetter(readDateTime),
            "magvar": makeObjectPropertySetter(readDecimal),
            "geoidheight": makeObjectPropertySetter(readDecimal),
            "name": makeObjectPropertySetter(readString),
            "cmt": makeObjectPropertySetter(readString),
            "desc": makeObjectPropertySetter(readString),
            "src": makeObjectPropertySetter(readString),
            "link": parseLink,
            "sym": makeObjectPropertySetter(readString),
            "type": makeObjectPropertySetter(readString),
            "fix": makeObjectPropertySetter(readString),
            "sat": makeObjectPropertySetter(readNonNegativeInteger),
            "hdop": makeObjectPropertySetter(readDecimal),
            "vdop": makeObjectPropertySetter(readDecimal),
            "pdop": makeObjectPropertySetter(readDecimal),
            "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
            "dgpsid": makeObjectPropertySetter(readNonNegativeInteger),
            "extensions": parseExtensions
          });
          var LINK_SEQUENCE = ["text", "type"];
          var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "text": makeChildAppender(writeStringTextNode),
            "type": makeChildAppender(writeStringTextNode)
          });
          var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
            "name",
            "cmt",
            "desc",
            "src",
            "link",
            "number",
            "type",
            "rtept"
          ]);
          var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "name": makeChildAppender(writeStringTextNode),
            "cmt": makeChildAppender(writeStringTextNode),
            "desc": makeChildAppender(writeStringTextNode),
            "src": makeChildAppender(writeStringTextNode),
            "link": makeChildAppender(writeLink),
            "number": makeChildAppender(writeNonNegativeIntegerTextNode),
            "type": makeChildAppender(writeStringTextNode),
            "rtept": makeArraySerializer(makeChildAppender(writeWptType))
          });
          var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ["ele", "time"]);
          var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
            "name",
            "cmt",
            "desc",
            "src",
            "link",
            "number",
            "type",
            "trkseg"
          ]);
          var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "name": makeChildAppender(writeStringTextNode),
            "cmt": makeChildAppender(writeStringTextNode),
            "desc": makeChildAppender(writeStringTextNode),
            "src": makeChildAppender(writeStringTextNode),
            "link": makeChildAppender(writeLink),
            "number": makeChildAppender(writeNonNegativeIntegerTextNode),
            "type": makeChildAppender(writeStringTextNode),
            "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
          });
          var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
          var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "trkpt": makeChildAppender(writeWptType)
          });
          var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
            "ele",
            "time",
            "magvar",
            "geoidheight",
            "name",
            "cmt",
            "desc",
            "src",
            "link",
            "sym",
            "type",
            "fix",
            "sat",
            "hdop",
            "vdop",
            "pdop",
            "ageofdgpsdata",
            "dgpsid"
          ]);
          var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
            "ele": makeChildAppender(writeDecimalTextNode),
            "time": makeChildAppender(writeDateTimeTextNode),
            "magvar": makeChildAppender(writeDecimalTextNode),
            "geoidheight": makeChildAppender(writeDecimalTextNode),
            "name": makeChildAppender(writeStringTextNode),
            "cmt": makeChildAppender(writeStringTextNode),
            "desc": makeChildAppender(writeStringTextNode),
            "src": makeChildAppender(writeStringTextNode),
            "link": makeChildAppender(writeLink),
            "sym": makeChildAppender(writeStringTextNode),
            "type": makeChildAppender(writeStringTextNode),
            "fix": makeChildAppender(writeStringTextNode),
            "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
            "hdop": makeChildAppender(writeDecimalTextNode),
            "vdop": makeChildAppender(writeDecimalTextNode),
            "pdop": makeChildAppender(writeDecimalTextNode),
            "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
            "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
          });
          var GEOMETRY_TYPE_TO_NODENAME = {
            "Point": "wpt",
            "LineString": "rte",
            "MultiLineString": "trk"
          };
          function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
            var geometry = (
              /** @type {Feature} */
              value.getGeometry()
            );
            if (geometry) {
              var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
              if (nodeName) {
                var parentNode = objectStack[objectStack.length - 1].node;
                return createElementNS(parentNode.namespaceURI, nodeName);
              }
            }
          }
          function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
            flatCoordinates.push(parseFloat(node.getAttribute("lon")), parseFloat(node.getAttribute("lat")));
            if ("ele" in values) {
              flatCoordinates.push(
                /** @type {number} */
                values["ele"]
              );
              delete values["ele"];
              layoutOptions.hasZ = true;
            } else {
              flatCoordinates.push(0);
            }
            if ("time" in values) {
              flatCoordinates.push(
                /** @type {number} */
                values["time"]
              );
              delete values["time"];
              layoutOptions.hasM = true;
            } else {
              flatCoordinates.push(0);
            }
            return flatCoordinates;
          }
          function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
            var layout = GeometryLayout.XY;
            var stride = 2;
            if (layoutOptions.hasZ && layoutOptions.hasM) {
              layout = GeometryLayout.XYZM;
              stride = 4;
            } else if (layoutOptions.hasZ) {
              layout = GeometryLayout.XYZ;
              stride = 3;
            } else if (layoutOptions.hasM) {
              layout = GeometryLayout.XYM;
              stride = 3;
            }
            if (stride !== 4) {
              for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
                flatCoordinates[i * stride] = flatCoordinates[i * 4];
                flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
                if (layoutOptions.hasZ) {
                  flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
                }
                if (layoutOptions.hasM) {
                  flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
                }
              }
              flatCoordinates.length = flatCoordinates.length / 4 * stride;
              if (ends) {
                for (var i = 0, ii = ends.length; i < ii; i++) {
                  ends[i] = ends[i] / 4 * stride;
                }
              }
            }
            return layout;
          }
          function parseLink(node, objectStack) {
            var values = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var href = node.getAttribute("href");
            if (href !== null) {
              values["link"] = href;
            }
            parseNode(LINK_PARSERS, node, objectStack);
          }
          function parseExtensions(node, objectStack) {
            var values = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            values["extensionsNode_"] = node;
          }
          function parseRtePt(node, objectStack) {
            var values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
            if (values) {
              var rteValues = (
                /** @type {!Object} */
                objectStack[objectStack.length - 1]
              );
              var flatCoordinates = (
                /** @type {Array<number>} */
                rteValues["flatCoordinates"]
              );
              var layoutOptions = (
                /** @type {LayoutOptions} */
                rteValues["layoutOptions"]
              );
              appendCoordinate(flatCoordinates, layoutOptions, node, values);
            }
          }
          function parseTrkPt(node, objectStack) {
            var values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
            if (values) {
              var trkValues = (
                /** @type {!Object} */
                objectStack[objectStack.length - 1]
              );
              var flatCoordinates = (
                /** @type {Array<number>} */
                trkValues["flatCoordinates"]
              );
              var layoutOptions = (
                /** @type {LayoutOptions} */
                trkValues["layoutOptions"]
              );
              appendCoordinate(flatCoordinates, layoutOptions, node, values);
            }
          }
          function parseTrkSeg(node, objectStack) {
            var values = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            parseNode(TRKSEG_PARSERS, node, objectStack);
            var flatCoordinates = (
              /** @type {Array<number>} */
              values["flatCoordinates"]
            );
            var ends = (
              /** @type {Array<number>} */
              values["ends"]
            );
            ends.push(flatCoordinates.length);
          }
          function readRte(node, objectStack) {
            var options = (
              /** @type {import("./Feature.js").ReadOptions} */
              objectStack[0]
            );
            var values = pushParseAndPop({
              "flatCoordinates": [],
              "layoutOptions": {}
            }, RTE_PARSERS, node, objectStack);
            if (!values) {
              return void 0;
            }
            var flatCoordinates = (
              /** @type {Array<number>} */
              values["flatCoordinates"]
            );
            delete values["flatCoordinates"];
            var layoutOptions = (
              /** @type {LayoutOptions} */
              values["layoutOptions"]
            );
            delete values["layoutOptions"];
            var layout = applyLayoutOptions(layoutOptions, flatCoordinates);
            var geometry = new geom_LineString(flatCoordinates, layout);
            transformGeometryWithOptions(geometry, false, options);
            var feature = new ol_Feature(geometry);
            feature.setProperties(values, true);
            return feature;
          }
          function readTrk(node, objectStack) {
            var options = (
              /** @type {import("./Feature.js").ReadOptions} */
              objectStack[0]
            );
            var values = pushParseAndPop({
              "flatCoordinates": [],
              "ends": [],
              "layoutOptions": {}
            }, TRK_PARSERS, node, objectStack);
            if (!values) {
              return void 0;
            }
            var flatCoordinates = (
              /** @type {Array<number>} */
              values["flatCoordinates"]
            );
            delete values["flatCoordinates"];
            var ends = (
              /** @type {Array<number>} */
              values["ends"]
            );
            delete values["ends"];
            var layoutOptions = (
              /** @type {LayoutOptions} */
              values["layoutOptions"]
            );
            delete values["layoutOptions"];
            var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
            var geometry = new geom_MultiLineString(flatCoordinates, layout, ends);
            transformGeometryWithOptions(geometry, false, options);
            var feature = new ol_Feature(geometry);
            feature.setProperties(values, true);
            return feature;
          }
          function readWpt(node, objectStack) {
            var options = (
              /** @type {import("./Feature.js").ReadOptions} */
              objectStack[0]
            );
            var values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);
            if (!values) {
              return void 0;
            }
            var layoutOptions = (
              /** @type {LayoutOptions} */
              {}
            );
            var coordinates = appendCoordinate([], layoutOptions, node, values);
            var layout = applyLayoutOptions(layoutOptions, coordinates);
            var geometry = new geom_Point(coordinates, layout);
            transformGeometryWithOptions(geometry, false, options);
            var feature = new ol_Feature(geometry);
            feature.setProperties(values, true);
            return feature;
          }
          function writeLink(node, value, objectStack) {
            node.setAttribute("href", value);
            var context = objectStack[objectStack.length - 1];
            var properties = context["properties"];
            var link = [properties["linkText"], properties["linkType"]];
            pushSerializeAndPop(
              /** @type {import("../xml.js").NodeStackItem} */
              { node },
              LINK_SERIALIZERS,
              OBJECT_PROPERTY_NODE_FACTORY,
              link,
              objectStack,
              LINK_SEQUENCE
            );
          }
          function writeWptType(node, coordinate, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var parentNode = context.node;
            var namespaceURI = parentNode.namespaceURI;
            var properties = context["properties"];
            node.setAttributeNS(null, "lat", String(coordinate[1]));
            node.setAttributeNS(null, "lon", String(coordinate[0]));
            var geometryLayout = context["geometryLayout"];
            switch (geometryLayout) {
              case GeometryLayout.XYZM:
                if (coordinate[3] !== 0) {
                  properties["time"] = coordinate[3];
                }
              // fall through
              case GeometryLayout.XYZ:
                if (coordinate[2] !== 0) {
                  properties["ele"] = coordinate[2];
                }
                break;
              case GeometryLayout.XYM:
                if (coordinate[2] !== 0) {
                  properties["time"] = coordinate[2];
                }
                break;
              default:
            }
            var orderedKeys = node.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(
              /** @type {import("../xml.js").NodeStackItem} */
              { node, "properties": properties },
              WPT_TYPE_SERIALIZERS,
              OBJECT_PROPERTY_NODE_FACTORY,
              values,
              objectStack,
              orderedKeys
            );
          }
          function writeRte(node, feature, objectStack) {
            var options = (
              /** @type {import("./Feature.js").WriteOptions} */
              objectStack[0]
            );
            var properties = feature.getProperties();
            var context = { node };
            context["properties"] = properties;
            var geometry = feature.getGeometry();
            if (geometry.getType() == geom_GeometryType.LINE_STRING) {
              var lineString = (
                /** @type {LineString} */
                transformGeometryWithOptions(geometry, true, options)
              );
              context["geometryLayout"] = lineString.getLayout();
              properties["rtept"] = lineString.getCoordinates();
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          function writeTrk(node, feature, objectStack) {
            var options = (
              /** @type {import("./Feature.js").WriteOptions} */
              objectStack[0]
            );
            var properties = feature.getProperties();
            var context = { node };
            context["properties"] = properties;
            var geometry = feature.getGeometry();
            if (geometry.getType() == geom_GeometryType.MULTI_LINE_STRING) {
              var multiLineString = (
                /** @type {MultiLineString} */
                transformGeometryWithOptions(geometry, true, options)
              );
              properties["trkseg"] = multiLineString.getLineStrings();
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          function writeTrkSeg(node, lineString, objectStack) {
            var context = { node };
            context["geometryLayout"] = lineString.getLayout();
            context["properties"] = {};
            pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
          }
          function writeWpt(node, feature, objectStack) {
            var options = (
              /** @type {import("./Feature.js").WriteOptions} */
              objectStack[0]
            );
            var context = objectStack[objectStack.length - 1];
            context["properties"] = feature.getProperties();
            var geometry = feature.getGeometry();
            if (geometry.getType() == geom_GeometryType.POINT) {
              var point = (
                /** @type {Point} */
                transformGeometryWithOptions(geometry, true, options)
              );
              context["geometryLayout"] = point.getLayout();
              writeWptType(node, point.getCoordinates(), objectStack);
            }
          }
          var format_GPX = GPX_GPX;
          var TextFeature_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TextFeature_TextFeature = (
            /** @class */
            function(_super) {
              TextFeature_extends(TextFeature, _super);
              function TextFeature() {
                return _super.call(this) || this;
              }
              TextFeature.prototype.getType = function() {
                return FormatType.TEXT;
              };
              TextFeature.prototype.readFeature = function(source, opt_options) {
                return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
              };
              TextFeature.prototype.readFeatureFromText = function(text, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TextFeature.prototype.readFeatures = function(source, opt_options) {
                return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
              };
              TextFeature.prototype.readFeaturesFromText = function(text, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TextFeature.prototype.readGeometry = function(source, opt_options) {
                return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
              };
              TextFeature.prototype.readGeometryFromText = function(text, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TextFeature.prototype.readProjection = function(source) {
                return this.readProjectionFromText(getText(source));
              };
              TextFeature.prototype.readProjectionFromText = function(text) {
                return this.dataProjection;
              };
              TextFeature.prototype.writeFeature = function(feature, opt_options) {
                return this.writeFeatureText(feature, this.adaptOptions(opt_options));
              };
              TextFeature.prototype.writeFeatureText = function(feature, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TextFeature.prototype.writeFeatures = function(features, opt_options) {
                return this.writeFeaturesText(features, this.adaptOptions(opt_options));
              };
              TextFeature.prototype.writeFeaturesText = function(features, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              TextFeature.prototype.writeGeometry = function(geometry, opt_options) {
                return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
              };
              TextFeature.prototype.writeGeometryText = function(geometry, opt_options) {
                return Object(util[
                  "b"
                  /* abstract */
                ])();
              };
              return TextFeature;
            }(format_Feature)
          );
          function getText(source) {
            if (typeof source === "string") {
              return source;
            } else {
              return "";
            }
          }
          var format_TextFeature = TextFeature_TextFeature;
          var IGC_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var IGCZ = {
            BAROMETRIC: "barometric",
            GPS: "gps",
            NONE: "none"
          };
          var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
          var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
          var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
          var NEWLINE_RE = /\r\n|\r|\n/;
          var IGC_IGC = (
            /** @class */
            function(_super) {
              IGC_extends(IGC, _super);
              function IGC(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.dataProjection = proj_get("EPSG:4326");
                _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;
                return _this;
              }
              IGC.prototype.readFeatureFromText = function(text, opt_options) {
                var altitudeMode = this.altitudeMode_;
                var lines = text.split(NEWLINE_RE);
                var properties = {};
                var flatCoordinates = [];
                var year = 2e3;
                var month = 0;
                var day = 1;
                var lastDateTime = -1;
                var i, ii;
                for (i = 0, ii = lines.length; i < ii; ++i) {
                  var line = lines[i];
                  var m = void 0;
                  if (line.charAt(0) == "B") {
                    m = B_RECORD_RE.exec(line);
                    if (m) {
                      var hour = parseInt(m[1], 10);
                      var minute = parseInt(m[2], 10);
                      var second = parseInt(m[3], 10);
                      var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 6e4;
                      if (m[6] == "S") {
                        y = -y;
                      }
                      var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 6e4;
                      if (m[9] == "W") {
                        x = -x;
                      }
                      flatCoordinates.push(x, y);
                      if (altitudeMode != IGCZ.NONE) {
                        var z = void 0;
                        if (altitudeMode == IGCZ.GPS) {
                          z = parseInt(m[11], 10);
                        } else if (altitudeMode == IGCZ.BAROMETRIC) {
                          z = parseInt(m[12], 10);
                        } else {
                          z = 0;
                        }
                        flatCoordinates.push(z);
                      }
                      var dateTime = Date.UTC(year, month, day, hour, minute, second);
                      if (dateTime < lastDateTime) {
                        dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
                      }
                      flatCoordinates.push(dateTime / 1e3);
                      lastDateTime = dateTime;
                    }
                  } else if (line.charAt(0) == "H") {
                    m = HFDTE_RECORD_RE.exec(line);
                    if (m) {
                      day = parseInt(m[1], 10);
                      month = parseInt(m[2], 10) - 1;
                      year = 2e3 + parseInt(m[3], 10);
                    } else {
                      m = H_RECORD_RE.exec(line);
                      if (m) {
                        properties[m[1]] = m[2].trim();
                      }
                    }
                  }
                }
                if (flatCoordinates.length === 0) {
                  return null;
                }
                var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;
                var lineString = new geom_LineString(flatCoordinates, layout);
                var feature = new ol_Feature(transformGeometryWithOptions(lineString, false, opt_options));
                feature.setProperties(properties, true);
                return feature;
              };
              IGC.prototype.readFeaturesFromText = function(text, opt_options) {
                var feature = this.readFeatureFromText(text, opt_options);
                if (feature) {
                  return [feature];
                } else {
                  return [];
                }
              };
              return IGC;
            }(format_TextFeature)
          );
          var format_IGC = IGC_IGC;
          var __spreadArray = function(to, from) {
            for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
              to[j] = from[i];
            return to;
          };
          var Versions = {
            VERSION1: "version1",
            VERSION2: "version2",
            VERSION3: "version3"
          };
          var IIIF_PROFILE_VALUES = {};
          IIIF_PROFILE_VALUES[Versions.VERSION1] = {
            "level0": {
              supports: [],
              formats: [],
              qualities: ["native"]
            },
            "level1": {
              supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
              formats: ["jpg"],
              qualities: ["native"]
            },
            "level2": {
              supports: [
                "regionByPx",
                "regionByPct",
                "sizeByW",
                "sizeByH",
                "sizeByPct",
                "sizeByConfinedWh",
                "sizeByWh"
              ],
              formats: ["jpg", "png"],
              qualities: ["native", "color", "grey", "bitonal"]
            }
          };
          IIIF_PROFILE_VALUES[Versions.VERSION2] = {
            "level0": {
              supports: [],
              formats: ["jpg"],
              qualities: ["default"]
            },
            "level1": {
              supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
              formats: ["jpg"],
              qualities: ["default"]
            },
            "level2": {
              supports: [
                "regionByPx",
                "regionByPct",
                "sizeByW",
                "sizeByH",
                "sizeByPct",
                "sizeByConfinedWh",
                "sizeByDistortedWh",
                "sizeByWh"
              ],
              formats: ["jpg", "png"],
              qualities: ["default", "bitonal"]
            }
          };
          IIIF_PROFILE_VALUES[Versions.VERSION3] = {
            "level0": {
              supports: [],
              formats: ["jpg"],
              qualities: ["default"]
            },
            "level1": {
              supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
              formats: ["jpg"],
              qualities: ["default"]
            },
            "level2": {
              supports: [
                "regionByPx",
                "regionSquare",
                "regionByPct",
                "sizeByW",
                "sizeByH",
                "sizeByPct",
                "sizeByConfinedWh",
                "sizeByWh"
              ],
              formats: ["jpg", "png"],
              qualities: ["default"]
            }
          };
          IIIF_PROFILE_VALUES["none"] = {
            "none": {
              supports: [],
              formats: [],
              qualities: []
            }
          };
          var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
          var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
          var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
          function generateVersion1Options(iiifInfo) {
            var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
            if (levelProfile === void 0) {
              levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
            }
            return {
              url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
              supports: levelProfile.supports,
              formats: __spreadArray(__spreadArray([], levelProfile.formats), [
                iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
              ]),
              qualities: __spreadArray(__spreadArray([], levelProfile.qualities), [
                iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
              ]),
              resolutions: iiifInfo.imageInfo.scale_factors,
              tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
            };
          }
          function generateVersion2Options(iiifInfo) {
            var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
            return {
              url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
              sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
                return [size.width, size.height];
              }),
              tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
                iiifInfo.imageInfo.tiles.map(function(tile) {
                  return tile.width;
                })[0],
                iiifInfo.imageInfo.tiles.map(function(tile) {
                  return tile.height === void 0 ? tile.width : tile.height;
                })[0]
              ],
              resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.scaleFactors;
              })[0],
              supports: __spreadArray(__spreadArray([], levelProfile.supports), profileSupports),
              formats: __spreadArray(__spreadArray([], levelProfile.formats), profileFormats),
              qualities: __spreadArray(__spreadArray([], levelProfile.qualities), profileQualities)
            };
          }
          function generateVersion3Options(iiifInfo) {
            var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray(__spreadArray([], levelProfile.formats), iiifInfo.imageInfo.extraFormats), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format) {
              return Object(ol_array[
                "f"
                /* includes */
              ])(["jpg", "png", "gif"], format);
            }).reduce(function(acc, format) {
              return acc === void 0 && Object(ol_array[
                "f"
                /* includes */
              ])(formats, format) ? format : acc;
            }, void 0) : void 0;
            return {
              url: iiifInfo.imageInfo["id"],
              sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
                return [size.width, size.height];
              }),
              tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
                iiifInfo.imageInfo.tiles.map(function(tile) {
                  return tile.width;
                })[0],
                iiifInfo.imageInfo.tiles.map(function(tile) {
                  return tile.height;
                })[0]
              ],
              resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.scaleFactors;
              })[0],
              supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray(__spreadArray([], levelProfile.supports), iiifInfo.imageInfo.extraFeatures),
              formats,
              qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray(__spreadArray([], levelProfile.qualities), iiifInfo.imageInfo.extraQualities),
              preferredFormat
            };
          }
          var versionFunctions = {};
          versionFunctions[Versions.VERSION1] = generateVersion1Options;
          versionFunctions[Versions.VERSION2] = generateVersion2Options;
          versionFunctions[Versions.VERSION3] = generateVersion3Options;
          var IIIFInfo_IIIFInfo = (
            /** @class */
            function() {
              function IIIFInfo(imageInfo) {
                this.setImageInfo(imageInfo);
              }
              IIIFInfo.prototype.setImageInfo = function(imageInfo) {
                if (typeof imageInfo == "string") {
                  this.imageInfo = JSON.parse(imageInfo);
                } else {
                  this.imageInfo = imageInfo;
                }
              };
              IIIFInfo.prototype.getImageApiVersion = function() {
                if (this.imageInfo === void 0) {
                  return;
                }
                var context = this.imageInfo["@context"] || "ol-no-context";
                if (typeof context == "string") {
                  context = [context];
                }
                for (var i = 0; i < context.length; i++) {
                  switch (context[i]) {
                    case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    case "http://iiif.io/api/image/1/context.json":
                      return Versions.VERSION1;
                    case "http://iiif.io/api/image/2/context.json":
                      return Versions.VERSION2;
                    case "http://iiif.io/api/image/3/context.json":
                      return Versions.VERSION3;
                    case "ol-no-context":
                      if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
                        return Versions.VERSION1;
                      }
                      break;
                    default:
                  }
                }
                assert2(false, 61);
              };
              IIIFInfo.prototype.getComplianceLevelEntryFromProfile = function(version) {
                if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
                  return;
                }
                if (version === void 0) {
                  version = this.getImageApiVersion();
                }
                switch (version) {
                  case Versions.VERSION1:
                    if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
                      return this.imageInfo.profile;
                    }
                    break;
                  case Versions.VERSION3:
                    if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
                      return this.imageInfo.profile;
                    }
                    break;
                  case Versions.VERSION2:
                    if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
                      return this.imageInfo.profile;
                    }
                    if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
                      return this.imageInfo.profile[0];
                    }
                    break;
                  default:
                }
              };
              IIIFInfo.prototype.getComplianceLevelFromProfile = function(version) {
                var complianceLevel = this.getComplianceLevelEntryFromProfile(version);
                if (complianceLevel === void 0) {
                  return void 0;
                }
                var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
                return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
              };
              IIIFInfo.prototype.getComplianceLevelSupportedFeatures = function() {
                if (this.imageInfo === void 0) {
                  return;
                }
                var version = this.getImageApiVersion();
                var level = this.getComplianceLevelFromProfile(version);
                if (level === void 0) {
                  return IIIF_PROFILE_VALUES["none"]["none"];
                }
                return IIIF_PROFILE_VALUES[version][level];
              };
              IIIFInfo.prototype.getTileSourceOptions = function(opt_preferredOptions) {
                var options = opt_preferredOptions || {}, version = this.getImageApiVersion();
                if (version === void 0) {
                  return;
                }
                var imageOptions = version === void 0 ? void 0 : versionFunctions[version](this);
                if (imageOptions === void 0) {
                  return;
                }
                return {
                  url: imageOptions.url,
                  version,
                  size: [this.imageInfo.width, this.imageInfo.height],
                  sizes: imageOptions.sizes,
                  format: options.format !== void 0 && Object(ol_array[
                    "f"
                    /* includes */
                  ])(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
                  supports: imageOptions.supports,
                  quality: options.quality && Object(ol_array[
                    "f"
                    /* includes */
                  ])(imageOptions.qualities, options.quality) ? options.quality : Object(ol_array[
                    "f"
                    /* includes */
                  ])(imageOptions.qualities, "native") ? "native" : "default",
                  resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a, b) {
                    return b - a;
                  }) : void 0,
                  tileSize: imageOptions.tileSize
                };
              };
              return IIIFInfo;
            }()
          );
          var format_IIIFInfo = IIIFInfo_IIIFInfo;
          var KML_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
          var KML_NAMESPACE_URIS = [
            null,
            "http://earth.google.com/kml/2.0",
            "http://earth.google.com/kml/2.1",
            "http://earth.google.com/kml/2.2",
            "http://www.opengis.net/kml/2.2"
          ];
          var KML_SCHEMA_LOCATION = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
          var ICON_ANCHOR_UNITS_MAP = {
            "fraction": IconAnchorUnits.FRACTION,
            "pixels": IconAnchorUnits.PIXELS,
            "insetPixels": IconAnchorUnits.PIXELS
          };
          var PLACEMARK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "ExtendedData": extendedDataParser,
            "Region": regionParser,
            "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
            "LineString": makeObjectPropertySetter(readLineString, "geometry"),
            "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
            "Point": makeObjectPropertySetter(readPoint, "geometry"),
            "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
            "Style": makeObjectPropertySetter(readStyle),
            "StyleMap": placemarkStyleMapParser,
            "address": makeObjectPropertySetter(readString),
            "description": makeObjectPropertySetter(readString),
            "name": makeObjectPropertySetter(readString),
            "open": makeObjectPropertySetter(readBoolean),
            "phoneNumber": makeObjectPropertySetter(readString),
            "styleUrl": makeObjectPropertySetter(readStyleURL),
            "visibility": makeObjectPropertySetter(readBoolean)
          }, makeStructureNS(GX_NAMESPACE_URIS, {
            "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
            "Track": makeObjectPropertySetter(readGxTrack, "geometry")
          }));
          var NETWORK_LINK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "ExtendedData": extendedDataParser,
            "Region": regionParser,
            "Link": linkParser,
            "address": makeObjectPropertySetter(readString),
            "description": makeObjectPropertySetter(readString),
            "name": makeObjectPropertySetter(readString),
            "open": makeObjectPropertySetter(readBoolean),
            "phoneNumber": makeObjectPropertySetter(readString),
            "visibility": makeObjectPropertySetter(readBoolean)
          });
          var KML_LINK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "href": makeObjectPropertySetter(readURI)
          });
          var REGION_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "LatLonAltBox": latLonAltBoxParser,
            "Lod": lodParser
          });
          var KML_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["Document", "Placemark"]);
          var KML_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Document": makeChildAppender(writeDocument),
            "Placemark": makeChildAppender(writePlacemark)
          });
          var DEFAULT_COLOR;
          var DEFAULT_FILL_STYLE = null;
          function getDefaultFillStyle() {
            return DEFAULT_FILL_STYLE;
          }
          var DEFAULT_IMAGE_STYLE_ANCHOR;
          var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
          var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
          var DEFAULT_IMAGE_STYLE_SIZE;
          var DEFAULT_IMAGE_STYLE_SRC;
          var DEFAULT_IMAGE_SCALE_MULTIPLIER;
          var DEFAULT_IMAGE_STYLE = null;
          function getDefaultImageStyle() {
            return DEFAULT_IMAGE_STYLE;
          }
          var DEFAULT_NO_IMAGE_STYLE;
          var DEFAULT_STROKE_STYLE = null;
          function getDefaultStrokeStyle() {
            return DEFAULT_STROKE_STYLE;
          }
          var DEFAULT_TEXT_STROKE_STYLE;
          var DEFAULT_TEXT_STYLE = null;
          function getDefaultTextStyle() {
            return DEFAULT_TEXT_STYLE;
          }
          var DEFAULT_STYLE = null;
          function getDefaultStyle() {
            return DEFAULT_STYLE;
          }
          var DEFAULT_STYLE_ARRAY = null;
          function getDefaultStyleArray() {
            return DEFAULT_STYLE_ARRAY;
          }
          function createStyleDefaults() {
            DEFAULT_COLOR = [255, 255, 255, 1];
            DEFAULT_FILL_STYLE = new style_Fill({
              color: DEFAULT_COLOR
            });
            DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
            DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits.PIXELS;
            DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits.PIXELS;
            DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
            DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
            DEFAULT_IMAGE_SCALE_MULTIPLIER = 0.5;
            DEFAULT_IMAGE_STYLE = new style_Icon({
              anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
              anchorOrigin: IconOrigin.BOTTOM_LEFT,
              anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
              anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
              crossOrigin: "anonymous",
              rotation: 0,
              scale: DEFAULT_IMAGE_SCALE_MULTIPLIER,
              size: DEFAULT_IMAGE_STYLE_SIZE,
              src: DEFAULT_IMAGE_STYLE_SRC
            });
            DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
            DEFAULT_STROKE_STYLE = new style_Stroke({
              color: DEFAULT_COLOR,
              width: 1
            });
            DEFAULT_TEXT_STROKE_STYLE = new style_Stroke({
              color: [51, 51, 51, 1],
              width: 2
            });
            DEFAULT_TEXT_STYLE = new style_Text({
              font: "bold 16px Helvetica",
              fill: DEFAULT_FILL_STYLE,
              stroke: DEFAULT_TEXT_STROKE_STYLE,
              scale: 0.8
            });
            DEFAULT_STYLE = new style_Style({
              fill: DEFAULT_FILL_STYLE,
              image: DEFAULT_IMAGE_STYLE,
              text: DEFAULT_TEXT_STYLE,
              stroke: DEFAULT_STROKE_STYLE,
              zIndex: 0
            });
            DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
          }
          var TEXTAREA;
          function defaultIconUrlFunction(href) {
            return href;
          }
          var KML_KML = (
            /** @class */
            function(_super) {
              KML_extends(KML, _super);
              function KML(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                if (!DEFAULT_STYLE_ARRAY) {
                  createStyleDefaults();
                }
                _this.dataProjection = proj_get("EPSG:4326");
                _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
                _this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
                _this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
                _this.sharedStyles_ = {};
                _this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
                _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
                _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
                return _this;
              }
              KML.prototype.readDocumentOrFolder_ = function(node, objectStack) {
                var parsersNS = makeStructureNS(KML_NAMESPACE_URIS, {
                  "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
                  "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
                  "Placemark": makeArrayPusher(this.readPlacemark_, this),
                  "Style": this.readSharedStyle_.bind(this),
                  "StyleMap": this.readSharedStyleMap_.bind(this)
                });
                var features = pushParseAndPop([], parsersNS, node, objectStack, this);
                if (features) {
                  return features;
                } else {
                  return void 0;
                }
              };
              KML.prototype.readPlacemark_ = function(node, objectStack) {
                var object = pushParseAndPop({ "geometry": null }, PLACEMARK_PARSERS, node, objectStack, this);
                if (!object) {
                  return void 0;
                }
                var feature = new ol_Feature();
                var id = node.getAttribute("id");
                if (id !== null) {
                  feature.setId(id);
                }
                var options = (
                  /** @type {import("./Feature.js").ReadOptions} */
                  objectStack[0]
                );
                var geometry = object["geometry"];
                if (geometry) {
                  transformGeometryWithOptions(geometry, false, options);
                }
                feature.setGeometry(geometry);
                delete object["geometry"];
                if (this.extractStyles_) {
                  var style = object["Style"];
                  var styleUrl = object["styleUrl"];
                  var styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
                  feature.setStyle(styleFunction);
                }
                delete object["Style"];
                feature.setProperties(object, true);
                return feature;
              };
              KML.prototype.readSharedStyle_ = function(node, objectStack) {
                var id = node.getAttribute("id");
                if (id !== null) {
                  var style = readStyle.call(this, node, objectStack);
                  if (style) {
                    var styleUri = void 0;
                    var baseURI = node.baseURI;
                    if (!baseURI || baseURI == "about:blank") {
                      baseURI = window.location.href;
                    }
                    if (baseURI) {
                      var url = new URL("#" + id, baseURI);
                      styleUri = url.href;
                    } else {
                      styleUri = "#" + id;
                    }
                    this.sharedStyles_[styleUri] = style;
                  }
                }
              };
              KML.prototype.readSharedStyleMap_ = function(node, objectStack) {
                var id = node.getAttribute("id");
                if (id === null) {
                  return;
                }
                var styleMapValue = readStyleMapValue.call(this, node, objectStack);
                if (!styleMapValue) {
                  return;
                }
                var styleUri;
                var baseURI = node.baseURI;
                if (!baseURI || baseURI == "about:blank") {
                  baseURI = window.location.href;
                }
                if (baseURI) {
                  var url = new URL("#" + id, baseURI);
                  styleUri = url.href;
                } else {
                  styleUri = "#" + id;
                }
                this.sharedStyles_[styleUri] = styleMapValue;
              };
              KML.prototype.readFeatureFromNode = function(node, opt_options) {
                if (!Object(ol_array[
                  "f"
                  /* includes */
                ])(KML_NAMESPACE_URIS, node.namespaceURI)) {
                  return null;
                }
                var feature = this.readPlacemark_(node, [
                  this.getReadOptions(node, opt_options)
                ]);
                if (feature) {
                  return feature;
                } else {
                  return null;
                }
              };
              KML.prototype.readFeaturesFromNode = function(node, opt_options) {
                if (!Object(ol_array[
                  "f"
                  /* includes */
                ])(KML_NAMESPACE_URIS, node.namespaceURI)) {
                  return [];
                }
                var features;
                var localName = node.localName;
                if (localName == "Document" || localName == "Folder") {
                  features = this.readDocumentOrFolder_(node, [
                    this.getReadOptions(node, opt_options)
                  ]);
                  if (features) {
                    return features;
                  } else {
                    return [];
                  }
                } else if (localName == "Placemark") {
                  var feature = this.readPlacemark_(node, [
                    this.getReadOptions(node, opt_options)
                  ]);
                  if (feature) {
                    return [feature];
                  } else {
                    return [];
                  }
                } else if (localName == "kml") {
                  features = [];
                  for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                    var fs = this.readFeaturesFromNode(n, opt_options);
                    if (fs) {
                      Object(ol_array[
                        "c"
                        /* extend */
                      ])(features, fs);
                    }
                  }
                  return features;
                } else {
                  return [];
                }
              };
              KML.prototype.readName = function(source) {
                if (!source) {
                  return void 0;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readNameFromDocument(doc);
                } else if (isDocument(source)) {
                  return this.readNameFromDocument(
                    /** @type {Document} */
                    source
                  );
                } else {
                  return this.readNameFromNode(
                    /** @type {Element} */
                    source
                  );
                }
              };
              KML.prototype.readNameFromDocument = function(doc) {
                for (var n = (
                  /** @type {Node} */
                  doc.firstChild
                ); n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    var name_1 = this.readNameFromNode(
                      /** @type {Element} */
                      n
                    );
                    if (name_1) {
                      return name_1;
                    }
                  }
                }
                return void 0;
              };
              KML.prototype.readNameFromNode = function(node) {
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "name") {
                    return readString(n);
                  }
                }
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  var localName = n.localName;
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
                    var name_2 = this.readNameFromNode(n);
                    if (name_2) {
                      return name_2;
                    }
                  }
                }
                return void 0;
              };
              KML.prototype.readNetworkLinks = function(source) {
                var networkLinks = [];
                if (typeof source === "string") {
                  var doc = parse2(source);
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(networkLinks, this.readNetworkLinksFromDocument(doc));
                } else if (isDocument(source)) {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(networkLinks, this.readNetworkLinksFromDocument(
                    /** @type {Document} */
                    source
                  ));
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(networkLinks, this.readNetworkLinksFromNode(
                    /** @type {Element} */
                    source
                  ));
                }
                return networkLinks;
              };
              KML.prototype.readNetworkLinksFromDocument = function(doc) {
                var networkLinks = [];
                for (var n = (
                  /** @type {Node} */
                  doc.firstChild
                ); n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(networkLinks, this.readNetworkLinksFromNode(
                      /** @type {Element} */
                      n
                    ));
                  }
                }
                return networkLinks;
              };
              KML.prototype.readNetworkLinksFromNode = function(node) {
                var networkLinks = [];
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "NetworkLink") {
                    var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);
                    networkLinks.push(obj);
                  }
                }
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  var localName = n.localName;
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(networkLinks, this.readNetworkLinksFromNode(n));
                  }
                }
                return networkLinks;
              };
              KML.prototype.readRegion = function(source) {
                var regions = [];
                if (typeof source === "string") {
                  var doc = parse2(source);
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(regions, this.readRegionFromDocument(doc));
                } else if (isDocument(source)) {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(regions, this.readRegionFromDocument(
                    /** @type {Document} */
                    source
                  ));
                } else {
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(regions, this.readRegionFromNode(
                    /** @type {Element} */
                    source
                  ));
                }
                return regions;
              };
              KML.prototype.readRegionFromDocument = function(doc) {
                var regions = [];
                for (var n = (
                  /** @type {Node} */
                  doc.firstChild
                ); n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(regions, this.readRegionFromNode(
                      /** @type {Element} */
                      n
                    ));
                  }
                }
                return regions;
              };
              KML.prototype.readRegionFromNode = function(node) {
                var regions = [];
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "Region") {
                    var obj = pushParseAndPop({}, REGION_PARSERS, n, []);
                    regions.push(obj);
                  }
                }
                for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                  var localName = n.localName;
                  if (Object(ol_array[
                    "f"
                    /* includes */
                  ])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(regions, this.readRegionFromNode(n));
                  }
                }
                return regions;
              };
              KML.prototype.writeFeaturesNode = function(features, opt_options) {
                opt_options = this.adaptOptions(opt_options);
                var kml = createElementNS(KML_NAMESPACE_URIS[4], "kml");
                var xmlnsUri = "http://www.w3.org/2000/xmlns/";
                kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
                kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
                kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", KML_SCHEMA_LOCATION);
                var context = {
                  node: kml
                };
                var properties = {};
                if (features.length > 1) {
                  properties["Document"] = features;
                } else if (features.length == 1) {
                  properties["Placemark"] = features[0];
                }
                var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
                var values = makeSequence(properties, orderedKeys);
                pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
                return kml;
              };
              return KML;
            }(format_XMLFeature)
          );
          function createNameStyleFunction(foundStyle, name) {
            var textOffset = [0, 0];
            var textAlign = "start";
            var imageStyle = foundStyle.getImage();
            if (imageStyle) {
              var imageSize = imageStyle.getImageSize();
              if (imageSize === null) {
                imageSize = DEFAULT_IMAGE_STYLE_SIZE;
              }
              if (imageSize.length == 2) {
                var imageScale = imageStyle.getScaleArray();
                textOffset[0] = imageScale[0] * imageSize[0] / 2;
                textOffset[1] = -imageScale[1] * imageSize[1] / 2;
                textAlign = "left";
              }
            }
            var textStyle = foundStyle.getText();
            if (textStyle) {
              textStyle = textStyle.clone();
              textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
              textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
              textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
              textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
            } else {
              textStyle = DEFAULT_TEXT_STYLE.clone();
            }
            textStyle.setText(name);
            textStyle.setOffsetX(textOffset[0]);
            textStyle.setOffsetY(textOffset[1]);
            textStyle.setTextAlign(textAlign);
            var nameStyle = new style_Style({
              image: imageStyle,
              text: textStyle
            });
            return nameStyle;
          }
          function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
            return (
              /**
               * @param {Feature} feature feature.
               * @param {number} resolution Resolution.
               * @return {Array<Style>|Style} Style.
               */
              function(feature, resolution) {
                var drawName = showPointNames;
                var name = "";
                var multiGeometryPoints = [];
                if (drawName) {
                  var geometry = feature.getGeometry();
                  if (geometry) {
                    var type = geometry.getType();
                    if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                      multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
                        var type2 = geometry2.getType();
                        return type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.MULTI_POINT;
                      });
                      drawName = multiGeometryPoints.length > 0;
                    } else {
                      drawName = type === geom_GeometryType.POINT || type === geom_GeometryType.MULTI_POINT;
                    }
                  }
                }
                if (drawName) {
                  name = /** @type {string} */
                  feature.get("name");
                  drawName = drawName && !!name;
                  if (drawName && name.search(/&[^&]+;/) > -1) {
                    if (!TEXTAREA) {
                      TEXTAREA = document.createElement("textarea");
                    }
                    TEXTAREA.innerHTML = name;
                    name = TEXTAREA.value;
                  }
                }
                var featureStyle = defaultStyle;
                if (style) {
                  featureStyle = style;
                } else if (styleUrl) {
                  featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
                }
                if (drawName) {
                  var nameStyle = createNameStyleFunction(featureStyle[0], name);
                  if (multiGeometryPoints.length > 0) {
                    nameStyle.setGeometry(new geom_GeometryCollection(multiGeometryPoints));
                    var baseStyle = new style_Style({
                      geometry: featureStyle[0].getGeometry(),
                      image: null,
                      fill: featureStyle[0].getFill(),
                      stroke: featureStyle[0].getStroke(),
                      text: null
                    });
                    return [nameStyle, baseStyle].concat(featureStyle.slice(1));
                  }
                  return nameStyle;
                }
                return featureStyle;
              }
            );
          }
          function findStyle(styleValue, defaultStyle, sharedStyles) {
            if (Array.isArray(styleValue)) {
              return styleValue;
            } else if (typeof styleValue === "string") {
              return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
            } else {
              return defaultStyle;
            }
          }
          function readColor(node) {
            var s = getAllTextContent(node, false);
            var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
            if (m) {
              var hexColor = m[1];
              return [
                parseInt(hexColor.substr(6, 2), 16),
                parseInt(hexColor.substr(4, 2), 16),
                parseInt(hexColor.substr(2, 2), 16),
                parseInt(hexColor.substr(0, 2), 16) / 255
              ];
            } else {
              return void 0;
            }
          }
          function readFlatCoordinates(node) {
            var s = getAllTextContent(node, false);
            var flatCoordinates = [];
            s = s.replace(/\s*,\s*/g, ",");
            var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
            var m;
            while (m = re.exec(s)) {
              var x = parseFloat(m[1]);
              var y = parseFloat(m[2]);
              var z = m[3] ? parseFloat(m[3]) : 0;
              flatCoordinates.push(x, y, z);
              s = s.substr(m[0].length);
            }
            if (s !== "") {
              return void 0;
            }
            return flatCoordinates;
          }
          function readURI(node) {
            var s = getAllTextContent(node, false).trim();
            var baseURI = node.baseURI;
            if (!baseURI || baseURI == "about:blank") {
              baseURI = window.location.href;
            }
            if (baseURI) {
              var url = new URL(s, baseURI);
              return url.href;
            } else {
              return s;
            }
          }
          function readStyleURL(node) {
            var s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, "#");
            var baseURI = node.baseURI;
            if (!baseURI || baseURI == "about:blank") {
              baseURI = window.location.href;
            }
            if (baseURI) {
              var url = new URL(s, baseURI);
              return url.href;
            } else {
              return s;
            }
          }
          function readVec2(node) {
            var xunits = node.getAttribute("xunits");
            var yunits = node.getAttribute("yunits");
            var origin;
            if (xunits !== "insetPixels") {
              if (yunits !== "insetPixels") {
                origin = IconOrigin.BOTTOM_LEFT;
              } else {
                origin = IconOrigin.TOP_LEFT;
              }
            } else {
              if (yunits !== "insetPixels") {
                origin = IconOrigin.BOTTOM_RIGHT;
              } else {
                origin = IconOrigin.TOP_RIGHT;
              }
            }
            return {
              x: parseFloat(node.getAttribute("x")),
              xunits: ICON_ANCHOR_UNITS_MAP[xunits],
              y: parseFloat(node.getAttribute("y")),
              yunits: ICON_ANCHOR_UNITS_MAP[yunits],
              origin
            };
          }
          function readScale(node) {
            return readDecimal(node);
          }
          var STYLE_MAP_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Pair": pairDataParser
          });
          function readStyleMapValue(node, objectStack) {
            return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node, objectStack, this);
          }
          var ICON_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Icon": makeObjectPropertySetter(readIcon),
            "color": makeObjectPropertySetter(readColor),
            "heading": makeObjectPropertySetter(readDecimal),
            "hotSpot": makeObjectPropertySetter(readVec2),
            "scale": makeObjectPropertySetter(readScale)
          });
          function iconStyleParser(node, objectStack) {
            var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var styleObject = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var IconObject = "Icon" in object ? object["Icon"] : {};
            var drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
            var src;
            var href = (
              /** @type {string|undefined} */
              IconObject["href"]
            );
            if (href) {
              src = href;
            } else if (drawIcon) {
              src = DEFAULT_IMAGE_STYLE_SRC;
            }
            var anchor, anchorXUnits, anchorYUnits;
            var anchorOrigin = IconOrigin.BOTTOM_LEFT;
            var hotSpot = (
              /** @type {Vec2|undefined} */
              object["hotSpot"]
            );
            if (hotSpot) {
              anchor = [hotSpot.x, hotSpot.y];
              anchorXUnits = hotSpot.xunits;
              anchorYUnits = hotSpot.yunits;
              anchorOrigin = hotSpot.origin;
            } else if (src === DEFAULT_IMAGE_STYLE_SRC) {
              anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
              anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
              anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
            } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
              anchor = [0.5, 0];
              anchorXUnits = IconAnchorUnits.FRACTION;
              anchorYUnits = IconAnchorUnits.FRACTION;
            }
            var offset;
            var x = (
              /** @type {number|undefined} */
              IconObject["x"]
            );
            var y = (
              /** @type {number|undefined} */
              IconObject["y"]
            );
            if (x !== void 0 && y !== void 0) {
              offset = [x, y];
            }
            var size;
            var w = (
              /** @type {number|undefined} */
              IconObject["w"]
            );
            var h = (
              /** @type {number|undefined} */
              IconObject["h"]
            );
            if (w !== void 0 && h !== void 0) {
              size = [w, h];
            }
            var rotation;
            var heading = (
              /** @type {number} */
              object["heading"]
            );
            if (heading !== void 0) {
              rotation = toRadians(heading);
            }
            var scale = (
              /** @type {number|undefined} */
              object["scale"]
            );
            var color = (
              /** @type {Array<number>|undefined} */
              object["color"]
            );
            if (drawIcon) {
              if (src == DEFAULT_IMAGE_STYLE_SRC) {
                size = DEFAULT_IMAGE_STYLE_SIZE;
                if (scale === void 0) {
                  scale = DEFAULT_IMAGE_SCALE_MULTIPLIER;
                }
              }
              var imageStyle = new style_Icon({
                anchor,
                anchorOrigin,
                anchorXUnits,
                anchorYUnits,
                crossOrigin: this.crossOrigin_,
                offset,
                offsetOrigin: IconOrigin.BOTTOM_LEFT,
                rotation,
                scale,
                size,
                src: this.iconUrlFunction_(src),
                color
              });
              styleObject["imageStyle"] = imageStyle;
            } else {
              styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
            }
          }
          var LABEL_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeObjectPropertySetter(readColor),
            "scale": makeObjectPropertySetter(readScale)
          });
          function labelStyleParser(node, objectStack) {
            var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var styleObject = objectStack[objectStack.length - 1];
            var textStyle = new style_Text({
              fill: new style_Fill({
                color: (
                  /** @type {import("../color.js").Color} */
                  "color" in object ? object["color"] : DEFAULT_COLOR
                )
              }),
              scale: (
                /** @type {number|undefined} */
                object["scale"]
              )
            });
            styleObject["textStyle"] = textStyle;
          }
          var LINE_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeObjectPropertySetter(readColor),
            "width": makeObjectPropertySetter(readDecimal)
          });
          function lineStyleParser(node, objectStack) {
            var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var styleObject = objectStack[objectStack.length - 1];
            var strokeStyle = new style_Stroke({
              color: (
                /** @type {import("../color.js").Color} */
                "color" in object ? object["color"] : DEFAULT_COLOR
              ),
              width: (
                /** @type {number} */
                "width" in object ? object["width"] : 1
              )
            });
            styleObject["strokeStyle"] = strokeStyle;
          }
          var POLY_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeObjectPropertySetter(readColor),
            "fill": makeObjectPropertySetter(readBoolean),
            "outline": makeObjectPropertySetter(readBoolean)
          });
          function polyStyleParser(node, objectStack) {
            var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var styleObject = objectStack[objectStack.length - 1];
            var fillStyle = new style_Fill({
              color: (
                /** @type {import("../color.js").Color} */
                "color" in object ? object["color"] : DEFAULT_COLOR
              )
            });
            styleObject["fillStyle"] = fillStyle;
            var fill = (
              /** @type {boolean|undefined} */
              object["fill"]
            );
            if (fill !== void 0) {
              styleObject["fill"] = fill;
            }
            var outline = (
              /** @type {boolean|undefined} */
              object["outline"]
            );
            if (outline !== void 0) {
              styleObject["outline"] = outline;
            }
          }
          var FLAT_LINEAR_RING_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "coordinates": makeReplacer(readFlatCoordinates)
          });
          function readFlatLinearRing(node, objectStack) {
            return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
          }
          function gxCoordParser(node, objectStack) {
            var gxTrackObject = (
              /** @type {GxTrackObject} */
              objectStack[objectStack.length - 1]
            );
            var coordinates = gxTrackObject.coordinates;
            var s = getAllTextContent(node, false);
            var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
            var m = re.exec(s);
            if (m) {
              var x = parseFloat(m[1]);
              var y = parseFloat(m[2]);
              var z = parseFloat(m[3]);
              coordinates.push([x, y, z]);
            } else {
              coordinates.push([]);
            }
          }
          var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
            "Track": makeArrayPusher(readGxTrack)
          });
          function readGxMultiTrack(node, objectStack) {
            var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
            if (!lineStrings) {
              return void 0;
            }
            return new geom_MultiLineString(lineStrings);
          }
          var GX_TRACK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "when": whenParser
          }, makeStructureNS(GX_NAMESPACE_URIS, {
            "coord": gxCoordParser
          }));
          function readGxTrack(node, objectStack) {
            var gxTrackObject = pushParseAndPop(
              /** @type {GxTrackObject} */
              {
                coordinates: [],
                whens: []
              },
              GX_TRACK_PARSERS,
              node,
              objectStack
            );
            if (!gxTrackObject) {
              return void 0;
            }
            var flatCoordinates = [];
            var coordinates = gxTrackObject.coordinates;
            var whens = gxTrackObject.whens;
            for (var i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {
              if (coordinates[i].length == 3) {
                flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);
              }
            }
            return new geom_LineString(flatCoordinates, GeometryLayout.XYZM);
          }
          var ICON_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "href": makeObjectPropertySetter(readURI)
          }, makeStructureNS(GX_NAMESPACE_URIS, {
            "x": makeObjectPropertySetter(readDecimal),
            "y": makeObjectPropertySetter(readDecimal),
            "w": makeObjectPropertySetter(readDecimal),
            "h": makeObjectPropertySetter(readDecimal)
          }));
          function readIcon(node, objectStack) {
            var iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);
            if (iconObject) {
              return iconObject;
            } else {
              return null;
            }
          }
          var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "coordinates": makeReplacer(readFlatCoordinates)
          });
          function readFlatCoordinatesFromNode(node, objectStack) {
            return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
          }
          var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "extrude": makeObjectPropertySetter(readBoolean),
            "tessellate": makeObjectPropertySetter(readBoolean),
            "altitudeMode": makeObjectPropertySetter(readString)
          });
          function readLineString(node, objectStack) {
            var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
            var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
              lineString.setProperties(properties, true);
              return lineString;
            } else {
              return void 0;
            }
          }
          function readLinearRing(node, objectStack) {
            var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
            var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              var polygon = new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, [
                flatCoordinates.length
              ]);
              polygon.setProperties(properties, true);
              return polygon;
            } else {
              return void 0;
            }
          }
          var MULTI_GEOMETRY_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "LineString": makeArrayPusher(readLineString),
            "LinearRing": makeArrayPusher(readLinearRing),
            "MultiGeometry": makeArrayPusher(readMultiGeometry),
            "Point": makeArrayPusher(readPoint),
            "Polygon": makeArrayPusher(readPolygon)
          });
          function readMultiGeometry(node, objectStack) {
            var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);
            if (!geometries) {
              return null;
            }
            if (geometries.length === 0) {
              return new geom_GeometryCollection(geometries);
            }
            var multiGeometry;
            var homogeneous = true;
            var type = geometries[0].getType();
            var geometry;
            for (var i = 1, ii = geometries.length; i < ii; ++i) {
              geometry = geometries[i];
              if (geometry.getType() != type) {
                homogeneous = false;
                break;
              }
            }
            if (homogeneous) {
              var layout = void 0;
              var flatCoordinates = void 0;
              if (type == geom_GeometryType.POINT) {
                var point = geometries[0];
                layout = point.getLayout();
                flatCoordinates = point.getFlatCoordinates();
                for (var i = 1, ii = geometries.length; i < ii; ++i) {
                  geometry = geometries[i];
                  Object(ol_array[
                    "c"
                    /* extend */
                  ])(flatCoordinates, geometry.getFlatCoordinates());
                }
                multiGeometry = new geom_MultiPoint(flatCoordinates, layout);
                setCommonGeometryProperties(multiGeometry, geometries);
              } else if (type == geom_GeometryType.LINE_STRING) {
                multiGeometry = new geom_MultiLineString(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
              } else if (type == geom_GeometryType.POLYGON) {
                multiGeometry = new geom_MultiPolygon(geometries);
                setCommonGeometryProperties(multiGeometry, geometries);
              } else if (type == geom_GeometryType.GEOMETRY_COLLECTION) {
                multiGeometry = new geom_GeometryCollection(geometries);
              } else {
                assert2(false, 37);
              }
            } else {
              multiGeometry = new geom_GeometryCollection(geometries);
            }
            return (
              /** @type {import("../geom/Geometry.js").default} */
              multiGeometry
            );
          }
          function readPoint(node, objectStack) {
            var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
            var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              var point = new geom_Point(flatCoordinates, GeometryLayout.XYZ);
              point.setProperties(properties, true);
              return point;
            } else {
              return void 0;
            }
          }
          var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "innerBoundaryIs": innerBoundaryIsParser,
            "outerBoundaryIs": outerBoundaryIsParser
          });
          function readPolygon(node, objectStack) {
            var properties = pushParseAndPop(
              /** @type {Object<string,*>} */
              {},
              EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
              node,
              objectStack
            );
            var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
            if (flatLinearRings && flatLinearRings[0]) {
              var flatCoordinates = flatLinearRings[0];
              var ends = [flatCoordinates.length];
              for (var i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                Object(ol_array[
                  "c"
                  /* extend */
                ])(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
              }
              var polygon = new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
              polygon.setProperties(properties, true);
              return polygon;
            } else {
              return void 0;
            }
          }
          var STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "IconStyle": iconStyleParser,
            "LabelStyle": labelStyleParser,
            "LineStyle": lineStyleParser,
            "PolyStyle": polyStyleParser
          });
          function readStyle(node, objectStack) {
            var styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);
            if (!styleObject) {
              return null;
            }
            var fillStyle = (
              /** @type {Fill} */
              "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE
            );
            var fill = (
              /** @type {boolean|undefined} */
              styleObject["fill"]
            );
            if (fill !== void 0 && !fill) {
              fillStyle = null;
            }
            var imageStyle;
            if ("imageStyle" in styleObject) {
              if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
                imageStyle = styleObject["imageStyle"];
              }
            } else {
              imageStyle = DEFAULT_IMAGE_STYLE;
            }
            var textStyle = (
              /** @type {Text} */
              "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE
            );
            var strokeStyle = (
              /** @type {Stroke} */
              "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE
            );
            var outline = (
              /** @type {boolean|undefined} */
              styleObject["outline"]
            );
            if (outline !== void 0 && !outline) {
              return [
                new style_Style({
                  geometry: function(feature) {
                    var geometry = feature.getGeometry();
                    var type = geometry.getType();
                    if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                      return new geom_GeometryCollection(geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
                        var type2 = geometry2.getType();
                        return type2 !== geom_GeometryType.POLYGON && type2 !== geom_GeometryType.MULTI_POLYGON;
                      }));
                    } else if (type !== geom_GeometryType.POLYGON && type !== geom_GeometryType.MULTI_POLYGON) {
                      return geometry;
                    }
                  },
                  fill: fillStyle,
                  image: imageStyle,
                  stroke: strokeStyle,
                  text: textStyle,
                  zIndex: void 0
                  // FIXME
                }),
                new style_Style({
                  geometry: function(feature) {
                    var geometry = feature.getGeometry();
                    var type = geometry.getType();
                    if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                      return new geom_GeometryCollection(geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
                        var type2 = geometry2.getType();
                        return type2 === geom_GeometryType.POLYGON || type2 === geom_GeometryType.MULTI_POLYGON;
                      }));
                    } else if (type === geom_GeometryType.POLYGON || type === geom_GeometryType.MULTI_POLYGON) {
                      return geometry;
                    }
                  },
                  fill: fillStyle,
                  stroke: null,
                  zIndex: void 0
                  // FIXME
                })
              ];
            }
            return [
              new style_Style({
                fill: fillStyle,
                image: imageStyle,
                stroke: strokeStyle,
                text: textStyle,
                zIndex: void 0
                // FIXME
              })
            ];
          }
          function setCommonGeometryProperties(multiGeometry, geometries) {
            var ii = geometries.length;
            var extrudes = new Array(geometries.length);
            var tessellates = new Array(geometries.length);
            var altitudeModes = new Array(geometries.length);
            var hasExtrude, hasTessellate, hasAltitudeMode;
            hasExtrude = false;
            hasTessellate = false;
            hasAltitudeMode = false;
            for (var i = 0; i < ii; ++i) {
              var geometry = geometries[i];
              extrudes[i] = geometry.get("extrude");
              tessellates[i] = geometry.get("tessellate");
              altitudeModes[i] = geometry.get("altitudeMode");
              hasExtrude = hasExtrude || extrudes[i] !== void 0;
              hasTessellate = hasTessellate || tessellates[i] !== void 0;
              hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
            }
            if (hasExtrude) {
              multiGeometry.set("extrude", extrudes);
            }
            if (hasTessellate) {
              multiGeometry.set("tessellate", tessellates);
            }
            if (hasAltitudeMode) {
              multiGeometry.set("altitudeMode", altitudeModes);
            }
          }
          var DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "displayName": makeObjectPropertySetter(readString),
            "value": makeObjectPropertySetter(readString)
          });
          function dataParser(node, objectStack) {
            var name = node.getAttribute("name");
            parseNode(DATA_PARSERS, node, objectStack);
            var featureObject = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            if (name && featureObject.displayName) {
              featureObject[name] = {
                value: featureObject.value,
                displayName: featureObject.displayName,
                toString: function() {
                  return featureObject.value;
                }
              };
            } else if (name !== null) {
              featureObject[name] = featureObject.value;
            } else if (featureObject.displayName !== null) {
              featureObject[featureObject.displayName] = featureObject.value;
            }
            delete featureObject["value"];
          }
          var EXTENDED_DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Data": dataParser,
            "SchemaData": schemaDataParser
          });
          function extendedDataParser(node, objectStack) {
            parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
          }
          function regionParser(node, objectStack) {
            parseNode(REGION_PARSERS, node, objectStack);
          }
          var PAIR_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Style": makeObjectPropertySetter(readStyle),
            "key": makeObjectPropertySetter(readString),
            "styleUrl": makeObjectPropertySetter(readStyleURL)
          });
          function pairDataParser(node, objectStack) {
            var pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);
            if (!pairObject) {
              return;
            }
            var key = (
              /** @type {string|undefined} */
              pairObject["key"]
            );
            if (key && key == "normal") {
              var styleUrl = (
                /** @type {string|undefined} */
                pairObject["styleUrl"]
              );
              if (styleUrl) {
                objectStack[objectStack.length - 1] = styleUrl;
              }
              var style = (
                /** @type {Style} */
                pairObject["Style"]
              );
              if (style) {
                objectStack[objectStack.length - 1] = style;
              }
            }
          }
          function placemarkStyleMapParser(node, objectStack) {
            var styleMapValue = readStyleMapValue.call(this, node, objectStack);
            if (!styleMapValue) {
              return;
            }
            var placemarkObject = objectStack[objectStack.length - 1];
            if (Array.isArray(styleMapValue)) {
              placemarkObject["Style"] = styleMapValue;
            } else if (typeof styleMapValue === "string") {
              placemarkObject["styleUrl"] = styleMapValue;
            } else {
              assert2(false, 38);
            }
          }
          var SCHEMA_DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "SimpleData": simpleDataParser
          });
          function schemaDataParser(node, objectStack) {
            parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
          }
          function simpleDataParser(node, objectStack) {
            var name = node.getAttribute("name");
            if (name !== null) {
              var data = readString(node);
              var featureObject = (
                /** @type {Object} */
                objectStack[objectStack.length - 1]
              );
              featureObject[name] = data;
            }
          }
          var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "altitudeMode": makeObjectPropertySetter(readString),
            "minAltitude": makeObjectPropertySetter(readDecimal),
            "maxAltitude": makeObjectPropertySetter(readDecimal),
            "north": makeObjectPropertySetter(readDecimal),
            "south": makeObjectPropertySetter(readDecimal),
            "east": makeObjectPropertySetter(readDecimal),
            "west": makeObjectPropertySetter(readDecimal)
          });
          function latLonAltBoxParser(node, objectStack) {
            var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var regionObject = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var extent = [
              parseFloat(object["west"]),
              parseFloat(object["south"]),
              parseFloat(object["east"]),
              parseFloat(object["north"])
            ];
            regionObject["extent"] = extent;
            regionObject["altitudeMode"] = object["altitudeMode"];
            regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
            regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
          }
          var LOD_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "minLodPixels": makeObjectPropertySetter(readDecimal),
            "maxLodPixels": makeObjectPropertySetter(readDecimal),
            "minFadeExtent": makeObjectPropertySetter(readDecimal),
            "maxFadeExtent": makeObjectPropertySetter(readDecimal)
          });
          function lodParser(node, objectStack) {
            var object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);
            if (!object) {
              return;
            }
            var lodObject = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
            lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
            lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
            lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
          }
          var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
            // allows multiple, so we parse multiple here too.
            "LinearRing": makeArrayPusher(readFlatLinearRing)
          });
          function innerBoundaryIsParser(node, objectStack) {
            var innerBoundaryFlatLinearRings = pushParseAndPop(
              /** @type {Array<Array<number>>} */
              [],
              INNER_BOUNDARY_IS_PARSERS,
              node,
              objectStack
            );
            if (innerBoundaryFlatLinearRings.length > 0) {
              var flatLinearRings = (
                /** @type {Array<Array<number>>} */
                objectStack[objectStack.length - 1]
              );
              flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
            }
          }
          var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "LinearRing": makeReplacer(readFlatLinearRing)
          });
          function outerBoundaryIsParser(node, objectStack) {
            var flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
            if (flatLinearRing) {
              var flatLinearRings = (
                /** @type {Array<Array<number>>} */
                objectStack[objectStack.length - 1]
              );
              flatLinearRings[0] = flatLinearRing;
            }
          }
          function linkParser(node, objectStack) {
            parseNode(KML_LINK_PARSERS, node, objectStack);
          }
          function whenParser(node, objectStack) {
            var gxTrackObject = (
              /** @type {GxTrackObject} */
              objectStack[objectStack.length - 1]
            );
            var whens = gxTrackObject.whens;
            var s = getAllTextContent(node, false);
            var when = Date.parse(s);
            whens.push(isNaN(when) ? 0 : when);
          }
          function writeColorTextNode(node, color) {
            var rgba = asArray(color);
            var opacity = rgba.length == 4 ? rgba[3] : 1;
            var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
            for (var i = 0; i < 4; ++i) {
              var hex = Math.floor(
                /** @type {number} */
                abgr[i]
              ).toString(16);
              abgr[i] = hex.length == 1 ? "0" + hex : hex;
            }
            writeStringTextNode(node, abgr.join(""));
          }
          function writeCoordinatesTextNode(node, coordinates, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var layout = context["layout"];
            var stride = context["stride"];
            var dimension;
            if (layout == GeometryLayout.XY || layout == GeometryLayout.XYM) {
              dimension = 2;
            } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYZM) {
              dimension = 3;
            } else {
              assert2(false, 34);
            }
            var ii = coordinates.length;
            var text = "";
            if (ii > 0) {
              text += coordinates[0];
              for (var d = 1; d < dimension; ++d) {
                text += "," + coordinates[d];
              }
              for (var i = stride; i < ii; i += stride) {
                text += " " + coordinates[i];
                for (var d = 1; d < dimension; ++d) {
                  text += "," + coordinates[i + d];
                }
              }
            }
            writeStringTextNode(node, text);
          }
          var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Data": makeChildAppender(writeDataNode),
            "value": makeChildAppender(writeDataNodeValue),
            "displayName": makeChildAppender(writeDataNodeName)
          });
          function writeDataNode(node, pair, objectStack) {
            node.setAttribute("name", pair.name);
            var context = { node };
            var value = pair.value;
            if (typeof value == "object") {
              if (value !== null && value.displayName) {
                pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
              }
              if (value !== null && value.value) {
                pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
              }
            } else {
              pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
            }
          }
          function writeDataNodeName(node, name) {
            writeCDATASection(node, name);
          }
          function writeDataNodeValue(node, value) {
            writeStringTextNode(node, value);
          }
          var DOCUMENT_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Placemark": makeChildAppender(writePlacemark)
          });
          var DOCUMENT_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
            var parentNode = objectStack[objectStack.length - 1].node;
            return createElementNS(parentNode.namespaceURI, "Placemark");
          };
          function writeDocument(node, features, objectStack) {
            var context = { node };
            pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);
          }
          var DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
          function writeExtendedData(node, namesAndValues, objectStack) {
            var context = { node };
            var names = namesAndValues.names;
            var values = namesAndValues.values;
            var length = names.length;
            for (var i = 0; i < length; i++) {
              pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
            }
          }
          var ICON_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["href"], makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"]));
          var ICON_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "href": makeChildAppender(writeStringTextNode)
          }, makeStructureNS(GX_NAMESPACE_URIS, {
            "x": makeChildAppender(writeDecimalTextNode),
            "y": makeChildAppender(writeDecimalTextNode),
            "w": makeChildAppender(writeDecimalTextNode),
            "h": makeChildAppender(writeDecimalTextNode)
          }));
          var GX_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
            return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + opt_nodeName);
          };
          function writeIcon(node, icon, objectStack) {
            var context = { node };
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(icon, orderedKeys);
            pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
            orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
            values = makeSequence(icon, orderedKeys);
            pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          var ICON_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "scale",
            "heading",
            "Icon",
            "color",
            "hotSpot"
          ]);
          var ICON_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "Icon": makeChildAppender(writeIcon),
            "color": makeChildAppender(writeColorTextNode),
            "heading": makeChildAppender(writeDecimalTextNode),
            "hotSpot": makeChildAppender(writeVec2),
            "scale": makeChildAppender(writeScaleTextNode)
          });
          function writeIconStyle(node, style, objectStack) {
            var context = { node };
            var properties = {};
            var src = style.getSrc();
            var size = style.getSize();
            var iconImageSize = style.getImageSize();
            var iconProperties = {
              "href": src
            };
            if (size) {
              iconProperties["w"] = size[0];
              iconProperties["h"] = size[1];
              var anchor = style.getAnchor();
              var origin_1 = style.getOrigin();
              if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
                iconProperties["x"] = origin_1[0];
                iconProperties["y"] = iconImageSize[1] - (origin_1[1] + size[1]);
              }
              if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
                var hotSpot = {
                  x: anchor[0],
                  xunits: IconAnchorUnits.PIXELS,
                  y: size[1] - anchor[1],
                  yunits: IconAnchorUnits.PIXELS
                };
                properties["hotSpot"] = hotSpot;
              }
            }
            properties["Icon"] = iconProperties;
            var scale = style.getScale();
            if (scale !== 1) {
              properties["scale"] = scale;
            }
            var rotation = style.getRotation();
            if (rotation !== 0) {
              properties["heading"] = rotation;
            }
            var color = style.getColor();
            if (color) {
              properties["color"] = color;
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          var LABEL_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "color",
            "scale"
          ]);
          var LABEL_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeChildAppender(writeColorTextNode),
            "scale": makeChildAppender(writeScaleTextNode)
          });
          function writeLabelStyle(node, style, objectStack) {
            var context = { node };
            var properties = {};
            var fill = style.getFill();
            if (fill) {
              properties["color"] = fill.getColor();
            }
            var scale = style.getScale();
            if (scale && scale !== 1) {
              properties["scale"] = scale;
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          var LINE_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["color", "width"]);
          var LINE_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeChildAppender(writeColorTextNode),
            "width": makeChildAppender(writeDecimalTextNode)
          });
          function writeLineStyle(node, style, objectStack) {
            var context = { node };
            var properties = {
              "color": style.getColor(),
              "width": Number(style.getWidth()) || 1
            };
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          var KML_GEOMETRY_TYPE_TO_NODENAME = {
            "Point": "Point",
            "LineString": "LineString",
            "LinearRing": "LinearRing",
            "Polygon": "Polygon",
            "MultiPoint": "MultiGeometry",
            "MultiLineString": "MultiGeometry",
            "MultiPolygon": "MultiGeometry",
            "GeometryCollection": "MultiGeometry"
          };
          var GEOMETRY_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
            if (value) {
              var parentNode = objectStack[objectStack.length - 1].node;
              return createElementNS(parentNode.namespaceURI, KML_GEOMETRY_TYPE_TO_NODENAME[
                /** @type {import("../geom/Geometry.js").default} */
                value.getType()
              ]);
            }
          };
          var POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
          var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
          var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
          var POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
          var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "LineString": makeChildAppender(writePrimitiveGeometry),
            "Point": makeChildAppender(writePrimitiveGeometry),
            "Polygon": makeChildAppender(writePolygon),
            "GeometryCollection": makeChildAppender(writeMultiGeometry)
          });
          function writeMultiGeometry(node, geometry, objectStack) {
            var context = { node };
            var type = geometry.getType();
            var geometries = [];
            var factory;
            if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
              geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
                var type2 = geometry2.getType();
                if (type2 === geom_GeometryType.MULTI_POINT) {
                  geometries = geometries.concat(
                    /** @type {MultiPoint} */
                    geometry2.getPoints()
                  );
                } else if (type2 === geom_GeometryType.MULTI_LINE_STRING) {
                  geometries = geometries.concat(
                    /** @type {MultiLineString} */
                    geometry2.getLineStrings()
                  );
                } else if (type2 === geom_GeometryType.MULTI_POLYGON) {
                  geometries = geometries.concat(
                    /** @type {MultiPolygon} */
                    geometry2.getPolygons()
                  );
                } else if (type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.LINE_STRING || type2 === geom_GeometryType.POLYGON) {
                  geometries.push(geometry2);
                } else {
                  assert2(false, 39);
                }
              });
              factory = GEOMETRY_NODE_FACTORY;
            } else if (type === geom_GeometryType.MULTI_POINT) {
              geometries = /** @type {MultiPoint} */
              geometry.getPoints();
              factory = POINT_NODE_FACTORY;
            } else if (type === geom_GeometryType.MULTI_LINE_STRING) {
              geometries = /** @type {MultiLineString} */
              geometry.getLineStrings();
              factory = LINE_STRING_NODE_FACTORY;
            } else if (type === geom_GeometryType.MULTI_POLYGON) {
              geometries = /** @type {MultiPolygon} */
              geometry.getPolygons();
              factory = POLYGON_NODE_FACTORY;
            } else {
              assert2(false, 39);
            }
            pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
          }
          var BOUNDARY_IS_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "LinearRing": makeChildAppender(writePrimitiveGeometry)
          });
          function writeBoundaryIs(node, linearRing, objectStack) {
            var context = { node };
            pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
          }
          var PLACEMARK_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "ExtendedData": makeChildAppender(writeExtendedData),
            "MultiGeometry": makeChildAppender(writeMultiGeometry),
            "LineString": makeChildAppender(writePrimitiveGeometry),
            "LinearRing": makeChildAppender(writePrimitiveGeometry),
            "Point": makeChildAppender(writePrimitiveGeometry),
            "Polygon": makeChildAppender(writePolygon),
            "Style": makeChildAppender(writeStyle),
            "address": makeChildAppender(writeStringTextNode),
            "description": makeChildAppender(writeStringTextNode),
            "name": makeChildAppender(writeStringTextNode),
            "open": makeChildAppender(writeBooleanTextNode),
            "phoneNumber": makeChildAppender(writeStringTextNode),
            "styleUrl": makeChildAppender(writeStringTextNode),
            "visibility": makeChildAppender(writeBooleanTextNode)
          });
          var PLACEMARK_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "name",
            "open",
            "visibility",
            "address",
            "phoneNumber",
            "description",
            "styleUrl",
            "Style"
          ]);
          var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
          function writePlacemark(node, feature, objectStack) {
            var context = { node };
            if (feature.getId()) {
              node.setAttribute(
                "id",
                /** @type {string} */
                feature.getId()
              );
            }
            var properties = feature.getProperties();
            var filter = {
              "address": 1,
              "description": 1,
              "name": 1,
              "open": 1,
              "phoneNumber": 1,
              "styleUrl": 1,
              "visibility": 1
            };
            filter[feature.getGeometryName()] = 1;
            var keys = Object.keys(properties || {}).sort().filter(function(v) {
              return !filter[v];
            });
            var styleFunction = feature.getStyleFunction();
            if (styleFunction) {
              var styles = styleFunction(feature, 0);
              if (styles) {
                var styleArray = Array.isArray(styles) ? styles : [styles];
                var pointStyles = styleArray;
                if (feature.getGeometry()) {
                  pointStyles = styleArray.filter(function(style) {
                    var geometry2 = style.getGeometryFunction()(feature);
                    if (geometry2) {
                      var type = geometry2.getType();
                      if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                        return (
                          /** @type {GeometryCollection} */
                          geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                            var type2 = geometry3.getType();
                            return type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.MULTI_POINT;
                          }).length
                        );
                      }
                      return type === geom_GeometryType.POINT || type === geom_GeometryType.MULTI_POINT;
                    }
                  });
                }
                if (this.writeStyles_) {
                  var lineStyles = styleArray;
                  var polyStyles = styleArray;
                  if (feature.getGeometry()) {
                    lineStyles = styleArray.filter(function(style) {
                      var geometry2 = style.getGeometryFunction()(feature);
                      if (geometry2) {
                        var type = geometry2.getType();
                        if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                          return (
                            /** @type {GeometryCollection} */
                            geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                              var type2 = geometry3.getType();
                              return type2 === geom_GeometryType.LINE_STRING || type2 === geom_GeometryType.MULTI_LINE_STRING;
                            }).length
                          );
                        }
                        return type === geom_GeometryType.LINE_STRING || type === geom_GeometryType.MULTI_LINE_STRING;
                      }
                    });
                    polyStyles = styleArray.filter(function(style) {
                      var geometry2 = style.getGeometryFunction()(feature);
                      if (geometry2) {
                        var type = geometry2.getType();
                        if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                          return (
                            /** @type {GeometryCollection} */
                            geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                              var type2 = geometry3.getType();
                              return type2 === geom_GeometryType.POLYGON || type2 === geom_GeometryType.MULTI_POLYGON;
                            }).length
                          );
                        }
                        return type === geom_GeometryType.POLYGON || type === geom_GeometryType.MULTI_POLYGON;
                      }
                    });
                  }
                  properties["Style"] = {
                    pointStyles,
                    lineStyles,
                    polyStyles
                  };
                }
                if (pointStyles.length && properties["name"] === void 0) {
                  var textStyle = pointStyles[0].getText();
                  if (textStyle) {
                    properties["name"] = textStyle.getText();
                  }
                }
              }
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
            if (keys.length > 0) {
              var sequence = makeSequence(properties, keys);
              var namesAndValues = { names: keys, values: sequence };
              pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
            }
            var options = (
              /** @type {import("./Feature.js").WriteOptions} */
              objectStack[0]
            );
            var geometry = feature.getGeometry();
            if (geometry) {
              geometry = transformGeometryWithOptions(geometry, true, options);
            }
            pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
          }
          var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "extrude",
            "tessellate",
            "altitudeMode",
            "coordinates"
          ]);
          var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "extrude": makeChildAppender(writeBooleanTextNode),
            "tessellate": makeChildAppender(writeBooleanTextNode),
            "altitudeMode": makeChildAppender(writeStringTextNode),
            "coordinates": makeChildAppender(writeCoordinatesTextNode)
          });
          function writePrimitiveGeometry(node, geometry, objectStack) {
            var flatCoordinates = geometry.getFlatCoordinates();
            var context = { node };
            context["layout"] = geometry.getLayout();
            context["stride"] = geometry.getStride();
            var properties = geometry.getProperties();
            properties.coordinates = flatCoordinates;
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          var POLY_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "color",
            "fill",
            "outline"
          ]);
          var POLYGON_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
            "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
          });
          var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
          var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
          function writePolygon(node, polygon, objectStack) {
            var linearRings = polygon.getLinearRings();
            var outerRing = linearRings.shift();
            var context = { node };
            pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);
            pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
          }
          var POLY_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "color": makeChildAppender(writeColorTextNode),
            "fill": makeChildAppender(writeBooleanTextNode),
            "outline": makeChildAppender(writeBooleanTextNode)
          });
          function writePolyStyle(node, style, objectStack) {
            var context = { node };
            var fill = style.getFill();
            var stroke = style.getStroke();
            var properties = {
              "color": fill ? fill.getColor() : void 0,
              "fill": fill ? void 0 : false,
              "outline": stroke ? void 0 : false
            };
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          function writeScaleTextNode(node, scale) {
            writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
          }
          var STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
            "IconStyle",
            "LabelStyle",
            "LineStyle",
            "PolyStyle"
          ]);
          var STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
            "IconStyle": makeChildAppender(writeIconStyle),
            "LabelStyle": makeChildAppender(writeLabelStyle),
            "LineStyle": makeChildAppender(writeLineStyle),
            "PolyStyle": makeChildAppender(writePolyStyle)
          });
          function writeStyle(node, styles, objectStack) {
            var context = { node };
            var properties = {};
            if (styles.pointStyles.length) {
              var textStyle = styles.pointStyles[0].getText();
              if (textStyle) {
                properties["LabelStyle"] = textStyle;
              }
              var imageStyle = styles.pointStyles[0].getImage();
              if (imageStyle && typeof /** @type {?} */
              imageStyle.getSrc === "function") {
                properties["IconStyle"] = imageStyle;
              }
            }
            if (styles.lineStyles.length) {
              var strokeStyle = styles.lineStyles[0].getStroke();
              if (strokeStyle) {
                properties["LineStyle"] = strokeStyle;
              }
            }
            if (styles.polyStyles.length) {
              var strokeStyle = styles.polyStyles[0].getStroke();
              if (strokeStyle && !properties["LineStyle"]) {
                properties["LineStyle"] = strokeStyle;
              }
              properties["PolyStyle"] = styles.polyStyles[0];
            }
            var parentNode = objectStack[objectStack.length - 1].node;
            var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          }
          function writeVec2(node, vec2) {
            node.setAttribute("x", String(vec2.x));
            node.setAttribute("y", String(vec2.y));
            node.setAttribute("xunits", vec2.xunits);
            node.setAttribute("yunits", vec2.yunits);
          }
          var format_KML = KML_KML;
          var node_modules_pbf = __webpack_require__("7915");
          var pbf_default = __webpack_require__.n(node_modules_pbf);
          var Feature_tmpTransform = create();
          var Feature_RenderFeature = (
            /** @class */
            function() {
              function RenderFeature(type, flatCoordinates, ends, properties, id) {
                this.extent_;
                this.id_ = id;
                this.type_ = type;
                this.flatCoordinates_ = flatCoordinates;
                this.flatInteriorPoints_ = null;
                this.flatMidpoints_ = null;
                this.ends_ = ends;
                this.properties_ = properties;
              }
              RenderFeature.prototype.get = function(key) {
                return this.properties_[key];
              };
              RenderFeature.prototype.getExtent = function() {
                if (!this.extent_) {
                  this.extent_ = this.type_ === geom_GeometryType.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
                }
                return this.extent_;
              };
              RenderFeature.prototype.getFlatInteriorPoint = function() {
                if (!this.flatInteriorPoints_) {
                  var flatCenter = extent_getCenter(this.getExtent());
                  this.flatInteriorPoints_ = getInteriorPointOfArray(
                    this.flatCoordinates_,
                    0,
                    /** @type {Array<number>} */
                    this.ends_,
                    2,
                    flatCenter,
                    0
                  );
                }
                return this.flatInteriorPoints_;
              };
              RenderFeature.prototype.getFlatInteriorPoints = function() {
                if (!this.flatInteriorPoints_) {
                  var flatCenters = center_linearRingss(
                    this.flatCoordinates_,
                    0,
                    /** @type {Array<Array<number>>} */
                    this.ends_,
                    2
                  );
                  this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
                    this.flatCoordinates_,
                    0,
                    /** @type {Array<Array<number>>} */
                    this.ends_,
                    2,
                    flatCenters
                  );
                }
                return this.flatInteriorPoints_;
              };
              RenderFeature.prototype.getFlatMidpoint = function() {
                if (!this.flatMidpoints_) {
                  this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
                }
                return this.flatMidpoints_;
              };
              RenderFeature.prototype.getFlatMidpoints = function() {
                if (!this.flatMidpoints_) {
                  this.flatMidpoints_ = [];
                  var flatCoordinates = this.flatCoordinates_;
                  var offset = 0;
                  var ends = (
                    /** @type {Array<number>} */
                    this.ends_
                  );
                  for (var i = 0, ii = ends.length; i < ii; ++i) {
                    var end = ends[i];
                    var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
                    Object(ol_array[
                      "c"
                      /* extend */
                    ])(this.flatMidpoints_, midpoint);
                    offset = end;
                  }
                }
                return this.flatMidpoints_;
              };
              RenderFeature.prototype.getId = function() {
                return this.id_;
              };
              RenderFeature.prototype.getOrientedFlatCoordinates = function() {
                return this.flatCoordinates_;
              };
              RenderFeature.prototype.getGeometry = function() {
                return this;
              };
              RenderFeature.prototype.getSimplifiedGeometry = function(squaredTolerance) {
                return this;
              };
              RenderFeature.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
                return this;
              };
              RenderFeature.prototype.getProperties = function() {
                return this.properties_;
              };
              RenderFeature.prototype.getStride = function() {
                return 2;
              };
              RenderFeature.prototype.getStyleFunction = function() {
                return void 0;
              };
              RenderFeature.prototype.getType = function() {
                return this.type_;
              };
              RenderFeature.prototype.transform = function(projection) {
                projection = proj_get(projection);
                var pixelExtent = projection.getExtent();
                var projectedExtent = projection.getWorldExtent();
                if (pixelExtent && projectedExtent) {
                  var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
                  compose(Feature_tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                  transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, Feature_tmpTransform, this.flatCoordinates_);
                }
              };
              RenderFeature.prototype.getEnds = function() {
                return this.ends_;
              };
              return RenderFeature;
            }()
          );
          Feature_RenderFeature.prototype.getEndss = Feature_RenderFeature.prototype.getEnds;
          Feature_RenderFeature.prototype.getFlatCoordinates = Feature_RenderFeature.prototype.getOrientedFlatCoordinates;
          var render_Feature = Feature_RenderFeature;
          var MVT_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var MVT_MVT = (
            /** @class */
            function(_super) {
              MVT_extends(MVT, _super);
              function MVT(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.dataProjection = new proj_Projection({
                  code: "",
                  units: proj_Units.TILE_PIXELS
                });
                _this.featureClass_ = options.featureClass ? options.featureClass : render_Feature;
                _this.geometryName_ = options.geometryName;
                _this.layerName_ = options.layerName ? options.layerName : "layer";
                _this.layers_ = options.layers ? options.layers : null;
                _this.idProperty_ = options.idProperty;
                return _this;
              }
              MVT.prototype.readRawGeometry_ = function(pbf, feature, flatCoordinates, ends) {
                pbf.pos = feature.geometry;
                var end = pbf.readVarint() + pbf.pos;
                var cmd = 1;
                var length = 0;
                var x = 0;
                var y = 0;
                var coordsLen = 0;
                var currentEnd = 0;
                while (pbf.pos < end) {
                  if (!length) {
                    var cmdLen = pbf.readVarint();
                    cmd = cmdLen & 7;
                    length = cmdLen >> 3;
                  }
                  length--;
                  if (cmd === 1 || cmd === 2) {
                    x += pbf.readSVarint();
                    y += pbf.readSVarint();
                    if (cmd === 1) {
                      if (coordsLen > currentEnd) {
                        ends.push(coordsLen);
                        currentEnd = coordsLen;
                      }
                    }
                    flatCoordinates.push(x, y);
                    coordsLen += 2;
                  } else if (cmd === 7) {
                    if (coordsLen > currentEnd) {
                      flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
                      coordsLen += 2;
                    }
                  } else {
                    assert2(false, 59);
                  }
                }
                if (coordsLen > currentEnd) {
                  ends.push(coordsLen);
                  currentEnd = coordsLen;
                }
              };
              MVT.prototype.createFeature_ = function(pbf, rawFeature, options) {
                var type = rawFeature.type;
                if (type === 0) {
                  return null;
                }
                var feature;
                var values = rawFeature.properties;
                var id;
                if (!this.idProperty_) {
                  id = rawFeature.id;
                } else {
                  id = values[this.idProperty_];
                  delete values[this.idProperty_];
                }
                values[this.layerName_] = rawFeature.layer.name;
                var flatCoordinates = [];
                var ends = [];
                this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
                var geometryType = getGeometryType(type, ends.length);
                if (this.featureClass_ === render_Feature) {
                  feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
                  feature.transform(options.dataProjection);
                } else {
                  var geom = void 0;
                  if (geometryType == geom_GeometryType.POLYGON) {
                    var endss = [];
                    var offset = 0;
                    var prevEndIndex = 0;
                    for (var i = 0, ii = ends.length; i < ii; ++i) {
                      var end = ends[i];
                      if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
                        endss.push(ends.slice(prevEndIndex, i + 1));
                      } else {
                        if (endss.length === 0) {
                          continue;
                        }
                        endss[endss.length - 1].push(ends[prevEndIndex]);
                      }
                      prevEndIndex = i + 1;
                      offset = end;
                    }
                    if (endss.length > 1) {
                      geom = new geom_MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);
                    } else {
                      geom = new geom_Polygon(flatCoordinates, GeometryLayout.XY, ends);
                    }
                  } else {
                    geom = geometryType === geom_GeometryType.POINT ? new geom_Point(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.LINE_STRING ? new geom_LineString(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.POLYGON ? new geom_Polygon(flatCoordinates, GeometryLayout.XY, ends) : geometryType === geom_GeometryType.MULTI_POINT ? new geom_MultiPoint(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.MULTI_LINE_STRING ? new geom_MultiLineString(flatCoordinates, GeometryLayout.XY, ends) : null;
                  }
                  var ctor = (
                    /** @type {typeof import("../Feature.js").default} */
                    this.featureClass_
                  );
                  feature = new ctor();
                  if (this.geometryName_) {
                    feature.setGeometryName(this.geometryName_);
                  }
                  var geometry = transformGeometryWithOptions(geom, false, options);
                  feature.setGeometry(geometry);
                  feature.setId(id);
                  feature.setProperties(values, true);
                }
                return feature;
              };
              MVT.prototype.getType = function() {
                return FormatType.ARRAY_BUFFER;
              };
              MVT.prototype.readFeatures = function(source, opt_options) {
                var layers = this.layers_;
                var options = (
                  /** @type {import("./Feature.js").ReadOptions} */
                  this.adaptOptions(opt_options)
                );
                var dataProjection = proj_get(options.dataProjection);
                dataProjection.setWorldExtent(options.extent);
                options.dataProjection = dataProjection;
                var pbf = new pbf_default.a(
                  /** @type {ArrayBuffer} */
                  source
                );
                var pbfLayers = pbf.readFields(layersPBFReader, {});
                var features = [];
                for (var name_1 in pbfLayers) {
                  if (layers && layers.indexOf(name_1) == -1) {
                    continue;
                  }
                  var pbfLayer = pbfLayers[name_1];
                  var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
                  dataProjection.setExtent(extent);
                  for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
                    var rawFeature = readRawFeature(pbf, pbfLayer, i);
                    features.push(this.createFeature_(pbf, rawFeature, options));
                  }
                }
                return features;
              };
              MVT.prototype.readProjection = function(source) {
                return this.dataProjection;
              };
              MVT.prototype.setLayers = function(layers) {
                this.layers_ = layers;
              };
              return MVT;
            }(format_Feature)
          );
          function layersPBFReader(tag, layers, pbf) {
            if (tag === 3) {
              var layer = {
                keys: [],
                values: [],
                features: []
              };
              var end = pbf.readVarint() + pbf.pos;
              pbf.readFields(layerPBFReader, layer, end);
              layer.length = layer.features.length;
              if (layer.length) {
                layers[layer.name] = layer;
              }
            }
          }
          function layerPBFReader(tag, layer, pbf) {
            if (tag === 15) {
              layer.version = pbf.readVarint();
            } else if (tag === 1) {
              layer.name = pbf.readString();
            } else if (tag === 5) {
              layer.extent = pbf.readVarint();
            } else if (tag === 2) {
              layer.features.push(pbf.pos);
            } else if (tag === 3) {
              layer.keys.push(pbf.readString());
            } else if (tag === 4) {
              var value = null;
              var end = pbf.readVarint() + pbf.pos;
              while (pbf.pos < end) {
                tag = pbf.readVarint() >> 3;
                value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
              }
              layer.values.push(value);
            }
          }
          function featurePBFReader(tag, feature, pbf) {
            if (tag == 1) {
              feature.id = pbf.readVarint();
            } else if (tag == 2) {
              var end = pbf.readVarint() + pbf.pos;
              while (pbf.pos < end) {
                var key = feature.layer.keys[pbf.readVarint()];
                var value = feature.layer.values[pbf.readVarint()];
                feature.properties[key] = value;
              }
            } else if (tag == 3) {
              feature.type = pbf.readVarint();
            } else if (tag == 4) {
              feature.geometry = pbf.pos;
            }
          }
          function readRawFeature(pbf, layer, i) {
            pbf.pos = layer.features[i];
            var end = pbf.readVarint() + pbf.pos;
            var feature = {
              layer,
              type: 0,
              properties: {}
            };
            pbf.readFields(featurePBFReader, feature, end);
            return feature;
          }
          function getGeometryType(type, numEnds) {
            var geometryType;
            if (type === 1) {
              geometryType = numEnds === 1 ? geom_GeometryType.POINT : geom_GeometryType.MULTI_POINT;
            } else if (type === 2) {
              geometryType = numEnds === 1 ? geom_GeometryType.LINE_STRING : geom_GeometryType.MULTI_LINE_STRING;
            } else if (type === 3) {
              geometryType = geom_GeometryType.POLYGON;
            }
            return geometryType;
          }
          var format_MVT = MVT_MVT;
          var XML_XML = (
            /** @class */
            function() {
              function XML() {
              }
              XML.prototype.read = function(source) {
                if (!source) {
                  return null;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readFromDocument(doc);
                } else if (isDocument(source)) {
                  return this.readFromDocument(
                    /** @type {Document} */
                    source
                  );
                } else {
                  return this.readFromNode(
                    /** @type {Element} */
                    source
                  );
                }
              };
              XML.prototype.readFromDocument = function(doc) {
                for (var n = doc.firstChild; n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    return this.readFromNode(
                      /** @type {Element} */
                      n
                    );
                  }
                }
                return null;
              };
              XML.prototype.readFromNode = function(node) {
              };
              return XML;
            }()
          );
          var format_XML = XML_XML;
          var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
          function readHref(node) {
            return node.getAttributeNS(NAMESPACE_URI, "href");
          }
          var OWS_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
          var PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
            "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
            "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
          });
          var OWS_OWS = (
            /** @class */
            function(_super) {
              OWS_extends(OWS, _super);
              function OWS() {
                return _super.call(this) || this;
              }
              OWS.prototype.readFromNode = function(node) {
                var owsObject = pushParseAndPop({}, PARSERS, node, []);
                return owsObject ? owsObject : null;
              };
              return OWS;
            }(format_XML)
          );
          var ADDRESS_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "DeliveryPoint": makeObjectPropertySetter(readString),
            "City": makeObjectPropertySetter(readString),
            "AdministrativeArea": makeObjectPropertySetter(readString),
            "PostalCode": makeObjectPropertySetter(readString),
            "Country": makeObjectPropertySetter(readString),
            "ElectronicMailAddress": makeObjectPropertySetter(readString)
          });
          var ALLOWED_VALUES_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Value": makeObjectPropertyPusher(readValue)
          });
          var CONSTRAINT_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "AllowedValues": makeObjectPropertySetter(readAllowedValues)
          });
          var CONTACT_INFO_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Phone": makeObjectPropertySetter(readPhone),
            "Address": makeObjectPropertySetter(readAddress)
          });
          var DCP_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "HTTP": makeObjectPropertySetter(readHttp)
          });
          var HTTP_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Get": makeObjectPropertyPusher(readGet),
            "Post": void 0
            // TODO
          });
          var OPERATION_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "DCP": makeObjectPropertySetter(readDcp)
          });
          var OPERATIONS_METADATA_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Operation": readOperation
          });
          var PHONE_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Voice": makeObjectPropertySetter(readString),
            "Facsimile": makeObjectPropertySetter(readString)
          });
          var REQUEST_METHOD_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Constraint": makeObjectPropertyPusher(readConstraint)
          });
          var SERVICE_CONTACT_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "IndividualName": makeObjectPropertySetter(readString),
            "PositionName": makeObjectPropertySetter(readString),
            "ContactInfo": makeObjectPropertySetter(readContactInfo)
          });
          var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "Abstract": makeObjectPropertySetter(readString),
            "AccessConstraints": makeObjectPropertySetter(readString),
            "Fees": makeObjectPropertySetter(readString),
            "Title": makeObjectPropertySetter(readString),
            "ServiceTypeVersion": makeObjectPropertySetter(readString),
            "ServiceType": makeObjectPropertySetter(readString)
          });
          var SERVICE_PROVIDER_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
            "ProviderName": makeObjectPropertySetter(readString),
            "ProviderSite": makeObjectPropertySetter(readHref),
            "ServiceContact": makeObjectPropertySetter(readServiceContact)
          });
          function readAddress(node, objectStack) {
            return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
          }
          function readAllowedValues(node, objectStack) {
            return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
          }
          function readConstraint(node, objectStack) {
            var name = node.getAttribute("name");
            if (!name) {
              return void 0;
            }
            return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node, objectStack);
          }
          function readContactInfo(node, objectStack) {
            return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
          }
          function readDcp(node, objectStack) {
            return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
          }
          function readGet(node, objectStack) {
            var href = readHref(node);
            if (!href) {
              return void 0;
            }
            return pushParseAndPop({ "href": href }, REQUEST_METHOD_PARSERS, node, objectStack);
          }
          function readHttp(node, objectStack) {
            return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
          }
          function readOperation(node, objectStack) {
            var name = node.getAttribute("name");
            var value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
            if (!value) {
              return void 0;
            }
            var object = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            object[name] = value;
          }
          function readOperationsMetadata(node, objectStack) {
            return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
          }
          function readPhone(node, objectStack) {
            return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
          }
          function readServiceIdentification(node, objectStack) {
            return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
          }
          function readServiceContact(node, objectStack) {
            return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
          }
          function readServiceProvider(node, objectStack) {
            return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
          }
          function readValue(node, objectStack) {
            return readString(node);
          }
          var format_OWS = OWS_OWS;
          function flipXY(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {
            var dest, destOffset;
            if (opt_dest !== void 0) {
              dest = opt_dest;
              destOffset = opt_destOffset !== void 0 ? opt_destOffset : 0;
            } else {
              dest = [];
              destOffset = 0;
            }
            var j = offset;
            while (j < end) {
              var x = flatCoordinates[j++];
              dest[destOffset++] = flatCoordinates[j++];
              dest[destOffset++] = x;
              for (var k = 2; k < stride; ++k) {
                dest[destOffset++] = flatCoordinates[j++];
              }
            }
            dest.length = destOffset;
            return dest;
          }
          var Polyline_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Polyline_Polyline = (
            /** @class */
            function(_super) {
              Polyline_extends(Polyline, _super);
              function Polyline(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.dataProjection = proj_get("EPSG:4326");
                _this.factor_ = options.factor ? options.factor : 1e5;
                _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;
                return _this;
              }
              Polyline.prototype.readFeatureFromText = function(text, opt_options) {
                var geometry = this.readGeometryFromText(text, opt_options);
                return new ol_Feature(geometry);
              };
              Polyline.prototype.readFeaturesFromText = function(text, opt_options) {
                var feature = this.readFeatureFromText(text, opt_options);
                return [feature];
              };
              Polyline.prototype.readGeometryFromText = function(text, opt_options) {
                var stride = getStrideForLayout(this.geometryLayout_);
                var flatCoordinates = decodeDeltas(text, stride, this.factor_);
                flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
                var coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
                var lineString = new geom_LineString(coordinates, this.geometryLayout_);
                return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));
              };
              Polyline.prototype.writeFeatureText = function(feature, opt_options) {
                var geometry = feature.getGeometry();
                if (geometry) {
                  return this.writeGeometryText(geometry, opt_options);
                } else {
                  assert2(false, 40);
                  return "";
                }
              };
              Polyline.prototype.writeFeaturesText = function(features, opt_options) {
                return this.writeFeatureText(features[0], opt_options);
              };
              Polyline.prototype.writeGeometryText = function(geometry, opt_options) {
                geometry = /** @type {LineString} */
                transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));
                var flatCoordinates = geometry.getFlatCoordinates();
                var stride = geometry.getStride();
                flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
                return encodeDeltas(flatCoordinates, stride, this.factor_);
              };
              return Polyline;
            }(format_TextFeature)
          );
          function encodeDeltas(numbers, stride, opt_factor) {
            var factor = opt_factor ? opt_factor : 1e5;
            var d;
            var lastNumbers = new Array(stride);
            for (d = 0; d < stride; ++d) {
              lastNumbers[d] = 0;
            }
            for (var i = 0, ii = numbers.length; i < ii; ) {
              for (d = 0; d < stride; ++d, ++i) {
                var num = numbers[i];
                var delta = num - lastNumbers[d];
                lastNumbers[d] = num;
                numbers[i] = delta;
              }
            }
            return encodeFloats(numbers, factor);
          }
          function decodeDeltas(encoded, stride, opt_factor) {
            var factor = opt_factor ? opt_factor : 1e5;
            var d;
            var lastNumbers = new Array(stride);
            for (d = 0; d < stride; ++d) {
              lastNumbers[d] = 0;
            }
            var numbers = decodeFloats(encoded, factor);
            for (var i = 0, ii = numbers.length; i < ii; ) {
              for (d = 0; d < stride; ++d, ++i) {
                lastNumbers[d] += numbers[i];
                numbers[i] = lastNumbers[d];
              }
            }
            return numbers;
          }
          function encodeFloats(numbers, opt_factor) {
            var factor = opt_factor ? opt_factor : 1e5;
            for (var i = 0, ii = numbers.length; i < ii; ++i) {
              numbers[i] = Math.round(numbers[i] * factor);
            }
            return encodeSignedIntegers(numbers);
          }
          function decodeFloats(encoded, opt_factor) {
            var factor = opt_factor ? opt_factor : 1e5;
            var numbers = decodeSignedIntegers(encoded);
            for (var i = 0, ii = numbers.length; i < ii; ++i) {
              numbers[i] /= factor;
            }
            return numbers;
          }
          function encodeSignedIntegers(numbers) {
            for (var i = 0, ii = numbers.length; i < ii; ++i) {
              var num = numbers[i];
              numbers[i] = num < 0 ? ~(num << 1) : num << 1;
            }
            return encodeUnsignedIntegers(numbers);
          }
          function decodeSignedIntegers(encoded) {
            var numbers = decodeUnsignedIntegers(encoded);
            for (var i = 0, ii = numbers.length; i < ii; ++i) {
              var num = numbers[i];
              numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
            }
            return numbers;
          }
          function encodeUnsignedIntegers(numbers) {
            var encoded = "";
            for (var i = 0, ii = numbers.length; i < ii; ++i) {
              encoded += encodeUnsignedInteger(numbers[i]);
            }
            return encoded;
          }
          function decodeUnsignedIntegers(encoded) {
            var numbers = [];
            var current = 0;
            var shift = 0;
            for (var i = 0, ii = encoded.length; i < ii; ++i) {
              var b = encoded.charCodeAt(i) - 63;
              current |= (b & 31) << shift;
              if (b < 32) {
                numbers.push(current);
                current = 0;
                shift = 0;
              } else {
                shift += 5;
              }
            }
            return numbers;
          }
          function encodeUnsignedInteger(num) {
            var value, encoded = "";
            while (num >= 32) {
              value = (32 | num & 31) + 63;
              encoded += String.fromCharCode(value);
              num >>= 5;
            }
            value = num + 63;
            encoded += String.fromCharCode(value);
            return encoded;
          }
          var format_Polyline = Polyline_Polyline;
          var TopoJSON_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var TopoJSON_TopoJSON = (
            /** @class */
            function(_super) {
              TopoJSON_extends(TopoJSON, _super);
              function TopoJSON(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.layerName_ = options.layerName;
                _this.layers_ = options.layers ? options.layers : null;
                _this.dataProjection = proj_get(options.dataProjection ? options.dataProjection : "EPSG:4326");
                return _this;
              }
              TopoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
                if (object.type == "Topology") {
                  var topoJSONTopology = (
                    /** @type {TopoJSONTopology} */
                    object
                  );
                  var transform2 = void 0, scale = null, translate = null;
                  if (topoJSONTopology["transform"]) {
                    transform2 = topoJSONTopology["transform"];
                    scale = transform2["scale"];
                    translate = transform2["translate"];
                  }
                  var arcs = topoJSONTopology["arcs"];
                  if (transform2) {
                    transformArcs(arcs, scale, translate);
                  }
                  var features = [];
                  var topoJSONFeatures = topoJSONTopology["objects"];
                  var property = this.layerName_;
                  var feature = void 0;
                  for (var objectName in topoJSONFeatures) {
                    if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
                      continue;
                    }
                    if (topoJSONFeatures[objectName].type === "GeometryCollection") {
                      feature = /** @type {TopoJSONGeometryCollection} */
                      topoJSONFeatures[objectName];
                      features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));
                    } else {
                      feature = /** @type {TopoJSONGeometry} */
                      topoJSONFeatures[objectName];
                      features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));
                    }
                  }
                  return features;
                } else {
                  return [];
                }
              };
              TopoJSON.prototype.readProjectionFromObject = function(object) {
                return this.dataProjection;
              };
              return TopoJSON;
            }(format_JSONFeature)
          );
          var TopoJSON_GEOMETRY_READERS = {
            "Point": TopoJSON_readPointGeometry,
            "LineString": TopoJSON_readLineStringGeometry,
            "Polygon": TopoJSON_readPolygonGeometry,
            "MultiPoint": TopoJSON_readMultiPointGeometry,
            "MultiLineString": TopoJSON_readMultiLineStringGeometry,
            "MultiPolygon": TopoJSON_readMultiPolygonGeometry
          };
          function concatenateArcs(indices, arcs) {
            var coordinates = [];
            var index, arc;
            for (var i = 0, ii = indices.length; i < ii; ++i) {
              index = indices[i];
              if (i > 0) {
                coordinates.pop();
              }
              if (index >= 0) {
                arc = arcs[index];
              } else {
                arc = arcs[~index].slice().reverse();
              }
              coordinates.push.apply(coordinates, arc);
            }
            for (var j = 0, jj = coordinates.length; j < jj; ++j) {
              coordinates[j] = coordinates[j].slice();
            }
            return coordinates;
          }
          function TopoJSON_readPointGeometry(object, scale, translate) {
            var coordinates = object["coordinates"];
            if (scale && translate) {
              transformVertex(coordinates, scale, translate);
            }
            return new geom_Point(coordinates);
          }
          function TopoJSON_readMultiPointGeometry(object, scale, translate) {
            var coordinates = object["coordinates"];
            if (scale && translate) {
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                transformVertex(coordinates[i], scale, translate);
              }
            }
            return new geom_MultiPoint(coordinates);
          }
          function TopoJSON_readLineStringGeometry(object, arcs) {
            var coordinates = concatenateArcs(object["arcs"], arcs);
            return new geom_LineString(coordinates);
          }
          function TopoJSON_readMultiLineStringGeometry(object, arcs) {
            var coordinates = [];
            for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
              coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
            }
            return new geom_MultiLineString(coordinates);
          }
          function TopoJSON_readPolygonGeometry(object, arcs) {
            var coordinates = [];
            for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
              coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
            }
            return new geom_Polygon(coordinates);
          }
          function TopoJSON_readMultiPolygonGeometry(object, arcs) {
            var coordinates = [];
            for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
              var polyArray = object["arcs"][i];
              var ringCoords = [];
              for (var j = 0, jj = polyArray.length; j < jj; ++j) {
                ringCoords[j] = concatenateArcs(polyArray[j], arcs);
              }
              coordinates[i] = ringCoords;
            }
            return new geom_MultiPolygon(coordinates);
          }
          function readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {
            var geometries = collection["geometries"];
            var features = [];
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);
            }
            return features;
          }
          function readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {
            var geometry = null;
            var type = object.type;
            if (type) {
              var geometryReader = TopoJSON_GEOMETRY_READERS[type];
              if (type === "Point" || type === "MultiPoint") {
                geometry = geometryReader(object, scale, translate);
              } else {
                geometry = geometryReader(object, arcs);
              }
              geometry = transformGeometryWithOptions(geometry, false, opt_options);
            }
            var feature = new ol_Feature({ geometry });
            if (object.id !== void 0) {
              feature.setId(object.id);
            }
            var properties = object.properties;
            if (property) {
              if (!properties) {
                properties = {};
              }
              properties[property] = name;
            }
            if (properties) {
              feature.setProperties(properties, true);
            }
            return feature;
          }
          function transformArcs(arcs, scale, translate) {
            for (var i = 0, ii = arcs.length; i < ii; ++i) {
              transformArc(arcs[i], scale, translate);
            }
          }
          function transformArc(arc, scale, translate) {
            var x = 0;
            var y = 0;
            for (var i = 0, ii = arc.length; i < ii; ++i) {
              var vertex = arc[i];
              x += vertex[0];
              y += vertex[1];
              vertex[0] = x;
              vertex[1] = y;
              transformVertex(vertex, scale, translate);
            }
          }
          function transformVertex(vertex, scale, translate) {
            vertex[0] = vertex[0] * scale[0] + translate[0];
            vertex[1] = vertex[1] * scale[1] + translate[1];
          }
          var format_TopoJSON = TopoJSON_TopoJSON;
          var GML32_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GML32 = (
            /** @class */
            function(_super) {
              GML32_extends(GML322, _super);
              function GML322(opt_options) {
                var _this = this;
                var options = (
                  /** @type {import("./GMLBase.js").Options} */
                  opt_options ? opt_options : {}
                );
                _this = _super.call(this, options) || this;
                _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
                return _this;
              }
              return GML322;
            }(format_GML3)
          );
          GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
          GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "pos": makeReplacer(format_GML3.prototype.readFlatPos),
              "posList": makeReplacer(format_GML3.prototype.readFlatPosList),
              "coordinates": makeReplacer(format_GML2.prototype.readFlatCoordinates)
            }
          };
          GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "interior": format_GML3.prototype.interiorParser,
              "exterior": format_GML3.prototype.exteriorParser
            }
          };
          GML32.prototype.GEOMETRY_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "Point": makeReplacer(format_GMLBase.prototype.readPoint),
              "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
              "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
              "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
              "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
              "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
              "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
              "Surface": makeReplacer(GML32.prototype.readSurface),
              "MultiSurface": makeReplacer(format_GML3.prototype.readMultiSurface),
              "Curve": makeReplacer(GML32.prototype.readCurve),
              "MultiCurve": makeReplacer(format_GML3.prototype.readMultiCurve),
              "Envelope": makeReplacer(GML32.prototype.readEnvelope)
            }
          };
          GML32.prototype.MULTICURVE_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "curveMember": makeArrayPusher(format_GML3.prototype.curveMemberParser),
              "curveMembers": makeArrayPusher(format_GML3.prototype.curveMemberParser)
            }
          };
          GML32.prototype.MULTISURFACE_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "surfaceMember": makeArrayPusher(format_GML3.prototype.surfaceMemberParser),
              "surfaceMembers": makeArrayPusher(format_GML3.prototype.surfaceMemberParser)
            }
          };
          GML32.prototype.CURVEMEMBER_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString),
              "Curve": makeArrayPusher(format_GML3.prototype.readCurve)
            }
          };
          GML32.prototype.SURFACEMEMBER_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon),
              "Surface": makeArrayPusher(format_GML3.prototype.readSurface)
            }
          };
          GML32.prototype.SURFACE_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "patches": makeReplacer(format_GML3.prototype.readPatch)
            }
          };
          GML32.prototype.CURVE_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "segments": makeReplacer(format_GML3.prototype.readSegment)
            }
          };
          GML32.prototype.ENVELOPE_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "lowerCorner": makeArrayPusher(format_GML3.prototype.readFlatPosList),
              "upperCorner": makeArrayPusher(format_GML3.prototype.readFlatPosList)
            }
          };
          GML32.prototype.PATCHES_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "PolygonPatch": makeReplacer(format_GML3.prototype.readPolygonPatch)
            }
          };
          GML32.prototype.SEGMENTS_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "LineStringSegment": makeReplacer(format_GML3.prototype.readLineStringSegment)
            }
          };
          GML32.prototype.MULTIPOINT_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "pointMember": makeArrayPusher(format_GMLBase.prototype.pointMemberParser),
              "pointMembers": makeArrayPusher(format_GMLBase.prototype.pointMemberParser)
            }
          };
          GML32.prototype.MULTILINESTRING_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "lineStringMember": makeArrayPusher(format_GMLBase.prototype.lineStringMemberParser),
              "lineStringMembers": makeArrayPusher(format_GMLBase.prototype.lineStringMemberParser)
            }
          };
          GML32.prototype.MULTIPOLYGON_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "polygonMember": makeArrayPusher(format_GMLBase.prototype.polygonMemberParser),
              "polygonMembers": makeArrayPusher(format_GMLBase.prototype.polygonMemberParser)
            }
          };
          GML32.prototype.POINTMEMBER_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "Point": makeArrayPusher(format_GMLBase.prototype.readFlatCoordinatesFromNode)
            }
          };
          GML32.prototype.LINESTRINGMEMBER_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString)
            }
          };
          GML32.prototype.POLYGONMEMBER_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon)
            }
          };
          GML32.prototype.RING_PARSERS = {
            "http://www.opengis.net/gml/3.2": {
              "LinearRing": makeReplacer(format_GMLBase.prototype.readFlatLinearRing)
            }
          };
          GML32.prototype.RING_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "exterior": makeChildAppender(format_GML3.prototype.writeRing),
              "interior": makeChildAppender(format_GML3.prototype.writeRing)
            }
          };
          GML32.prototype.ENVELOPE_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "lowerCorner": makeChildAppender(writeStringTextNode),
              "upperCorner": makeChildAppender(writeStringTextNode)
            }
          };
          GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "surfaceMember": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygonMember),
              "polygonMember": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygonMember)
            }
          };
          GML32.prototype.POINTMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "pointMember": makeChildAppender(format_GML3.prototype.writePointMember)
            }
          };
          GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "lineStringMember": makeChildAppender(format_GML3.prototype.writeLineStringOrCurveMember),
              "curveMember": makeChildAppender(format_GML3.prototype.writeLineStringOrCurveMember)
            }
          };
          GML32.prototype.GEOMETRY_SERIALIZERS = {
            "http://www.opengis.net/gml/3.2": {
              "Curve": makeChildAppender(format_GML3.prototype.writeCurveOrLineString),
              "MultiCurve": makeChildAppender(format_GML3.prototype.writeMultiCurveOrLineString),
              "Point": makeChildAppender(GML32.prototype.writePoint),
              "MultiPoint": makeChildAppender(format_GML3.prototype.writeMultiPoint),
              "LineString": makeChildAppender(format_GML3.prototype.writeCurveOrLineString),
              "MultiLineString": makeChildAppender(format_GML3.prototype.writeMultiCurveOrLineString),
              "LinearRing": makeChildAppender(format_GML3.prototype.writeLinearRing),
              "Polygon": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygon),
              "MultiPolygon": makeChildAppender(format_GML3.prototype.writeMultiSurfaceOrPolygon),
              "Surface": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygon),
              "MultiSurface": makeChildAppender(format_GML3.prototype.writeMultiSurfaceOrPolygon),
              "Envelope": makeChildAppender(format_GML3.prototype.writeEnvelope)
            }
          };
          var format_GML32 = GML32;
          var Filter = (
            /** @class */
            function() {
              function Filter2(tagName) {
                this.tagName_ = tagName;
              }
              Filter2.prototype.getTagName = function() {
                return this.tagName_;
              };
              return Filter2;
            }()
          );
          var filter_Filter = Filter;
          var LogicalNary_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LogicalNary_LogicalNary = (
            /** @class */
            function(_super) {
              LogicalNary_extends(LogicalNary, _super);
              function LogicalNary(tagName, conditions) {
                var _this = _super.call(this, tagName) || this;
                _this.conditions = conditions;
                assert2(_this.conditions.length >= 2, 57);
                return _this;
              }
              return LogicalNary;
            }(filter_Filter)
          );
          var filter_LogicalNary = LogicalNary_LogicalNary;
          var And_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var And = (
            /** @class */
            function(_super) {
              And_extends(And2, _super);
              function And2(conditions) {
                return _super.call(this, "And", Array.prototype.slice.call(arguments)) || this;
              }
              return And2;
            }(filter_LogicalNary)
          );
          var filter_And = And;
          var Bbox_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Bbox = (
            /** @class */
            function(_super) {
              Bbox_extends(Bbox2, _super);
              function Bbox2(geometryName, extent, opt_srsName) {
                var _this = _super.call(this, "BBOX") || this;
                _this.geometryName = geometryName;
                _this.extent = extent;
                if (extent.length !== 4) {
                  throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
                }
                _this.srsName = opt_srsName;
                return _this;
              }
              return Bbox2;
            }(filter_Filter)
          );
          var filter_Bbox = Bbox;
          var Spatial_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Spatial = (
            /** @class */
            function(_super) {
              Spatial_extends(Spatial2, _super);
              function Spatial2(tagName, geometryName, geometry, opt_srsName) {
                var _this = _super.call(this, tagName) || this;
                _this.geometryName = geometryName || "the_geom";
                _this.geometry = geometry;
                _this.srsName = opt_srsName;
                return _this;
              }
              return Spatial2;
            }(filter_Filter)
          );
          var filter_Spatial = Spatial;
          var Contains_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Contains = (
            /** @class */
            function(_super) {
              Contains_extends(Contains2, _super);
              function Contains2(geometryName, geometry, opt_srsName) {
                return _super.call(this, "Contains", geometryName, geometry, opt_srsName) || this;
              }
              return Contains2;
            }(filter_Spatial)
          );
          var filter_Contains = Contains;
          var DWithin_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var DWithin = (
            /** @class */
            function(_super) {
              DWithin_extends(DWithin2, _super);
              function DWithin2(geometryName, geometry, distance, unit, opt_srsName) {
                var _this = _super.call(this, "DWithin", geometryName, geometry, opt_srsName) || this;
                _this.distance = distance;
                _this.unit = unit;
                return _this;
              }
              return DWithin2;
            }(filter_Spatial)
          );
          var filter_DWithin = DWithin;
          var Disjoint_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Disjoint = (
            /** @class */
            function(_super) {
              Disjoint_extends(Disjoint2, _super);
              function Disjoint2(geometryName, geometry, opt_srsName) {
                return _super.call(this, "Disjoint", geometryName, geometry, opt_srsName) || this;
              }
              return Disjoint2;
            }(filter_Spatial)
          );
          var filter_Disjoint = Disjoint;
          var Comparison_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Comparison = (
            /** @class */
            function(_super) {
              Comparison_extends(Comparison2, _super);
              function Comparison2(tagName, propertyName) {
                var _this = _super.call(this, tagName) || this;
                _this.propertyName = propertyName;
                return _this;
              }
              return Comparison2;
            }(filter_Filter)
          );
          var filter_Comparison = Comparison;
          var During_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var During = (
            /** @class */
            function(_super) {
              During_extends(During2, _super);
              function During2(propertyName, begin, end) {
                var _this = _super.call(this, "During", propertyName) || this;
                _this.begin = begin;
                _this.end = end;
                return _this;
              }
              return During2;
            }(filter_Comparison)
          );
          var filter_During = During;
          var ComparisonBinary_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ComparisonBinary = (
            /** @class */
            function(_super) {
              ComparisonBinary_extends(ComparisonBinary2, _super);
              function ComparisonBinary2(tagName, propertyName, expression, opt_matchCase) {
                var _this = _super.call(this, tagName, propertyName) || this;
                _this.expression = expression;
                _this.matchCase = opt_matchCase;
                return _this;
              }
              return ComparisonBinary2;
            }(filter_Comparison)
          );
          var filter_ComparisonBinary = ComparisonBinary;
          var EqualTo_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var EqualTo = (
            /** @class */
            function(_super) {
              EqualTo_extends(EqualTo2, _super);
              function EqualTo2(propertyName, expression, opt_matchCase) {
                return _super.call(this, "PropertyIsEqualTo", propertyName, expression, opt_matchCase) || this;
              }
              return EqualTo2;
            }(filter_ComparisonBinary)
          );
          var filter_EqualTo = EqualTo;
          var GreaterThan_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GreaterThan = (
            /** @class */
            function(_super) {
              GreaterThan_extends(GreaterThan2, _super);
              function GreaterThan2(propertyName, expression) {
                return _super.call(this, "PropertyIsGreaterThan", propertyName, expression) || this;
              }
              return GreaterThan2;
            }(filter_ComparisonBinary)
          );
          var filter_GreaterThan = GreaterThan;
          var GreaterThanOrEqualTo_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GreaterThanOrEqualTo = (
            /** @class */
            function(_super) {
              GreaterThanOrEqualTo_extends(GreaterThanOrEqualTo2, _super);
              function GreaterThanOrEqualTo2(propertyName, expression) {
                return _super.call(this, "PropertyIsGreaterThanOrEqualTo", propertyName, expression) || this;
              }
              return GreaterThanOrEqualTo2;
            }(filter_ComparisonBinary)
          );
          var filter_GreaterThanOrEqualTo = GreaterThanOrEqualTo;
          var Intersects_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Intersects = (
            /** @class */
            function(_super) {
              Intersects_extends(Intersects2, _super);
              function Intersects2(geometryName, geometry, opt_srsName) {
                return _super.call(this, "Intersects", geometryName, geometry, opt_srsName) || this;
              }
              return Intersects2;
            }(filter_Spatial)
          );
          var filter_Intersects = Intersects;
          var IsBetween_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var IsBetween = (
            /** @class */
            function(_super) {
              IsBetween_extends(IsBetween2, _super);
              function IsBetween2(propertyName, lowerBoundary, upperBoundary) {
                var _this = _super.call(this, "PropertyIsBetween", propertyName) || this;
                _this.lowerBoundary = lowerBoundary;
                _this.upperBoundary = upperBoundary;
                return _this;
              }
              return IsBetween2;
            }(filter_Comparison)
          );
          var filter_IsBetween = IsBetween;
          var IsLike_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var IsLike = (
            /** @class */
            function(_super) {
              IsLike_extends(IsLike2, _super);
              function IsLike2(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
                var _this = _super.call(this, "PropertyIsLike", propertyName) || this;
                _this.pattern = pattern;
                _this.wildCard = opt_wildCard !== void 0 ? opt_wildCard : "*";
                _this.singleChar = opt_singleChar !== void 0 ? opt_singleChar : ".";
                _this.escapeChar = opt_escapeChar !== void 0 ? opt_escapeChar : "!";
                _this.matchCase = opt_matchCase;
                return _this;
              }
              return IsLike2;
            }(filter_Comparison)
          );
          var filter_IsLike = IsLike;
          var IsNull_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var IsNull = (
            /** @class */
            function(_super) {
              IsNull_extends(IsNull2, _super);
              function IsNull2(propertyName) {
                return _super.call(this, "PropertyIsNull", propertyName) || this;
              }
              return IsNull2;
            }(filter_Comparison)
          );
          var filter_IsNull = IsNull;
          var LessThan_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LessThan = (
            /** @class */
            function(_super) {
              LessThan_extends(LessThan2, _super);
              function LessThan2(propertyName, expression) {
                return _super.call(this, "PropertyIsLessThan", propertyName, expression) || this;
              }
              return LessThan2;
            }(filter_ComparisonBinary)
          );
          var filter_LessThan = LessThan;
          var LessThanOrEqualTo_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LessThanOrEqualTo = (
            /** @class */
            function(_super) {
              LessThanOrEqualTo_extends(LessThanOrEqualTo2, _super);
              function LessThanOrEqualTo2(propertyName, expression) {
                return _super.call(this, "PropertyIsLessThanOrEqualTo", propertyName, expression) || this;
              }
              return LessThanOrEqualTo2;
            }(filter_ComparisonBinary)
          );
          var filter_LessThanOrEqualTo = LessThanOrEqualTo;
          var Not_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Not = (
            /** @class */
            function(_super) {
              Not_extends(Not2, _super);
              function Not2(condition) {
                var _this = _super.call(this, "Not") || this;
                _this.condition = condition;
                return _this;
              }
              return Not2;
            }(filter_Filter)
          );
          var filter_Not = Not;
          var NotEqualTo_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var NotEqualTo = (
            /** @class */
            function(_super) {
              NotEqualTo_extends(NotEqualTo2, _super);
              function NotEqualTo2(propertyName, expression, opt_matchCase) {
                return _super.call(this, "PropertyIsNotEqualTo", propertyName, expression, opt_matchCase) || this;
              }
              return NotEqualTo2;
            }(filter_ComparisonBinary)
          );
          var filter_NotEqualTo = NotEqualTo;
          var Or_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Or = (
            /** @class */
            function(_super) {
              Or_extends(Or2, _super);
              function Or2(conditions) {
                return _super.call(this, "Or", Array.prototype.slice.call(arguments)) || this;
              }
              return Or2;
            }(filter_LogicalNary)
          );
          var filter_Or = Or;
          var ResourceId_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ResourceId = (
            /** @class */
            function(_super) {
              ResourceId_extends(ResourceId2, _super);
              function ResourceId2(rid) {
                var _this = _super.call(this, "ResourceId") || this;
                _this.rid = rid;
                return _this;
              }
              return ResourceId2;
            }(filter_Filter)
          );
          var filter_ResourceId = ResourceId;
          var Within_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Within = (
            /** @class */
            function(_super) {
              Within_extends(Within2, _super);
              function Within2(geometryName, geometry, opt_srsName) {
                return _super.call(this, "Within", geometryName, geometry, opt_srsName) || this;
              }
              return Within2;
            }(filter_Spatial)
          );
          var filter_Within = Within;
          function and(conditions) {
            var params = [null].concat(Array.prototype.slice.call(arguments));
            return new (Function.prototype.bind.apply(filter_And, params))();
          }
          function or(conditions) {
            var params = [null].concat(Array.prototype.slice.call(arguments));
            return new (Function.prototype.bind.apply(filter_Or, params))();
          }
          function not(condition) {
            return new filter_Not(condition);
          }
          function filter_bbox(geometryName, extent, opt_srsName) {
            return new filter_Bbox(geometryName, extent, opt_srsName);
          }
          function filter_contains(geometryName, geometry, opt_srsName) {
            return new filter_Contains(geometryName, geometry, opt_srsName);
          }
          function filter_intersects(geometryName, geometry, opt_srsName) {
            return new filter_Intersects(geometryName, geometry, opt_srsName);
          }
          function disjoint(geometryName, geometry, opt_srsName) {
            return new filter_Disjoint(geometryName, geometry, opt_srsName);
          }
          function within(geometryName, geometry, opt_srsName) {
            return new filter_Within(geometryName, geometry, opt_srsName);
          }
          function dwithin(geometryName, geometry, distance, unit, opt_srsName) {
            return new filter_DWithin(geometryName, geometry, distance, unit, opt_srsName);
          }
          function equalTo(propertyName, expression, opt_matchCase) {
            return new filter_EqualTo(propertyName, expression, opt_matchCase);
          }
          function notEqualTo(propertyName, expression, opt_matchCase) {
            return new filter_NotEqualTo(propertyName, expression, opt_matchCase);
          }
          function lessThan(propertyName, expression) {
            return new filter_LessThan(propertyName, expression);
          }
          function lessThanOrEqualTo(propertyName, expression) {
            return new filter_LessThanOrEqualTo(propertyName, expression);
          }
          function greaterThan(propertyName, expression) {
            return new filter_GreaterThan(propertyName, expression);
          }
          function greaterThanOrEqualTo(propertyName, expression) {
            return new filter_GreaterThanOrEqualTo(propertyName, expression);
          }
          function isNull(propertyName) {
            return new filter_IsNull(propertyName);
          }
          function between(propertyName, lowerBoundary, upperBoundary) {
            return new filter_IsBetween(propertyName, lowerBoundary, upperBoundary);
          }
          function like(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
            return new filter_IsLike(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
          }
          function during(propertyName, begin, end) {
            return new filter_During(propertyName, begin, end);
          }
          function resourceId(rid) {
            return new filter_ResourceId(rid);
          }
          var WFS_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var FEATURE_COLLECTION_PARSERS = {
            "http://www.opengis.net/gml": {
              "boundedBy": makeObjectPropertySetter(format_GMLBase.prototype.readGeometryElement, "bounds")
            },
            "http://www.opengis.net/wfs/2.0": {
              "member": makeArrayPusher(format_GMLBase.prototype.readFeaturesInternal)
            }
          };
          var TRANSACTION_SUMMARY_PARSERS = {
            "http://www.opengis.net/wfs": {
              "totalInserted": makeObjectPropertySetter(readNonNegativeInteger),
              "totalUpdated": makeObjectPropertySetter(readNonNegativeInteger),
              "totalDeleted": makeObjectPropertySetter(readNonNegativeInteger)
            },
            "http://www.opengis.net/wfs/2.0": {
              "totalInserted": makeObjectPropertySetter(readNonNegativeInteger),
              "totalUpdated": makeObjectPropertySetter(readNonNegativeInteger),
              "totalDeleted": makeObjectPropertySetter(readNonNegativeInteger)
            }
          };
          var TRANSACTION_RESPONSE_PARSERS = {
            "http://www.opengis.net/wfs": {
              "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
              "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
            },
            "http://www.opengis.net/wfs/2.0": {
              "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
              "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
            }
          };
          var QUERY_SERIALIZERS = {
            "http://www.opengis.net/wfs": {
              "PropertyName": makeChildAppender(writeStringTextNode)
            },
            "http://www.opengis.net/wfs/2.0": {
              "PropertyName": makeChildAppender(writeStringTextNode)
            }
          };
          var TRANSACTION_SERIALIZERS = {
            "http://www.opengis.net/wfs": {
              "Insert": makeChildAppender(writeFeature),
              "Update": makeChildAppender(writeUpdate),
              "Delete": makeChildAppender(writeDelete),
              "Property": makeChildAppender(writeProperty),
              "Native": makeChildAppender(writeNative)
            },
            "http://www.opengis.net/wfs/2.0": {
              "Insert": makeChildAppender(writeFeature),
              "Update": makeChildAppender(writeUpdate),
              "Delete": makeChildAppender(writeDelete),
              "Property": makeChildAppender(writeProperty),
              "Native": makeChildAppender(writeNative)
            }
          };
          var FEATURE_PREFIX = "feature";
          var XMLNS = "http://www.w3.org/2000/xmlns/";
          var OGCNS = {
            "2.0.0": "http://www.opengis.net/ogc/1.1",
            "1.1.0": "http://www.opengis.net/ogc",
            "1.0.0": "http://www.opengis.net/ogc"
          };
          var WFSNS = {
            "2.0.0": "http://www.opengis.net/wfs/2.0",
            "1.1.0": "http://www.opengis.net/wfs",
            "1.0.0": "http://www.opengis.net/wfs"
          };
          var FESNS = {
            "2.0.0": "http://www.opengis.net/fes/2.0",
            "1.1.0": "http://www.opengis.net/fes",
            "1.0.0": "http://www.opengis.net/fes"
          };
          var SCHEMA_LOCATIONS = {
            "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
            "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
            "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
          };
          var GML_FORMATS = {
            "2.0.0": format_GML32,
            "1.1.0": format_GML3,
            "1.0.0": format_GML2
          };
          var DEFAULT_VERSION = "1.1.0";
          var WFS_WFS = (
            /** @class */
            function(_super) {
              WFS_extends(WFS, _super);
              function WFS(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.version_ = options.version ? options.version : DEFAULT_VERSION;
                _this.featureType_ = options.featureType;
                _this.featureNS_ = options.featureNS;
                _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();
                _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];
                return _this;
              }
              WFS.prototype.getFeatureType = function() {
                return this.featureType_;
              };
              WFS.prototype.setFeatureType = function(featureType) {
                this.featureType_ = featureType;
              };
              WFS.prototype.readFeaturesFromNode = function(node, opt_options) {
                var context = {
                  node
                };
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(context, {
                  "featureType": this.featureType_,
                  "featureNS": this.featureNS_
                });
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(context, this.getReadOptions(node, opt_options ? opt_options : {}));
                var objectStack = [context];
                var featuresNS;
                if (this.version_ === "2.0.0") {
                  featuresNS = FEATURE_COLLECTION_PARSERS;
                } else {
                  featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
                }
                var features = pushParseAndPop([], featuresNS, node, objectStack, this.gmlFormat_);
                if (!features) {
                  features = [];
                }
                return features;
              };
              WFS.prototype.readTransactionResponse = function(source) {
                if (!source) {
                  return void 0;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readTransactionResponseFromDocument(doc);
                } else if (isDocument(source)) {
                  return this.readTransactionResponseFromDocument(
                    /** @type {Document} */
                    source
                  );
                } else {
                  return this.readTransactionResponseFromNode(
                    /** @type {Element} */
                    source
                  );
                }
              };
              WFS.prototype.readFeatureCollectionMetadata = function(source) {
                if (!source) {
                  return void 0;
                } else if (typeof source === "string") {
                  var doc = parse2(source);
                  return this.readFeatureCollectionMetadataFromDocument(doc);
                } else if (isDocument(source)) {
                  return this.readFeatureCollectionMetadataFromDocument(
                    /** @type {Document} */
                    source
                  );
                } else {
                  return this.readFeatureCollectionMetadataFromNode(
                    /** @type {Element} */
                    source
                  );
                }
              };
              WFS.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {
                for (var n = (
                  /** @type {Node} */
                  doc.firstChild
                ); n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    return this.readFeatureCollectionMetadataFromNode(
                      /** @type {Element} */
                      n
                    );
                  }
                }
                return void 0;
              };
              WFS.prototype.readFeatureCollectionMetadataFromNode = function(node) {
                var result = {};
                var value = readNonNegativeIntegerString(node.getAttribute("numberOfFeatures"));
                result["numberOfFeatures"] = value;
                return pushParseAndPop(
                  /** @type {FeatureCollectionMetadata} */
                  result,
                  FEATURE_COLLECTION_PARSERS,
                  node,
                  [],
                  this.gmlFormat_
                );
              };
              WFS.prototype.readTransactionResponseFromDocument = function(doc) {
                for (var n = (
                  /** @type {Node} */
                  doc.firstChild
                ); n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    return this.readTransactionResponseFromNode(
                      /** @type {Element} */
                      n
                    );
                  }
                }
                return void 0;
              };
              WFS.prototype.readTransactionResponseFromNode = function(node) {
                return pushParseAndPop(
                  /** @type {TransactionResponse} */
                  {},
                  TRANSACTION_RESPONSE_PARSERS,
                  node,
                  []
                );
              };
              WFS.prototype.writeGetFeature = function(options) {
                var _this = this;
                var node = createElementNS(WFSNS[this.version_], "GetFeature");
                node.setAttribute("service", "WFS");
                node.setAttribute("version", this.version_);
                if (options.handle) {
                  node.setAttribute("handle", options.handle);
                }
                if (options.outputFormat) {
                  node.setAttribute("outputFormat", options.outputFormat);
                }
                if (options.maxFeatures !== void 0) {
                  node.setAttribute("maxFeatures", String(options.maxFeatures));
                }
                if (options.resultType) {
                  node.setAttribute("resultType", options.resultType);
                }
                if (options.startIndex !== void 0) {
                  node.setAttribute("startIndex", String(options.startIndex));
                }
                if (options.count !== void 0) {
                  node.setAttribute("count", String(options.count));
                }
                if (options.viewParams !== void 0) {
                  node.setAttribute("viewParams", options.viewParams);
                }
                node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation_);
                var context = {
                  node
                };
                Object(ol_obj[
                  "a"
                  /* assign */
                ])(context, {
                  "version": this.version_,
                  "srsName": options.srsName,
                  "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
                  "featurePrefix": options.featurePrefix,
                  "propertyNames": options.propertyNames ? options.propertyNames : []
                });
                assert2(Array.isArray(options.featureTypes), 11);
                if (typeof options.featureTypes[0] === "string") {
                  var filter = options.filter;
                  if (options.bbox) {
                    assert2(options.geometryName, 12);
                    filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
                  }
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(context, {
                    "geometryName": options.geometryName,
                    "filter": filter
                  });
                  writeGetFeature(
                    node,
                    /** @type {!Array<string>} */
                    options.featureTypes,
                    [context]
                  );
                } else {
                  options.featureTypes.forEach(function(featureType) {
                    var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
                    Object(ol_obj[
                      "a"
                      /* assign */
                    ])(context, {
                      "geometryName": featureType.geometryName,
                      "filter": completeFilter
                    });
                    writeGetFeature(node, [featureType.name], [context]);
                  });
                }
                return node;
              };
              WFS.prototype.combineBboxAndFilter = function(geometryName, extent, opt_srsName, opt_filter) {
                var bboxFilter = filter_bbox(geometryName, extent, opt_srsName);
                if (opt_filter) {
                  return and(opt_filter, bboxFilter);
                }
                return bboxFilter;
              };
              WFS.prototype.writeTransaction = function(inserts, updates, deletes, options) {
                var objectStack = [];
                var version = options.version ? options.version : this.version_;
                var node = createElementNS(WFSNS[version], "Transaction");
                node.setAttribute("service", "WFS");
                node.setAttribute("version", version);
                var baseObj;
                if (options) {
                  baseObj = options.gmlOptions ? options.gmlOptions : {};
                  if (options.handle) {
                    node.setAttribute("handle", options.handle);
                  }
                }
                node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATIONS[version]);
                var request = createTransactionRequest(node, baseObj, version, options);
                if (inserts) {
                  serializeTransactionRequest("Insert", inserts, objectStack, request);
                }
                if (updates) {
                  serializeTransactionRequest("Update", updates, objectStack, request);
                }
                if (deletes) {
                  serializeTransactionRequest("Delete", deletes, objectStack, request);
                }
                if (options.nativeElements) {
                  serializeTransactionRequest("Native", options.nativeElements, objectStack, request);
                }
                return node;
              };
              WFS.prototype.readProjectionFromDocument = function(doc) {
                for (var n = doc.firstChild; n; n = n.nextSibling) {
                  if (n.nodeType == Node.ELEMENT_NODE) {
                    return this.readProjectionFromNode(
                      /** @type {Element} */
                      n
                    );
                  }
                }
                return null;
              };
              WFS.prototype.readProjectionFromNode = function(node) {
                if (node.firstElementChild && node.firstElementChild.firstElementChild) {
                  node = node.firstElementChild.firstElementChild;
                  for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                    if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
                      var objectStack = [{}];
                      this.gmlFormat_.readGeometryElement(n, objectStack);
                      return proj_get(objectStack.pop().srsName);
                    }
                  }
                }
                return null;
              };
              return WFS;
            }(format_XMLFeature)
          );
          function createTransactionRequest(node, baseObj, version, options) {
            var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
            var gmlVersion;
            if (version === "1.0.0") {
              gmlVersion = 2;
            } else if (version === "1.1.0") {
              gmlVersion = 3;
            } else if (version === "2.0.0") {
              gmlVersion = 3.2;
            }
            var obj = Object(ol_obj[
              "a"
              /* assign */
            ])({ node }, {
              version,
              "featureNS": options.featureNS,
              "featureType": options.featureType,
              "featurePrefix": featurePrefix,
              "gmlVersion": gmlVersion,
              "hasZ": options.hasZ,
              "srsName": options.srsName
            }, baseObj);
            return obj;
          }
          function serializeTransactionRequest(type, features, objectStack, request) {
            pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);
          }
          function readTransactionSummary(node, objectStack) {
            return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
          }
          var OGC_FID_PARSERS = {
            "http://www.opengis.net/ogc": {
              "FeatureId": makeArrayPusher(function(node, objectStack) {
                return node.getAttribute("fid");
              })
            },
            "http://www.opengis.net/ogc/1.1": {
              "FeatureId": makeArrayPusher(function(node, objectStack) {
                return node.getAttribute("fid");
              })
            }
          };
          function fidParser(node, objectStack) {
            parseNode(OGC_FID_PARSERS, node, objectStack);
          }
          var INSERT_RESULTS_PARSERS = {
            "http://www.opengis.net/wfs": {
              "Feature": fidParser
            },
            "http://www.opengis.net/wfs/2.0": {
              "Feature": fidParser
            }
          };
          function readInsertResults(node, objectStack) {
            return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);
          }
          function writeFeature(node, feature, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var featureType = context["featureType"];
            var featureNS = context["featureNS"];
            var gmlVersion = context["gmlVersion"];
            var child = createElementNS(featureNS, featureType);
            node.appendChild(child);
            if (gmlVersion === 2) {
              format_GML2.prototype.writeFeatureElement(child, feature, objectStack);
            } else if (gmlVersion === 3) {
              format_GML3.prototype.writeFeatureElement(child, feature, objectStack);
            } else {
              format_GML32.prototype.writeFeatureElement(child, feature, objectStack);
            }
          }
          function writeOgcFidFilter(node, fid, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var version = context["version"];
            var ns = OGCNS[version];
            var filter = createElementNS(ns, "Filter");
            var child = createElementNS(ns, "FeatureId");
            filter.appendChild(child);
            child.setAttribute(
              "fid",
              /** @type {string} */
              fid
            );
            node.appendChild(filter);
          }
          function getTypeName(featurePrefix, featureType) {
            featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
            var prefix = featurePrefix + ":";
            if (featureType.indexOf(prefix) === 0) {
              return featureType;
            } else {
              return prefix + featureType;
            }
          }
          function writeDelete(node, feature, objectStack) {
            var context = objectStack[objectStack.length - 1];
            assert2(feature.getId() !== void 0, 26);
            var featureType = context["featureType"];
            var featurePrefix = context["featurePrefix"];
            var featureNS = context["featureNS"];
            var typeName = getTypeName(featurePrefix, featureType);
            node.setAttribute("typeName", typeName);
            node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
            var fid = feature.getId();
            if (fid !== void 0) {
              writeOgcFidFilter(node, fid, objectStack);
            }
          }
          function writeUpdate(node, feature, objectStack) {
            var context = objectStack[objectStack.length - 1];
            assert2(feature.getId() !== void 0, 27);
            var version = context["version"];
            var featureType = context["featureType"];
            var featurePrefix = context["featurePrefix"];
            var featureNS = context["featureNS"];
            var typeName = getTypeName(featurePrefix, featureType);
            var geometryName = feature.getGeometryName();
            node.setAttribute("typeName", typeName);
            node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
            var fid = feature.getId();
            if (fid !== void 0) {
              var keys = feature.getKeys();
              var values = [];
              for (var i = 0, ii = keys.length; i < ii; i++) {
                var value = feature.get(keys[i]);
                if (value !== void 0) {
                  var name_1 = keys[i];
                  if (value && typeof /** @type {?} */
                  value.getSimplifiedGeometry === "function") {
                    name_1 = geometryName;
                  }
                  values.push({ name: name_1, value });
                }
              }
              pushSerializeAndPop(
                /** @type {import("../xml.js").NodeStackItem} */
                {
                  version,
                  "gmlVersion": context["gmlVersion"],
                  node,
                  "hasZ": context["hasZ"],
                  "srsName": context["srsName"]
                },
                TRANSACTION_SERIALIZERS,
                makeSimpleNodeFactory("Property"),
                values,
                objectStack
              );
              writeOgcFidFilter(node, fid, objectStack);
            }
          }
          function writeProperty(node, pair, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var version = context["version"];
            var ns = WFSNS[version];
            var name = createElementNS(ns, "Name");
            var gmlVersion = context["gmlVersion"];
            node.appendChild(name);
            writeStringTextNode(name, pair.name);
            if (pair.value !== void 0 && pair.value !== null) {
              var value = createElementNS(ns, "Value");
              node.appendChild(value);
              if (pair.value && typeof /** @type {?} */
              pair.value.getSimplifiedGeometry === "function") {
                if (gmlVersion === 2) {
                  format_GML2.prototype.writeGeometryElement(value, pair.value, objectStack);
                } else if (gmlVersion === 3) {
                  format_GML3.prototype.writeGeometryElement(value, pair.value, objectStack);
                } else {
                  format_GML32.prototype.writeGeometryElement(value, pair.value, objectStack);
                }
              } else {
                writeStringTextNode(value, pair.value);
              }
            }
          }
          function writeNative(node, nativeElement, objectStack) {
            if (nativeElement.vendorId) {
              node.setAttribute("vendorId", nativeElement.vendorId);
            }
            if (nativeElement.safeToIgnore !== void 0) {
              node.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
            }
            if (nativeElement.value !== void 0) {
              writeStringTextNode(node, nativeElement.value);
            }
          }
          var GETFEATURE_SERIALIZERS = {
            "http://www.opengis.net/wfs": {
              "Query": makeChildAppender(writeQuery)
            },
            "http://www.opengis.net/wfs/2.0": {
              "Query": makeChildAppender(writeQuery)
            },
            "http://www.opengis.net/ogc": {
              "During": makeChildAppender(writeDuringFilter),
              "And": makeChildAppender(writeLogicalFilter),
              "Or": makeChildAppender(writeLogicalFilter),
              "Not": makeChildAppender(writeNotFilter),
              "BBOX": makeChildAppender(writeBboxFilter),
              "Contains": makeChildAppender(writeSpatialFilter),
              "Intersects": makeChildAppender(writeSpatialFilter),
              "Within": makeChildAppender(writeSpatialFilter),
              "DWithin": makeChildAppender(writeDWithinFilter),
              "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
              "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
              "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsNull": makeChildAppender(writeIsNullFilter),
              "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
              "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
            },
            "http://www.opengis.net/fes/2.0": {
              "During": makeChildAppender(writeDuringFilter),
              "And": makeChildAppender(writeLogicalFilter),
              "Or": makeChildAppender(writeLogicalFilter),
              "Not": makeChildAppender(writeNotFilter),
              "BBOX": makeChildAppender(writeBboxFilter),
              "Contains": makeChildAppender(writeSpatialFilter),
              "Disjoint": makeChildAppender(writeSpatialFilter),
              "Intersects": makeChildAppender(writeSpatialFilter),
              "ResourceId": makeChildAppender(writeResourceIdFilter),
              "Within": makeChildAppender(writeSpatialFilter),
              "DWithin": makeChildAppender(writeDWithinFilter),
              "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
              "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
              "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
              "PropertyIsNull": makeChildAppender(writeIsNullFilter),
              "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
              "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
            }
          };
          function writeQuery(node, featureType, objectStack) {
            var context = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var version = context["version"];
            var featurePrefix = context["featurePrefix"];
            var featureNS = context["featureNS"];
            var propertyNames = context["propertyNames"];
            var srsName = context["srsName"];
            var typeName;
            if (featurePrefix) {
              typeName = getTypeName(featurePrefix, featureType);
            } else {
              typeName = featureType;
            }
            var typeNameAttr;
            if (version === "2.0.0") {
              typeNameAttr = "typeNames";
            } else {
              typeNameAttr = "typeName";
            }
            node.setAttribute(typeNameAttr, typeName);
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            if (featureNS) {
              node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
            }
            var item = (
              /** @type {import("../xml.js").NodeStackItem} */
              Object(ol_obj[
                "a"
                /* assign */
              ])({}, context)
            );
            item.node = node;
            pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
            var filter = context["filter"];
            if (filter) {
              var child = createElementNS(getFilterNS(version), "Filter");
              node.appendChild(child);
              writeFilterCondition(child, filter, objectStack);
            }
          }
          function writeFilterCondition(node, filter, objectStack) {
            var context = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var item = { node };
            Object(ol_obj[
              "a"
              /* assign */
            ])(item, { context });
            pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
          }
          function writeBboxFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            parent["srsName"] = filter.srsName;
            var format = GML_FORMATS[version];
            writePropertyName(version, node, filter.geometryName);
            format.prototype.writeGeometryElement(node, filter.extent, objectStack);
          }
          function writeResourceIdFilter(node, filter, objectStack) {
            node.setAttribute(
              "rid",
              /** @type {string} */
              filter.rid
            );
          }
          function writeSpatialFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            parent["srsName"] = filter.srsName;
            var format = GML_FORMATS[version];
            writePropertyName(version, node, filter.geometryName);
            format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
          }
          function writeDWithinFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            writeSpatialFilter(node, filter, objectStack);
            var distance = createElementNS(getFilterNS(version), "Distance");
            writeStringTextNode(distance, filter.distance.toString());
            if (version === "2.0.0") {
              distance.setAttribute("uom", filter.unit);
            } else {
              distance.setAttribute("units", filter.unit);
            }
            node.appendChild(distance);
          }
          function writeDuringFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            writeExpression(FESNS[version], "ValueReference", node, filter.propertyName);
            var timePeriod = createElementNS(GMLNS, "TimePeriod");
            node.appendChild(timePeriod);
            var begin = createElementNS(GMLNS, "begin");
            timePeriod.appendChild(begin);
            writeTimeInstant(begin, filter.begin);
            var end = createElementNS(GMLNS, "end");
            timePeriod.appendChild(end);
            writeTimeInstant(end, filter.end);
          }
          function writeLogicalFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var item = { node };
            Object(ol_obj[
              "a"
              /* assign */
            ])(item, { context });
            var conditions = filter.conditions;
            for (var i = 0, ii = conditions.length; i < ii; ++i) {
              var condition = conditions[i];
              pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
            }
          }
          function writeNotFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var item = { node };
            Object(ol_obj[
              "a"
              /* assign */
            ])(item, { context });
            var condition = filter.condition;
            pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
          }
          function writeComparisonFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            if (filter.matchCase !== void 0) {
              node.setAttribute("matchCase", filter.matchCase.toString());
            }
            writePropertyName(version, node, filter.propertyName);
            writeLiteral(version, node, "" + filter.expression);
          }
          function writeIsNullFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            writePropertyName(version, node, filter.propertyName);
          }
          function writeIsBetweenFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            var ns = getFilterNS(version);
            writePropertyName(version, node, filter.propertyName);
            var lowerBoundary = createElementNS(ns, "LowerBoundary");
            node.appendChild(lowerBoundary);
            writeLiteral(version, lowerBoundary, "" + filter.lowerBoundary);
            var upperBoundary = createElementNS(ns, "UpperBoundary");
            node.appendChild(upperBoundary);
            writeLiteral(version, upperBoundary, "" + filter.upperBoundary);
          }
          function writeIsLikeFilter(node, filter, objectStack) {
            var parent = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var context = parent["context"];
            var version = context["version"];
            node.setAttribute("wildCard", filter.wildCard);
            node.setAttribute("singleChar", filter.singleChar);
            node.setAttribute("escapeChar", filter.escapeChar);
            if (filter.matchCase !== void 0) {
              node.setAttribute("matchCase", filter.matchCase.toString());
            }
            writePropertyName(version, node, filter.propertyName);
            writeLiteral(version, node, "" + filter.pattern);
          }
          function writeExpression(ns, tagName, node, value) {
            var property = createElementNS(ns, tagName);
            writeStringTextNode(property, value);
            node.appendChild(property);
          }
          function writeLiteral(version, node, value) {
            writeExpression(getFilterNS(version), "Literal", node, value);
          }
          function writePropertyName(version, node, value) {
            if (version === "2.0.0") {
              writeExpression(FESNS[version], "ValueReference", node, value);
            } else {
              writeExpression(OGCNS[version], "PropertyName", node, value);
            }
          }
          function writeTimeInstant(node, time) {
            var timeInstant = createElementNS(GMLNS, "TimeInstant");
            node.appendChild(timeInstant);
            var timePosition = createElementNS(GMLNS, "timePosition");
            timeInstant.appendChild(timePosition);
            writeStringTextNode(timePosition, time);
          }
          function writeFilter(filter, opt_version) {
            var version = opt_version || "1.1.0";
            var child = createElementNS(getFilterNS(version), "Filter");
            var context = {
              node: child
            };
            Object(ol_obj[
              "a"
              /* assign */
            ])(context, {
              "version": version,
              "filter": filter
            });
            writeFilterCondition(child, filter, [context]);
            return child;
          }
          function writeGetFeature(node, featureTypes, objectStack) {
            var context = (
              /** @type {Object} */
              objectStack[objectStack.length - 1]
            );
            var item = (
              /** @type {import("../xml.js").NodeStackItem} */
              Object(ol_obj[
                "a"
                /* assign */
              ])({}, context)
            );
            item.node = node;
            pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory("Query"), featureTypes, objectStack);
          }
          function getFilterNS(version) {
            var ns;
            if (version === "2.0.0") {
              ns = FESNS[version];
            } else {
              ns = OGCNS[version];
            }
            return ns;
          }
          var format_WFS = WFS_WFS;
          var WKT_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var GeometryConstructor = {
            "POINT": geom_Point,
            "LINESTRING": geom_LineString,
            "POLYGON": geom_Polygon,
            "MULTIPOINT": geom_MultiPoint,
            "MULTILINESTRING": geom_MultiLineString,
            "MULTIPOLYGON": geom_MultiPolygon
          };
          var EMPTY = "EMPTY";
          var Z = "Z";
          var M = "M";
          var ZM = "ZM";
          var TokenType = {
            START: 0,
            TEXT: 1,
            LEFT_PAREN: 2,
            RIGHT_PAREN: 3,
            NUMBER: 4,
            COMMA: 5,
            EOF: 6
          };
          var WKTGeometryType = {};
          for (var WKT_type in geom_GeometryType) {
            WKTGeometryType[WKT_type] = geom_GeometryType[WKT_type].toUpperCase();
          }
          var Lexer = (
            /** @class */
            function() {
              function Lexer2(wkt) {
                this.wkt = wkt;
                this.index_ = -1;
              }
              Lexer2.prototype.isAlpha_ = function(c) {
                return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
              };
              Lexer2.prototype.isNumeric_ = function(c, opt_decimal) {
                var decimal = opt_decimal !== void 0 ? opt_decimal : false;
                return c >= "0" && c <= "9" || c == "." && !decimal;
              };
              Lexer2.prototype.isWhiteSpace_ = function(c) {
                return c == " " || c == "	" || c == "\r" || c == "\n";
              };
              Lexer2.prototype.nextChar_ = function() {
                return this.wkt.charAt(++this.index_);
              };
              Lexer2.prototype.nextToken = function() {
                var c = this.nextChar_();
                var position = this.index_;
                var value = c;
                var type;
                if (c == "(") {
                  type = TokenType.LEFT_PAREN;
                } else if (c == ",") {
                  type = TokenType.COMMA;
                } else if (c == ")") {
                  type = TokenType.RIGHT_PAREN;
                } else if (this.isNumeric_(c) || c == "-") {
                  type = TokenType.NUMBER;
                  value = this.readNumber_();
                } else if (this.isAlpha_(c)) {
                  type = TokenType.TEXT;
                  value = this.readText_();
                } else if (this.isWhiteSpace_(c)) {
                  return this.nextToken();
                } else if (c === "") {
                  type = TokenType.EOF;
                } else {
                  throw new Error("Unexpected character: " + c);
                }
                return { position, value, type };
              };
              Lexer2.prototype.readNumber_ = function() {
                var c;
                var index = this.index_;
                var decimal = false;
                var scientificNotation = false;
                do {
                  if (c == ".") {
                    decimal = true;
                  } else if (c == "e" || c == "E") {
                    scientificNotation = true;
                  }
                  c = this.nextChar_();
                } while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'
                // hint that we should continue to read
                !scientificNotation && (c == "e" || c == "E") || // once we know that we have a scientific number, both '-' and '+'
                // are allowed
                scientificNotation && (c == "-" || c == "+"));
                return parseFloat(this.wkt.substring(index, this.index_--));
              };
              Lexer2.prototype.readText_ = function() {
                var c;
                var index = this.index_;
                do {
                  c = this.nextChar_();
                } while (this.isAlpha_(c));
                return this.wkt.substring(index, this.index_--).toUpperCase();
              };
              return Lexer2;
            }()
          );
          var WKT_Parser = (
            /** @class */
            function() {
              function Parser(lexer) {
                this.lexer_ = lexer;
                this.token_ = {
                  position: 0,
                  type: TokenType.START
                };
                this.layout_ = GeometryLayout.XY;
              }
              Parser.prototype.consume_ = function() {
                this.token_ = this.lexer_.nextToken();
              };
              Parser.prototype.isTokenType = function(type) {
                return this.token_.type == type;
              };
              Parser.prototype.match = function(type) {
                var isMatch = this.isTokenType(type);
                if (isMatch) {
                  this.consume_();
                }
                return isMatch;
              };
              Parser.prototype.parse = function() {
                this.consume_();
                return this.parseGeometry_();
              };
              Parser.prototype.parseGeometryLayout_ = function() {
                var layout = GeometryLayout.XY;
                var dimToken = this.token_;
                if (this.isTokenType(TokenType.TEXT)) {
                  var dimInfo = dimToken.value;
                  if (dimInfo === Z) {
                    layout = GeometryLayout.XYZ;
                  } else if (dimInfo === M) {
                    layout = GeometryLayout.XYM;
                  } else if (dimInfo === ZM) {
                    layout = GeometryLayout.XYZM;
                  }
                  if (layout !== GeometryLayout.XY) {
                    this.consume_();
                  }
                }
                return layout;
              };
              Parser.prototype.parseGeometryCollectionText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var geometries = [];
                  do {
                    geometries.push(this.parseGeometry_());
                  } while (this.match(TokenType.COMMA));
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return geometries;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parsePointText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = this.parsePoint_();
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parseLineStringText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = this.parsePointList_();
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parsePolygonText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = this.parseLineStringTextList_();
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parseMultiPointText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = void 0;
                  if (this.token_.type == TokenType.LEFT_PAREN) {
                    coordinates = this.parsePointTextList_();
                  } else {
                    coordinates = this.parsePointList_();
                  }
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parseMultiLineStringText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = this.parseLineStringTextList_();
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parseMultiPolygonText_ = function() {
                if (this.match(TokenType.LEFT_PAREN)) {
                  var coordinates = this.parsePolygonTextList_();
                  if (this.match(TokenType.RIGHT_PAREN)) {
                    return coordinates;
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parsePoint_ = function() {
                var coordinates = [];
                var dimensions = this.layout_.length;
                for (var i = 0; i < dimensions; ++i) {
                  var token = this.token_;
                  if (this.match(TokenType.NUMBER)) {
                    coordinates.push(
                      /** @type {number} */
                      token.value
                    );
                  } else {
                    break;
                  }
                }
                if (coordinates.length == dimensions) {
                  return coordinates;
                }
                throw new Error(this.formatErrorMessage_());
              };
              Parser.prototype.parsePointList_ = function() {
                var coordinates = [this.parsePoint_()];
                while (this.match(TokenType.COMMA)) {
                  coordinates.push(this.parsePoint_());
                }
                return coordinates;
              };
              Parser.prototype.parsePointTextList_ = function() {
                var coordinates = [this.parsePointText_()];
                while (this.match(TokenType.COMMA)) {
                  coordinates.push(this.parsePointText_());
                }
                return coordinates;
              };
              Parser.prototype.parseLineStringTextList_ = function() {
                var coordinates = [this.parseLineStringText_()];
                while (this.match(TokenType.COMMA)) {
                  coordinates.push(this.parseLineStringText_());
                }
                return coordinates;
              };
              Parser.prototype.parsePolygonTextList_ = function() {
                var coordinates = [this.parsePolygonText_()];
                while (this.match(TokenType.COMMA)) {
                  coordinates.push(this.parsePolygonText_());
                }
                return coordinates;
              };
              Parser.prototype.isEmptyGeometry_ = function() {
                var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
                if (isEmpty) {
                  this.consume_();
                }
                return isEmpty;
              };
              Parser.prototype.formatErrorMessage_ = function() {
                return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
              };
              Parser.prototype.parseGeometry_ = function() {
                var token = this.token_;
                if (this.match(TokenType.TEXT)) {
                  var geomType = (
                    /** @type {string} */
                    token.value
                  );
                  this.layout_ = this.parseGeometryLayout_();
                  var isEmpty = this.isEmptyGeometry_();
                  if (geomType == "GEOMETRYCOLLECTION") {
                    if (isEmpty) {
                      return new geom_GeometryCollection([]);
                    }
                    var geometries = this.parseGeometryCollectionText_();
                    return new geom_GeometryCollection(geometries);
                  } else {
                    var ctor = GeometryConstructor[geomType];
                    if (!ctor) {
                      throw new Error("Invalid geometry type: " + geomType);
                    }
                    var coordinates = void 0;
                    if (isEmpty) {
                      if (geomType == "POINT") {
                        coordinates = [NaN, NaN];
                      } else {
                        coordinates = [];
                      }
                    } else {
                      switch (geomType) {
                        case "POINT": {
                          coordinates = this.parsePointText_();
                          break;
                        }
                        case "LINESTRING": {
                          coordinates = this.parseLineStringText_();
                          break;
                        }
                        case "POLYGON": {
                          coordinates = this.parsePolygonText_();
                          break;
                        }
                        case "MULTIPOINT": {
                          coordinates = this.parseMultiPointText_();
                          break;
                        }
                        case "MULTILINESTRING": {
                          coordinates = this.parseMultiLineStringText_();
                          break;
                        }
                        case "MULTIPOLYGON": {
                          coordinates = this.parseMultiPolygonText_();
                          break;
                        }
                        default:
                          break;
                      }
                    }
                    return new ctor(coordinates, this.layout_);
                  }
                }
                throw new Error(this.formatErrorMessage_());
              };
              return Parser;
            }()
          );
          var WKT_WKT = (
            /** @class */
            function(_super) {
              WKT_extends(WKT, _super);
              function WKT(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
                return _this;
              }
              WKT.prototype.parse_ = function(wkt) {
                var lexer = new Lexer(wkt);
                var parser = new WKT_Parser(lexer);
                return parser.parse();
              };
              WKT.prototype.readFeatureFromText = function(text, opt_options) {
                var geom = this.readGeometryFromText(text, opt_options);
                var feature = new ol_Feature();
                feature.setGeometry(geom);
                return feature;
              };
              WKT.prototype.readFeaturesFromText = function(text, opt_options) {
                var geometries = [];
                var geometry = this.readGeometryFromText(text, opt_options);
                if (this.splitCollection_ && geometry.getType() == geom_GeometryType.GEOMETRY_COLLECTION) {
                  geometries = /** @type {GeometryCollection} */
                  geometry.getGeometriesArray();
                } else {
                  geometries = [geometry];
                }
                var features = [];
                for (var i = 0, ii = geometries.length; i < ii; ++i) {
                  var feature = new ol_Feature();
                  feature.setGeometry(geometries[i]);
                  features.push(feature);
                }
                return features;
              };
              WKT.prototype.readGeometryFromText = function(text, opt_options) {
                var geometry = this.parse_(text);
                return transformGeometryWithOptions(geometry, false, opt_options);
              };
              WKT.prototype.writeFeatureText = function(feature, opt_options) {
                var geometry = feature.getGeometry();
                if (geometry) {
                  return this.writeGeometryText(geometry, opt_options);
                }
                return "";
              };
              WKT.prototype.writeFeaturesText = function(features, opt_options) {
                if (features.length == 1) {
                  return this.writeFeatureText(features[0], opt_options);
                }
                var geometries = [];
                for (var i = 0, ii = features.length; i < ii; ++i) {
                  geometries.push(features[i].getGeometry());
                }
                var collection = new geom_GeometryCollection(geometries);
                return this.writeGeometryText(collection, opt_options);
              };
              WKT.prototype.writeGeometryText = function(geometry, opt_options) {
                return encode(transformGeometryWithOptions(geometry, true, opt_options));
              };
              return WKT;
            }(format_TextFeature)
          );
          function encodePointGeometry(geom) {
            var coordinates = geom.getCoordinates();
            if (coordinates.length === 0) {
              return "";
            }
            return coordinates.join(" ");
          }
          function encodeMultiPointGeometry(geom) {
            var array = [];
            var components = geom.getPoints();
            for (var i = 0, ii = components.length; i < ii; ++i) {
              array.push("(" + encodePointGeometry(components[i]) + ")");
            }
            return array.join(",");
          }
          function encodeGeometryCollectionGeometry(geom) {
            var array = [];
            var geoms = geom.getGeometries();
            for (var i = 0, ii = geoms.length; i < ii; ++i) {
              array.push(encode(geoms[i]));
            }
            return array.join(",");
          }
          function encodeLineStringGeometry(geom) {
            var coordinates = geom.getCoordinates();
            var array = [];
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              array.push(coordinates[i].join(" "));
            }
            return array.join(",");
          }
          function encodeMultiLineStringGeometry(geom) {
            var array = [];
            var components = geom.getLineStrings();
            for (var i = 0, ii = components.length; i < ii; ++i) {
              array.push("(" + encodeLineStringGeometry(components[i]) + ")");
            }
            return array.join(",");
          }
          function encodePolygonGeometry(geom) {
            var array = [];
            var rings = geom.getLinearRings();
            for (var i = 0, ii = rings.length; i < ii; ++i) {
              array.push("(" + encodeLineStringGeometry(rings[i]) + ")");
            }
            return array.join(",");
          }
          function encodeMultiPolygonGeometry(geom) {
            var array = [];
            var components = geom.getPolygons();
            for (var i = 0, ii = components.length; i < ii; ++i) {
              array.push("(" + encodePolygonGeometry(components[i]) + ")");
            }
            return array.join(",");
          }
          function encodeGeometryLayout(geom) {
            var layout = geom.getLayout();
            var dimInfo = "";
            if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {
              dimInfo += Z;
            }
            if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {
              dimInfo += M;
            }
            return dimInfo;
          }
          var GeometryEncoder = {
            "Point": encodePointGeometry,
            "LineString": encodeLineStringGeometry,
            "Polygon": encodePolygonGeometry,
            "MultiPoint": encodeMultiPointGeometry,
            "MultiLineString": encodeMultiLineStringGeometry,
            "MultiPolygon": encodeMultiPolygonGeometry,
            "GeometryCollection": encodeGeometryCollectionGeometry
          };
          function encode(geom) {
            var type = geom.getType();
            var geometryEncoder = GeometryEncoder[type];
            var enc = geometryEncoder(geom);
            type = type.toUpperCase();
            if (typeof /** @type {?} */
            geom.getFlatCoordinates === "function") {
              var dimInfo = encodeGeometryLayout(
                /** @type {import("../geom/SimpleGeometry.js").default} */
                geom
              );
              if (dimInfo.length > 0) {
                type += " " + dimInfo;
              }
            }
            if (enc.length === 0) {
              return type + " " + EMPTY;
            }
            return type + "(" + enc + ")";
          }
          var format_WKT = WKT_WKT;
          var WMSCapabilities_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var WMSCapabilities_NAMESPACE_URIS = [null, "http://www.opengis.net/wms"];
          var WMSCapabilities_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Service": makeObjectPropertySetter(readService),
            "Capability": makeObjectPropertySetter(readCapability)
          });
          var CAPABILITY_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Request": makeObjectPropertySetter(readRequest),
            "Exception": makeObjectPropertySetter(readException),
            "Layer": makeObjectPropertySetter(readCapabilityLayer)
          });
          var WMSCapabilities_WMSCapabilities = (
            /** @class */
            function(_super) {
              WMSCapabilities_extends(WMSCapabilities, _super);
              function WMSCapabilities() {
                var _this = _super.call(this) || this;
                _this.version = void 0;
                return _this;
              }
              WMSCapabilities.prototype.readFromNode = function(node) {
                this.version = node.getAttribute("version").trim();
                var wmsCapabilityObject = pushParseAndPop({
                  "version": this.version
                }, WMSCapabilities_PARSERS, node, []);
                return wmsCapabilityObject ? wmsCapabilityObject : null;
              };
              return WMSCapabilities;
            }(format_XML)
          );
          var SERVICE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Name": makeObjectPropertySetter(readString),
            "Title": makeObjectPropertySetter(readString),
            "Abstract": makeObjectPropertySetter(readString),
            "KeywordList": makeObjectPropertySetter(readKeywordList),
            "OnlineResource": makeObjectPropertySetter(readHref),
            "ContactInformation": makeObjectPropertySetter(readContactInformation),
            "Fees": makeObjectPropertySetter(readString),
            "AccessConstraints": makeObjectPropertySetter(readString),
            "LayerLimit": makeObjectPropertySetter(readNonNegativeInteger),
            "MaxWidth": makeObjectPropertySetter(readNonNegativeInteger),
            "MaxHeight": makeObjectPropertySetter(readNonNegativeInteger)
          });
          var CONTACT_INFORMATION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
            "ContactPosition": makeObjectPropertySetter(readString),
            "ContactAddress": makeObjectPropertySetter(readContactAddress),
            "ContactVoiceTelephone": makeObjectPropertySetter(readString),
            "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
            "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
          });
          var CONTACT_PERSON_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "ContactPerson": makeObjectPropertySetter(readString),
            "ContactOrganization": makeObjectPropertySetter(readString)
          });
          var CONTACT_ADDRESS_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "AddressType": makeObjectPropertySetter(readString),
            "Address": makeObjectPropertySetter(readString),
            "City": makeObjectPropertySetter(readString),
            "StateOrProvince": makeObjectPropertySetter(readString),
            "PostCode": makeObjectPropertySetter(readString),
            "Country": makeObjectPropertySetter(readString)
          });
          var EXCEPTION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Format": makeArrayPusher(readString)
          });
          var LAYER_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Name": makeObjectPropertySetter(readString),
            "Title": makeObjectPropertySetter(readString),
            "Abstract": makeObjectPropertySetter(readString),
            "KeywordList": makeObjectPropertySetter(readKeywordList),
            "CRS": makeObjectPropertyPusher(readString),
            "EX_GeographicBoundingBox": makeObjectPropertySetter(readEXGeographicBoundingBox),
            "BoundingBox": makeObjectPropertyPusher(readBoundingBox),
            "Dimension": makeObjectPropertyPusher(readDimension),
            "Attribution": makeObjectPropertySetter(readAttribution),
            "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
            "Identifier": makeObjectPropertyPusher(readString),
            "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
            "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
            "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
            "Style": makeObjectPropertyPusher(WMSCapabilities_readStyle),
            "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
            "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
            "Layer": makeObjectPropertyPusher(readLayer)
          });
          var ATTRIBUTION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Title": makeObjectPropertySetter(readString),
            "OnlineResource": makeObjectPropertySetter(readHref),
            "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
          });
          var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "westBoundLongitude": makeObjectPropertySetter(readDecimal),
            "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
            "southBoundLatitude": makeObjectPropertySetter(readDecimal),
            "northBoundLatitude": makeObjectPropertySetter(readDecimal)
          });
          var REQUEST_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "GetCapabilities": makeObjectPropertySetter(readOperationType),
            "GetMap": makeObjectPropertySetter(readOperationType),
            "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
          });
          var OPERATIONTYPE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Format": makeObjectPropertyPusher(readString),
            "DCPType": makeObjectPropertyPusher(readDCPType)
          });
          var DCPTYPE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "HTTP": makeObjectPropertySetter(readHTTP)
          });
          var WMSCapabilities_HTTP_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Get": makeObjectPropertySetter(readFormatOnlineresource),
            "Post": makeObjectPropertySetter(readFormatOnlineresource)
          });
          var WMSCapabilities_STYLE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Name": makeObjectPropertySetter(readString),
            "Title": makeObjectPropertySetter(readString),
            "Abstract": makeObjectPropertySetter(readString),
            "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
            "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
            "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
          });
          var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Format": makeObjectPropertySetter(readString),
            "OnlineResource": makeObjectPropertySetter(readHref)
          });
          var KEYWORDLIST_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
            "Keyword": makeArrayPusher(readString)
          });
          function readAttribution(node, objectStack) {
            return pushParseAndPop({}, ATTRIBUTION_PARSERS, node, objectStack);
          }
          function readBoundingBox(node, objectStack) {
            var extent = [
              readDecimalString(node.getAttribute("minx")),
              readDecimalString(node.getAttribute("miny")),
              readDecimalString(node.getAttribute("maxx")),
              readDecimalString(node.getAttribute("maxy"))
            ];
            var resolutions = [
              readDecimalString(node.getAttribute("resx")),
              readDecimalString(node.getAttribute("resy"))
            ];
            return {
              "crs": node.getAttribute("CRS"),
              "extent": extent,
              "res": resolutions
            };
          }
          function readEXGeographicBoundingBox(node, objectStack) {
            var geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node, objectStack);
            if (!geographicBoundingBox) {
              return void 0;
            }
            var westBoundLongitude = (
              /** @type {number|undefined} */
              geographicBoundingBox["westBoundLongitude"]
            );
            var southBoundLatitude = (
              /** @type {number|undefined} */
              geographicBoundingBox["southBoundLatitude"]
            );
            var eastBoundLongitude = (
              /** @type {number|undefined} */
              geographicBoundingBox["eastBoundLongitude"]
            );
            var northBoundLatitude = (
              /** @type {number|undefined} */
              geographicBoundingBox["northBoundLatitude"]
            );
            if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
              return void 0;
            }
            return [
              westBoundLongitude,
              southBoundLatitude,
              eastBoundLongitude,
              northBoundLatitude
            ];
          }
          function readCapability(node, objectStack) {
            return pushParseAndPop({}, CAPABILITY_PARSERS, node, objectStack);
          }
          function readService(node, objectStack) {
            return pushParseAndPop({}, SERVICE_PARSERS, node, objectStack);
          }
          function readContactInformation(node, objectStack) {
            return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
          }
          function readContactPersonPrimary(node, objectStack) {
            return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node, objectStack);
          }
          function readContactAddress(node, objectStack) {
            return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
          }
          function readException(node, objectStack) {
            return pushParseAndPop([], EXCEPTION_PARSERS, node, objectStack);
          }
          function readCapabilityLayer(node, objectStack) {
            var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
            if (layerObject["Layer"] === void 0) {
              return Object.assign(layerObject, readLayer(node, objectStack));
            }
            return layerObject;
          }
          function readLayer(node, objectStack) {
            var parentLayerObject = (
              /**  @type {!Object<string,*>} */
              objectStack[objectStack.length - 1]
            );
            var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
            if (!layerObject) {
              return void 0;
            }
            var queryable = readBooleanString(node.getAttribute("queryable"));
            if (queryable === void 0) {
              queryable = parentLayerObject["queryable"];
            }
            layerObject["queryable"] = queryable !== void 0 ? queryable : false;
            var cascaded = readNonNegativeIntegerString(node.getAttribute("cascaded"));
            if (cascaded === void 0) {
              cascaded = parentLayerObject["cascaded"];
            }
            layerObject["cascaded"] = cascaded;
            var opaque = readBooleanString(node.getAttribute("opaque"));
            if (opaque === void 0) {
              opaque = parentLayerObject["opaque"];
            }
            layerObject["opaque"] = opaque !== void 0 ? opaque : false;
            var noSubsets = readBooleanString(node.getAttribute("noSubsets"));
            if (noSubsets === void 0) {
              noSubsets = parentLayerObject["noSubsets"];
            }
            layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
            var fixedWidth = readDecimalString(node.getAttribute("fixedWidth"));
            if (!fixedWidth) {
              fixedWidth = parentLayerObject["fixedWidth"];
            }
            layerObject["fixedWidth"] = fixedWidth;
            var fixedHeight = readDecimalString(node.getAttribute("fixedHeight"));
            if (!fixedHeight) {
              fixedHeight = parentLayerObject["fixedHeight"];
            }
            layerObject["fixedHeight"] = fixedHeight;
            var addKeys = ["Style", "CRS", "AuthorityURL"];
            addKeys.forEach(function(key) {
              if (key in parentLayerObject) {
                var childValue = layerObject[key] || [];
                layerObject[key] = childValue.concat(parentLayerObject[key]);
              }
            });
            var replaceKeys = [
              "EX_GeographicBoundingBox",
              "BoundingBox",
              "Dimension",
              "Attribution",
              "MinScaleDenominator",
              "MaxScaleDenominator"
            ];
            replaceKeys.forEach(function(key) {
              if (!(key in layerObject)) {
                var parentValue = parentLayerObject[key];
                layerObject[key] = parentValue;
              }
            });
            return layerObject;
          }
          function readDimension(node, objectStack) {
            var dimensionObject = {
              "name": node.getAttribute("name"),
              "units": node.getAttribute("units"),
              "unitSymbol": node.getAttribute("unitSymbol"),
              "default": node.getAttribute("default"),
              "multipleValues": readBooleanString(node.getAttribute("multipleValues")),
              "nearestValue": readBooleanString(node.getAttribute("nearestValue")),
              "current": readBooleanString(node.getAttribute("current")),
              "values": readString(node)
            };
            return dimensionObject;
          }
          function readFormatOnlineresource(node, objectStack) {
            return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
          }
          function readRequest(node, objectStack) {
            return pushParseAndPop({}, REQUEST_PARSERS, node, objectStack);
          }
          function readDCPType(node, objectStack) {
            return pushParseAndPop({}, DCPTYPE_PARSERS, node, objectStack);
          }
          function readHTTP(node, objectStack) {
            return pushParseAndPop({}, WMSCapabilities_HTTP_PARSERS, node, objectStack);
          }
          function readOperationType(node, objectStack) {
            return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node, objectStack);
          }
          function readSizedFormatOnlineresource(node, objectStack) {
            var formatOnlineresource = readFormatOnlineresource(node, objectStack);
            if (formatOnlineresource) {
              var size = [
                readNonNegativeIntegerString(node.getAttribute("width")),
                readNonNegativeIntegerString(node.getAttribute("height"))
              ];
              formatOnlineresource["size"] = size;
              return formatOnlineresource;
            }
            return void 0;
          }
          function readAuthorityURL(node, objectStack) {
            var authorityObject = readFormatOnlineresource(node, objectStack);
            if (authorityObject) {
              authorityObject["name"] = node.getAttribute("name");
              return authorityObject;
            }
            return void 0;
          }
          function readMetadataURL(node, objectStack) {
            var metadataObject = readFormatOnlineresource(node, objectStack);
            if (metadataObject) {
              metadataObject["type"] = node.getAttribute("type");
              return metadataObject;
            }
            return void 0;
          }
          function WMSCapabilities_readStyle(node, objectStack) {
            return pushParseAndPop({}, WMSCapabilities_STYLE_PARSERS, node, objectStack);
          }
          function readKeywordList(node, objectStack) {
            return pushParseAndPop([], KEYWORDLIST_PARSERS, node, objectStack);
          }
          var format_WMSCapabilities = WMSCapabilities_WMSCapabilities;
          var WMSGetFeatureInfo_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var featureIdentifier = "_feature";
          var layerIdentifier = "_layer";
          var WMSGetFeatureInfo_WMSGetFeatureInfo = (
            /** @class */
            function(_super) {
              WMSGetFeatureInfo_extends(WMSGetFeatureInfo, _super);
              function WMSGetFeatureInfo(opt_options) {
                var _this = _super.call(this) || this;
                var options = opt_options ? opt_options : {};
                _this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
                _this.gmlFormat_ = new format_GML2();
                _this.layers_ = options.layers ? options.layers : null;
                return _this;
              }
              WMSGetFeatureInfo.prototype.getLayers = function() {
                return this.layers_;
              };
              WMSGetFeatureInfo.prototype.setLayers = function(layers) {
                this.layers_ = layers;
              };
              WMSGetFeatureInfo.prototype.readFeatures_ = function(node, objectStack) {
                node.setAttribute("namespaceURI", this.featureNS_);
                var localName = node.localName;
                var features = [];
                if (node.childNodes.length === 0) {
                  return features;
                }
                if (localName == "msGMLOutput") {
                  for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
                    var layer = node.childNodes[i];
                    if (layer.nodeType !== Node.ELEMENT_NODE) {
                      continue;
                    }
                    var layerElement = (
                      /** @type {Element} */
                      layer
                    );
                    var context = objectStack[0];
                    var toRemove = layerIdentifier;
                    var layerName = layerElement.localName.replace(toRemove, "");
                    if (this.layers_ && !Object(ol_array[
                      "f"
                      /* includes */
                    ])(this.layers_, layerName)) {
                      continue;
                    }
                    var featureType = layerName + featureIdentifier;
                    context["featureType"] = featureType;
                    context["featureNS"] = this.featureNS_;
                    var parsers = {};
                    parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
                    var parsersNS = makeStructureNS([context["featureNS"], null], parsers);
                    layerElement.setAttribute("namespaceURI", this.featureNS_);
                    var layerFeatures = pushParseAndPop(
                      [],
                      // @ts-ignore
                      parsersNS,
                      layerElement,
                      objectStack,
                      this.gmlFormat_
                    );
                    if (layerFeatures) {
                      Object(ol_array[
                        "c"
                        /* extend */
                      ])(features, layerFeatures);
                    }
                  }
                }
                if (localName == "FeatureCollection") {
                  var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);
                  if (gmlFeatures) {
                    features = gmlFeatures;
                  }
                }
                return features;
              };
              WMSGetFeatureInfo.prototype.readFeaturesFromNode = function(node, opt_options) {
                var options = {};
                if (opt_options) {
                  Object(ol_obj[
                    "a"
                    /* assign */
                  ])(options, this.getReadOptions(node, opt_options));
                }
                return this.readFeatures_(node, [options]);
              };
              return WMSGetFeatureInfo;
            }(format_XMLFeature)
          );
          var format_WMSGetFeatureInfo = WMSGetFeatureInfo_WMSGetFeatureInfo;
          var WMTSCapabilities_extends = /* @__PURE__ */ function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var WMTSCapabilities_NAMESPACE_URIS = [null, "http://www.opengis.net/wmts/1.0"];
          var WMTSCapabilities_OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
          var WMTSCapabilities_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "Contents": makeObjectPropertySetter(readContents)
          });
          var WMTSCapabilities_WMTSCapabilities = (
            /** @class */
            function(_super) {
              WMTSCapabilities_extends(WMTSCapabilities, _super);
              function WMTSCapabilities() {
                var _this = _super.call(this) || this;
                _this.owsParser_ = new format_OWS();
                return _this;
              }
              WMTSCapabilities.prototype.readFromNode = function(node) {
                var version = node.getAttribute("version");
                if (version) {
                  version = version.trim();
                }
                var WMTSCapabilityObject = this.owsParser_.readFromNode(node);
                if (!WMTSCapabilityObject) {
                  return null;
                }
                WMTSCapabilityObject["version"] = version;
                WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, WMTSCapabilities_PARSERS, node, []);
                return WMTSCapabilityObject ? WMTSCapabilityObject : null;
              };
              return WMTSCapabilities;
            }(format_XML)
          );
          var CONTENTS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "Layer": makeObjectPropertyPusher(WMTSCapabilities_readLayer),
            "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
          });
          var WMTSCapabilities_LAYER_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "Style": makeObjectPropertyPusher(WMTSCapabilities_readStyle),
            "Format": makeObjectPropertyPusher(readString),
            "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
            "Dimension": makeObjectPropertyPusher(readDimensions),
            "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
          }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "Title": makeObjectPropertySetter(readString),
            "Abstract": makeObjectPropertySetter(readString),
            "WGS84BoundingBox": makeObjectPropertySetter(WMTSCapabilities_readBoundingBox),
            "Identifier": makeObjectPropertySetter(readString)
          }));
          var WMTSCapabilities_STYLE_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "LegendURL": makeObjectPropertyPusher(readLegendUrl)
          }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "Title": makeObjectPropertySetter(readString),
            "Identifier": makeObjectPropertySetter(readString)
          }));
          var TMS_LINKS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "TileMatrixSet": makeObjectPropertySetter(readString),
            "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
          });
          var TMS_LIMITS_LIST_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
          });
          var TMS_LIMITS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "TileMatrix": makeObjectPropertySetter(readString),
            "MinTileRow": makeObjectPropertySetter(readNonNegativeInteger),
            "MaxTileRow": makeObjectPropertySetter(readNonNegativeInteger),
            "MinTileCol": makeObjectPropertySetter(readNonNegativeInteger),
            "MaxTileCol": makeObjectPropertySetter(readNonNegativeInteger)
          });
          var DIMENSION_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "Default": makeObjectPropertySetter(readString),
            "Value": makeObjectPropertyPusher(readString)
          }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "Identifier": makeObjectPropertySetter(readString)
          }));
          var WGS84_BBOX_READERS = makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "LowerCorner": makeArrayPusher(readCoordinates),
            "UpperCorner": makeArrayPusher(readCoordinates)
          });
          var TMS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "WellKnownScaleSet": makeObjectPropertySetter(readString),
            "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
          }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "SupportedCRS": makeObjectPropertySetter(readString),
            "Identifier": makeObjectPropertySetter(readString),
            "BoundingBox": makeObjectPropertySetter(WMTSCapabilities_readBoundingBox)
          }));
          var TM_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
            "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
            "ScaleDenominator": makeObjectPropertySetter(readDecimal),
            "TileWidth": makeObjectPropertySetter(readNonNegativeInteger),
            "TileHeight": makeObjectPropertySetter(readNonNegativeInteger),
            "MatrixWidth": makeObjectPropertySetter(readNonNegativeInteger),
            "MatrixHeight": makeObjectPropertySetter(readNonNegativeInteger)
          }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
            "Identifier": makeObjectPropertySetter(readString)
          }));
          function readContents(node, objectStack) {
            return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
          }
          function WMTSCapabilities_readLayer(node, objectStack) {
            return pushParseAndPop({}, WMTSCapabilities_LAYER_PARSERS, node, objectStack);
          }
          function readTileMatrixSet(node, objectStack) {
            return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
          }
          function WMTSCapabilities_readStyle(node, objectStack) {
            var style = pushParseAndPop({}, WMTSCapabilities_STYLE_PARSERS, node, objectStack);
            if (!style) {
              return void 0;
            }
            var isDefault = node.getAttribute("isDefault") === "true";
            style["isDefault"] = isDefault;
            return style;
          }
          function readTileMatrixSetLink(node, objectStack) {
            return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
          }
          function readDimensions(node, objectStack) {
            return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
          }
          function readResourceUrl(node, objectStack) {
            var format = node.getAttribute("format");
            var template = node.getAttribute("template");
            var resourceType = node.getAttribute("resourceType");
            var resource = {};
            if (format) {
              resource["format"] = format;
            }
            if (template) {
              resource["template"] = template;
            }
            if (resourceType) {
              resource["resourceType"] = resourceType;
            }
            return resource;
          }
          function WMTSCapabilities_readBoundingBox(node, objectStack) {
            var coordinates = pushParseAndPop([], WGS84_BBOX_READERS, node, objectStack);
            if (coordinates.length != 2) {
              return void 0;
            }
            return boundingExtent(coordinates);
          }
          function readLegendUrl(node, objectStack) {
            var legend = {};
            legend["format"] = node.getAttribute("format");
            legend["href"] = readHref(node);
            return legend;
          }
          function readCoordinates(node, objectStack) {
            var coordinates = readString(node).split(/\s+/);
            if (!coordinates || coordinates.length != 2) {
              return void 0;
            }
            var x = +coordinates[0];
            var y = +coordinates[1];
            if (isNaN(x) || isNaN(y)) {
              return void 0;
            }
            return [x, y];
          }
          function readTileMatrix(node, objectStack) {
            return pushParseAndPop({}, TM_PARSERS, node, objectStack);
          }
          function readTileMatrixLimitsList(node, objectStack) {
            return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
          }
          function readTileMatrixLimits(node, objectStack) {
            return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
          }
          var format_WMTSCapabilities = WMTSCapabilities_WMTSCapabilities;
          function src_install(app) {
            if (src_install.installed) {
              return;
            }
            src_install.installed = true;
            app.use(map_namespaceObject);
            app.use(layers_namespaceObject);
            app.use(sources_namespaceObject);
            app.use(mapControls_namespaceObject);
            app.use(geometries_namespaceObject);
            app.use(styles_namespaceObject);
            app.use(components_interaction_namespaceObject);
            app.use(animations_namespaceObject);
            app.provide("ol-feature", ol_Feature);
            app.provide("ol-geom", geom_namespaceObject);
            app.provide("ol-animations", easing_namespaceObject);
            app.provide("ol-format", format_namespaceObject);
            app.provide("ol-loadingstrategy", loadingstrategy_namespaceObject);
            app.provide("ol-selectconditions", condition_namespaceObject);
            app.provide("ol-extent", extent_namespaceObject);
          }
          var entry_lib = __webpack_exports__["default"] = src_install;
        }
      ),
      /***/
      "fb6a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var isObject2 = __webpack_require__("861d");
          var isArray2 = __webpack_require__("e8b5");
          var toAbsoluteIndex = __webpack_require__("23cb");
          var toLength = __webpack_require__("50c4");
          var toIndexedObject = __webpack_require__("fc6a");
          var createProperty = __webpack_require__("8418");
          var wellKnownSymbol = __webpack_require__("b622");
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
          var SPECIES = wellKnownSymbol("species");
          var nativeSlice = [].slice;
          var max = Math.max;
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            slice: function slice(start, end) {
              var O = toIndexedObject(this);
              var length = toLength(O.length);
              var k = toAbsoluteIndex(start, length);
              var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
              var Constructor, result, n;
              if (isArray2(O)) {
                Constructor = O.constructor;
                if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                  Constructor = void 0;
                } else if (isObject2(Constructor)) {
                  Constructor = Constructor[SPECIES];
                  if (Constructor === null) Constructor = void 0;
                }
                if (Constructor === Array || Constructor === void 0) {
                  return nativeSlice.call(O, k, fin);
                }
              }
              result = new (Constructor === void 0 ? Array : Constructor)(max(fin - k, 0));
              for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
              result.length = n;
              return result;
            }
          });
        }
      ),
      /***/
      "fc6a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var IndexedObject = __webpack_require__("44ad");
          var requireObjectCoercible = __webpack_require__("1d80");
          module2.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        }
      ),
      /***/
      "fdbc": (
        /***/
        function(module2, exports2) {
          module2.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
          };
        }
      ),
      /***/
      "fdbf": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var NATIVE_SYMBOL = __webpack_require__("4930");
          module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
        }
      )
      /******/
    });
  }
});
export default require_vue3_openlayers_common();
/*! Bundled license information:

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.cjs.js:
  (**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue3-openlayers/dist/vue3-openlayers.common.js:
  (*!
    * ol-contextmenu - v4.1.0
    * https://github.com/jonataswalker/ol-contextmenu
    * Built: Sat Aug 15 2020 10:43:26 GMT-0300 (Brasilia Standard Time)
    *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=vue3-openlayers.js.map
